<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Operador (Webcam + IMGBB + Visualizador)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    /* -------------------------
       Estilos gerais
       ------------------------- */
    :root{
      --bg:#0b0b0c;
      --panel:#111;
      --accent:#0b84ff;
      --muted:#9aa;
      --success:#4CAF50;
      --danger:#dc3545;
      --btn-bg:#0b84ff;
      --btn-text:#fff;
    }
    html,body{height:100%;margin:0;padding:18px;background:var(--bg);color:#eee;font-family:Inter,Arial,Helvetica,sans-serif}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0 0 8px 0;font-weight:700}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:var(--btn-bg);color:var(--btn-text);border:0;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:700}
    button.secondary{background:#333}
    button.warn{background:var(--danger)}
    button.success{background:var(--success)}
    .qrcode-container{margin:12px 0;padding:10px;background:var(--panel);border-radius:8px;display:inline-block}
    .section{margin:14px 0;padding:12px;background:linear-gradient(180deg,#0f0f10,#0b0b0b);border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    #thumbs{display:flex;flex-wrap:wrap;gap:8px}
    #thumbs img{width:170px;height:auto;border-radius:6px;border:2px solid #222;object-fit:cover}
    canvas{max-width:100%;display:block;margin-top:12px;border:1px solid #222;background:#000}
    .status{padding:8px;border-radius:8px;background:#0c0c0d;color:#9f9}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    /* Webcam preview */
    #webcamPreview { width: 520px; height: 390px; background:#000; border:1px solid #333; display:block; margin-top:10px; border-radius:8px; object-fit:cover;}
    .small{font-size:13px;padding:6px 8px}
    #log{color:#9f9;margin-top:12px;white-space:pre-wrap;font-family:monospace;font-size:12px;max-height:260px;overflow-y:auto;padding:8px;background:#070707;border-radius:8px}
    .viewer-history{background:#121212;padding:10px;border-radius:6px;margin-top:10px;max-height:200px;overflow:auto}
    .viewer-item{margin:6px 0;padding:6px;background:#0b0b0b;border-radius:4px;border:1px solid rgba(255,255,255,0.02)}
    label{font-size:13px;color:var(--muted);display:block;margin-top:6px}
    input[type=text],select{padding:8px;border-radius:6px;border:1px solid #222;background:#0b0b0b;color:#eee}
    .flex{display:flex;gap:10px;align-items:center}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>üì∏ Cabine Fotogr√°fica ‚Äî Operador</h1>
      <div id="connectionStatus" class="status" style="background:#2b2b2b;color:#fff">üî¥ Desconectado</div>
    </div>
    <div class="controls">
      <button id="genQr" class="small secondary" disabled>Gerar QR Code Celular</button>
      <button id="finalizarSessao" class="small warn" disabled>Finalizar Sess√£o</button>
      <button id="genVisualizadorQr" class="small secondary" disabled>Gerar QR Visualizador + IMGBB</button>
      <button id="printBtn" class="small secondary" disabled>Imprimir (9x14)</button>
      <button id="debugBtn" class="small">Debug</button>
      <button id="testImgbbBtn" class="small success" disabled>Testar IMGBB</button>
      <button id="limparVisualizadorBtn" class="small warn">Limpar Visualizador</button>
    </div>
  </header>

  <div class="section">
    <div class="flex" style="align-items:center;gap:18px;">
      <div>
        <div>Sess√£o fixa:</div>
        <div style="font-weight:800;font-size:18px" id="sessionId">‚Äî</div>
      </div>
      <div id="qrcode" class="qrcode-container"></div>
      <div id="qrcodeVisualizador" class="qrcode-container"></div>
    </div>

    <div style="margin-top:12px" class="flex">
      <div>
        <label>Conectar servidor</label>
        <input id="serverUrl" type="text" value="https://festadodavi.onrender.com" style="width:300px">
      </div>
      <div>
        <label>IMGBB Key</label>
        <input id="imgbbKey" type="text" placeholder="opcional" style="width:320px">
      </div>
    </div>
  </div>

  <div class="section">
    <h3>Controle da Webcam / Stream</h3>
    <div class="controls-row">
      <button id="startWebcamBtn">Iniciar Webcam</button>
      <button id="stopWebcamBtn" disabled>Parar Webcam</button>
      <button id="startStreamBtn" disabled>Iniciar Stream para Celular</button>
      <button id="stopStreamBtn" disabled>Parar Stream</button>

      <label style="margin-left:8px">Resolu√ß√£o</label>
      <select id="resSelect">
        <option value="1280x720">1280√ó720</option>
        <option value="1920x1080">1920√ó1080</option>
        <option value="640x480">640√ó480</option>
      </select>

      <label>FPS</label>
      <select id="fpsSelect">
        <option>15</option>
        <option>24</option>
        <option selected>30</option>
        <option>60</option>
      </select>

      <label>Enviar para</label>
      <select id="streamSelect" style="min-width:220px">
        <option value="">Sess√£o fixa (autom√°tico)</option>
      </select>
    </div>

    <video id="webcamPreview" autoplay muted playsinline></video>

    <div style="margin-top:10px">
      <label>Status do stream</label>
      <div id="streamStatus" style="padding:8px;border-radius:6px;background:#0a0a0a">Nenhum</div>
    </div>
  </div>

  <div class="section">
    <h3>Fotos recebidas</h3>
    <div id="thumbs"></div>
    <div style="margin-top:12px">
      <button id="saveAllBtn" class="small secondary">Salvar Todas</button>
      <button id="clearThumbsBtn" class="small warn">Limpar Miniaturas</button>
    </div>
  </div>

  <div class="section">
    <h3>Preview ‚Äî Montagem Stories</h3>
    <canvas id="storiesCanvas" width="3375" height="6000"></canvas>
    <h3 style="margin-top:12px">Preview ‚Äî Impress√£o (9x14)</h3>
    <canvas id="printCanvas" width="3322" height="5167"></canvas>
  </div>

  <div class="section">
    <h3>Hist√≥rico de Visualizadores</h3>
    <div id="viewerHistory" class="viewer-history">
      <div class="viewer-item">Nenhum visualizador gerado ainda</div>
    </div>
  </div>

  <div id="log" aria-live="polite"></div>

  <!-- hidden audio assets -->
  <audio id="clack" src="clack.mp3" preload="auto"></audio>

  <script>
    /******************************************************************
     * Index completo do operador ‚Äî preserva todas as fun√ß√µes originais
     * + Adiciona streaming da webcam (PC -> celular) autom√°tico.
     *
     * Como usar:
     * - Abra index.html no PC/operador
     * - Permita a webcam
     * - Escaneie o QR no celular (ou abra /celular.html?session=cabine-fixa)
     * - No celular entre em tela cheia e iniciar sess√£o
     * - Fotos ser√£o solicitadas ao operador (take_photo), operador responde com photo_ready
     *
     * Notas:
     * - Ajuste resolu√ß√£o e FPS no painel.
     * - IMGBB: coloque a chave no campo IMGBB Key e clique Testar IMGBB para validar.
     ******************************************************************/

    // ========= Configs iniciais =========
    const DEFAULT_SERVER = document.getElementById('serverUrl').value || 'https://festadodavi.onrender.com';
    let SERVER_URL = DEFAULT_SERVER;
    const SESSION_FIXED = 'cabine-fixa';
    const el = id => document.getElementById(id);

    // Elementos
    const qrcodeEl = el('qrcode'), qrcodeVisualizadorEl = el('qrcodeVisualizador');
    const sessionIdEl = el('sessionId'), viewerHistoryEl = el('viewerHistory');
    const thumbsEl = el('thumbs'), storiesCanvas = el('storiesCanvas'), printCanvas = el('printCanvas');
    const logEl = el('log'), connectionStatusEl = el('connectionStatus');
    const startWebcamBtn = el('startWebcamBtn'), stopWebcamBtn = el('stopWebcamBtn');
    const startStreamBtn = el('startStreamBtn'), stopStreamBtn = el('stopStreamBtn');
    const streamSelect = el('streamSelect'), webcamPreview = el('webcamPreview');
    const resSelect = el('resSelect'), fpsSelect = el('fpsSelect');
    const genQrBtn = el('genQr'), genVisualizadorQrBtn = el('genVisualizadorQr');
    const finalizarBtn = el('finalizarSessao'), printBtn = el('printBtn'), testImgbbBtn = el('testImgbbBtn');
    const limparVisualizadorBtn = el('limparVisualizadorBtn'), debugBtn = el('debugBtn');

    const imgbbKeyInput = el('imgbbKey');
    const serverUrlInput = el('serverUrl');

    let socket = null;
    let localStream = null, webcamStreamActive = false;
    let streamingInterval = null, streamingTargetSession = null;
    let lastPhotos = [], viewerHistory = [], currentViewerSession = null;
    let sessionConnected = false;

    function log(msg){
      const ts = new Date().toLocaleTimeString();
      logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    function updateConnectionStatus(connected){
      if(connected){
        connectionStatusEl.innerHTML = 'üü¢ Conectado ao Servidor';
        connectionStatusEl.style.background = '#0b4';
      } else {
        connectionStatusEl.innerHTML = 'üî¥ Desconectado';
        connectionStatusEl.style.background = '#444';
      }
    }

    // ========= Socket.IO =========
    function initSocket(){
      if(socket && socket.connected) return socket;
      SERVER_URL = serverUrlInput.value || SERVER_URL;
      socket = io(SERVER_URL, { transports: ['websocket', 'polling'], reconnection:true });
      socket.on('connect', () => {
        log('‚úÖ CONECTADO ao servidor: ' + SERVER_URL);
        updateConnectionStatus(true);
        sessionIdEl.textContent = SESSION_FIXED;
        // join fixed session as operator
        socket.emit('join_session', { session: SESSION_FIXED, role: 'operator' });
        // generate QR automatically
        generateQrCode();
        startWebcamBtn.disabled = false;
        genQrBtn.disabled = false;
        finalizarBtn.disabled = false;
        startStreamBtn.disabled = false;
      });

      socket.on('disconnect', (reason) => {
        log('‚ùå DESCONECTADO: ' + reason);
        updateConnectionStatus(false);
      });

      socket.on('take_photo', ({ session, index, viewerId }) => {
        log('üì∏ Pedido TAKE_PHOTO recebido de viewer: ' + viewerId + ' index:' + index);
        // Capture high-res and return photo_ready
        captureHighResAndSend(index, viewerId);
      });

      socket.on('photos_submit', ({ viewerId, photos }) => {
        log(`üì¶ Recebido photos_submit do viewer ${viewerId} (qtd ${photos.length}) ‚Äî operador far√° montagem`);
        // You could auto-ack or process
      });

      socket.on('peer_joined', ({ id, role }) => {
        log(`üîî Peer joined: ${id} (${role})`);
      });

      socket.on('request_stream', ({ session, viewerId }) => {
        log('üì° request_stream recebido - iniciando envio de frames se estiver ativo');
        // start streaming automatically to fixed session if webcam active
        if(webcamStreamActive) {
          startStreamingToSession(session || SESSION_FIXED);
        }
      });

      // viewer count events
      socket.on('viewer_count', ({ viewers }) => {
        log(`üë• Viewers: ${viewers}`);
      });

      return socket;
    }

    // ========= QR generation =========
    function generateQrCode(){
      qrcodeEl.innerHTML = '';
      const url = `${location.origin}/celular.html?session=${encodeURIComponent(SESSION_FIXED)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width:220 }, (err) => {
        if(err) log('‚ùå Erro ao gerar QR: ' + err);
      });
      qrcodeEl.appendChild(canvas);
      log('üì± QR Code Celular gerado: ' + url);
    }

    // ========= Webcam control =========
    async function startWebcam(){
      try {
        const res = resSelect.value.split('x').map(n=>parseInt(n,10));
        const [w,h] = res;
        const fps = parseInt(fpsSelect.value,10) || 30;
        localStream = await navigator.mediaDevices.getUserMedia({ video: { width: w, height: h, frameRate: { ideal: fps } }, audio:false });
        webcamPreview.srcObject = localStream;
        webcamPreview.play().catch(()=>{});
        webcamStreamActive = true;
        startWebcamBtn.disabled = true;
        stopWebcamBtn.disabled = false;
        startStreamBtn.disabled = false;
        log(`üé• Webcam iniciada ${w}x${h} @ ${fps}fps`);
        // ensure socket is connected
        initSocket();
      } catch(e){
        log('‚ùå Erro ao iniciar webcam: ' + (e && e.message ? e.message : e));
        alert('Erro ao acessar a webcam. Verifique permiss√µes e se h√° outra aplica√ß√£o usando ela.');
      }
    }

    function stopWebcam(){
      if(localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream = null; }
      webcamPreview.srcObject = null;
      webcamStreamActive = false;
      startWebcamBtn.disabled = false;
      stopWebcamBtn.disabled = true;
      startStreamBtn.disabled = true;
      stopStream();
      log('üõë Webcam parada');
    }

    // capture high-res photo (native resolution) and send photo_ready
    async function captureHighResAndSend(index, viewerId){
      try {
        if(!localStream) { log('‚ö†Ô∏è Nenhuma webcam ativa para captura high-res'); return; }
        const v = document.createElement('video');
        v.srcObject = localStream;
        await v.play().catch(()=>{});
        const c = document.createElement('canvas');
        c.width = v.videoWidth || 1280;
        c.height = v.videoHeight || 720;
        const ctx = c.getContext('2d');
        // mirror horizontally so preview matches
        ctx.save(); ctx.translate(c.width,0); ctx.scale(-1,1);
        ctx.drawImage(v,0,0,c.width,c.height);
        ctx.restore();
        const photo = c.toDataURL('image/jpeg', 0.95);
        socket.emit('photo_ready', { session: SESSION_FIXED, index, viewerId, photo });
        log('‚úÖ photo_ready enviado para viewer ' + viewerId);
      } catch(err){ log('‚ùå Erro captura high-res: ' + (err && err.message ? err.message : err)); }
    }

    // ========= Streaming frames (low-res) =========
    let streamingTickHandle = null;
    function startStreamingToSession(sessionTarget){
      if(!webcamStreamActive || !localStream){ log('‚ö†Ô∏è Webcam n√£o iniciada'); return; }
      const fps = parseInt(fpsSelect.value,10) || 30;
      const target = sessionTarget || SESSION_FIXED;
      streamingTargetSession = target;
      const v = document.createElement('video');
      v.playsInline = true; v.muted = true;
      v.srcObject = localStream; v.play().catch(()=>{});
      // small canvas for streaming to keep bandwidth down
      const canvas = document.createElement('canvas');
      const streamRes = resSelect.value.split('x').map(Number);
      // choose a sensible stream size (scale down)
      canvas.width = Math.min(900, Math.round(streamRes[0] / 1.5));
      canvas.height = Math.round(canvas.width * (streamRes[1] / streamRes[0]));
      const ctx = canvas.getContext('2d');
      const interval = 1000 / fps;
      let last = performance.now();
      if(streamingTickHandle) clearInterval(streamingTickHandle);
      streamingTickHandle = setInterval(() => {
        try {
          ctx.save(); ctx.translate(canvas.width,0); ctx.scale(-1,1);
          ctx.drawImage(v,0,0,canvas.width,canvas.height);
          ctx.restore();
          const frame = canvas.toDataURL('image/jpeg', 0.6);
          socket.emit('stream_frame', { session: target, frame });
        } catch(e){
          // ignore intermittents
        }
      }, interval);
      stopStreamBtn.disabled = false;
      startStreamBtn.disabled = true;
      log(`‚ñ∂Ô∏è Iniciando stream para sess√£o ${target} @ ${fps}fps (tamanho ${canvas.width}x${canvas.height})`);
    }

    function stopStream(){
      if(streamingTickHandle){ clearInterval(streamingTickHandle); streamingTickHandle = null; log('‚è∏ Stream parado'); }
      streamingTargetSession = null;
      stopStreamBtn.disabled = true;
      startStreamBtn.disabled = false;
    }

    // ========= Miniaturas / Montagem / IMGBB =========
    function renderThumbs(){
      thumbsEl.innerHTML = '';
      lastPhotos.forEach((p, idx) => {
        const img = document.createElement('img');
        img.src = p;
        img.alt = 'foto-'+(idx+1);
        thumbsEl.appendChild(img);
      });
    }

    // Placeholder coordinates for stories & print templates (your originals)
    const STORIES_COORDS = [
      { x: 155, y: 381,  w: 2225, h: 1341 },
      { x: 155, y: 1817, w: 2225, h: 1341 },
      { x: 155, y: 3262, w: 2225, h: 1341 }
    ];
    const PRINT_COORDS = [
      { x: 191, y: 184,  w: 2163, h: 1308 },
      { x: 188, y: 1578, w: 2163, h: 1308 },
      { x: 191, y: 2970, w: 2163, h: 1308 }
    ];

    function drawImageCover(ctx, img, x, y, w, h){
      const imgRatio = img.width / img.height;
      const boxRatio = w / h;
      let sx = 0, sy = 0, sw = img.width, sh = img.height;
      if (imgRatio > boxRatio) {
        sw = img.height * boxRatio;
        sx = (img.width - sw) / 2;
      } else {
        sh = img.width / boxRatio;
        sy = (img.height - sh) / 2;
      }
      ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
    }

    function drawStories(photos){
      const ctx = storiesCanvas.getContext('2d');
      ctx.clearRect(0,0,storiesCanvas.width, storiesCanvas.height);
      const bg = new Image();
      bg.src = 'caralho (1).png';
      bg.onload = () => {
        ctx.drawImage(bg,0,0,storiesCanvas.width,storiesCanvas.height);
        photos.forEach((p,i) => {
          const img = new Image();
          img.src = p;
          img.onload = () => {
            const c = STORIES_COORDS[i];
            if(!c) return;
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
            log(`‚úÖ Foto ${i+1} posicionada stories`);
          };
        });
      };
    }

    function drawPrint(photos){
      const ctx = printCanvas.getContext('2d');
      ctx.clearRect(0,0,printCanvas.width, printCanvas.height);
      const bg = new Image();
      bg.src = 'imprimir (1).png';
      bg.onload = () => {
        ctx.drawImage(bg,0,0,printCanvas.width,printCanvas.height);
        photos.forEach((p,i) => {
          const img = new Image();
          img.src = p;
          img.onload = () => {
            const c = PRINT_COORDS[i];
            if(!c) return;
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
            log(`‚úÖ Foto ${i+1} posicionada print`);
          };
        });
      };
    }

    // Test IMGBB
    async function testImgbb(){
      if(!lastPhotos.length){ log('‚ùå Nenhuma foto para testar IMGBB'); return; }
      const key = imgbbKeyInput.value || '';
      if(!key){ alert('Coloque a IMGBB Key no campo.'); return; }
      try {
        log('üß™ Teste IMGBB iniciando...');
        const img = lastPhotos[0];
        const b64 = img.split(',')[1];
        const form = new FormData();
        form.append('key', key);
        form.append('image', b64);
        const res = await fetch('https://api.imgbb.com/1/upload', { method:'POST', body: form });
        const data = await res.json();
        if(data && data.success){
          log('‚úÖ IMGBB OK: ' + data.data.url);
          alert('Teste IMGBB sucesso:\n' + data.data.url);
        } else {
          log('‚ùå IMGBB Falhou: ' + JSON.stringify(data));
          alert('Falhou IMGBB: ver console');
        }
      } catch(e){
        log('‚ùå Erro IMGBB: ' + (e && e.message ? e.message : e));
      }
    }

    // ========= Buttons handlers =========
    startWebcamBtn.addEventListener('click', startWebcam);
    stopWebcamBtn.addEventListener('click', stopWebcam);
    startStreamBtn.addEventListener('click', () => {
      const target = streamSelect.value || SESSION_FIXED;
      startStreamingToSession(target);
    });
    stopStreamBtn.addEventListener('click', () => {
      socket && socket.emit('stop_stream', { session: streamingTargetSession });
      stopStream();
    });

    genQrBtn.addEventListener('click', generateQrCode);
    testImgbbBtn.addEventListener('click', testImgbb);
    finalizarBtn.addEventListener('click', () => {
      socket && socket.emit('end_session');
      lastPhotos = []; thumbsEl.innerHTML = ''; drawStories([]); drawPrint([]); log('Sess√£o finalizada manualmente');
      setTimeout(()=> location.reload(), 600);
    });

    limparVisualizadorBtn.addEventListener('click', () => {
      qrcodeVisualizadorEl.innerHTML = '';
      currentViewerSession = null;
      log('Visualizador limpo da interface');
    });

    debugBtn.addEventListener('click', () => {
      log('üêû DEBUG:\n- sessao: ' + SESSION_FIXED + '\n- webcam: ' + (!!localStream) + '\n- streaming: ' + (!!streamingTickHandle));
      fetch(SERVER_URL + '/status').then(r=>r.json()).then(d=>log('Status server: ' + JSON.stringify(d))).catch(e=>log('Erro status: ' + e.message));
    });

    // Utility for saving thumbnails as files (downloads)
    el('saveAllBtn').addEventListener('click', () => {
      if(!lastPhotos.length) return alert('Nenhuma foto');
      lastPhotos.forEach((p, i) => {
        const a = document.createElement('a');
        a.href = p;
        a.download = `foto-${i+1}.jpg`;
        a.click();
      });
      log('üì• Todas as fotos baixadas');
    });
    el('clearThumbsBtn').addEventListener('click', () => { lastPhotos = []; renderThumbs(); drawStories([]); drawPrint([]); log('Miniaturas limpas'); });

    // ========= Socket handlers for photos_ready and photos_ready result (viewer flow) =========
    if(!socket) initSocket();

    // When operator receives photos_submit from viewer, server will forward to operator (here you do your montage / imgbb)
    socket && socket.on && socket.on('photos_submit', async ({ viewerId, photos, session }) => {
      log(`üîÅ photos_submit recebido para operador (viewer ${viewerId}) ‚Äî fotos: ${photos.length}`);
      // Simple handling: keep lastPhotos for operator's UI and draw montages
      lastPhotos = photos.slice(0,3);
      renderThumbs();
      drawStories(lastPhotos); drawPrint(lastPhotos);
      genVisualizadorQrBtn.disabled = false; printBtn.disabled = false; testImgbbBtn.disabled = false;
      // Then upload to IMGBB and create visualizador link (server side ideally)
      // Here we will request the server to create a visualizador (if server supports)
      try {
        socket.emit('create_viewer_session', { photos: lastPhotos, session: SESSION_FIXED });
        log('üîÑ Solicita√ß√£o de cria√ß√£o de visualizador enviada ao servidor');
      } catch(e){
        log('‚ùå Erro ao solicitar cria√ß√£o de visualizador: ' + e.message);
      }
    });

    // When server returns viewer session created
    socket && socket.on && socket.on('viewer_session_created', ({ viewerId }) => {
      log('üéâ Viewer session criada: ' + viewerId);
      qrcodeVisualizadorEl.innerHTML = '';
      const url = `${location.origin}/visualizador.html?viewerId=${encodeURIComponent(viewerId)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 220 }, (err)=>{ if(err) log('‚ùå Erro QR visualizador: ' + err); });
      qrcodeVisualizadorEl.appendChild(canvas);
      currentViewerSession = viewerId;
      // update viewer history
      const item = document.createElement('div'); item.className = 'viewer-item';
      item.innerHTML = `<strong>${new Date().toLocaleString()}</strong> - ID: ${viewerId.substring(0,8)}...`;
      viewerHistoryEl.prepend(item);
    });

    // handle other server events gracefully
    socket && socket.on && socket.on('stream_frame', ({ session, frame }) => {
      // rarely used on operator side, but could be used if server relays frames
      log('‚ÑπÔ∏è Relay stream_frame recebido (ignore)');
    });

    // ========= Auto init on load =========
    window.addEventListener('DOMContentLoaded', () => {
      serverUrlInput.value = SERVER_URL;
      sessionIdEl.textContent = SESSION_FIXED;
      initSocket();
      // populate streamSelect with session fixed by default
      const opt = document.createElement('option'); opt.value = SESSION_FIXED; opt.textContent = `Sess√£o fixa: ${SESSION_FIXED}`; streamSelect.appendChild(opt);
      generateQrCode();
      log('üîÑ Interface inicializada');
    });

    // expose some functions for debugging in console
    window._cabine = { startWebcam, stopWebcam, startStreamingToSession, stopStream, captureHighResAndSend, lastPhotos };
  </script>
</body>
</html>
