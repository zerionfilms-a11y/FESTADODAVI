<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Operador</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/favicon.ico">

  <!-- Socket.io + QRCode (CDN) + jsPDF (stable CDN, no integrity to avoid mismatches) -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root{--bg:#0f1113;--panel:#0b0d0f;--accent:#0b84ff;--muted:#7f8c8d}
    *{box-sizing:border-box}
    body{font-family:Inter, Arial, Helvetica, sans-serif;background:var(--bg);color:#eee;margin:0;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0 0 8px 0;font-size:20px}
    .buttons-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:var(--accent);color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;margin-right:8px}
    button.secondary{background:#333}
    button.danger{background:#dc3545}
    button:disabled{background:#444;cursor:not-allowed;opacity:0.7}
    .qrcode-container{margin:12px 0;padding:10px;background:#111;border-radius:8px;display:inline-block}
    .qrcode-section{margin:20px 0}
    #thumbs{display:flex;flex-wrap:wrap;gap:8px}
    #thumbs img{width:170px;height:auto;border-radius:6px;border:2px solid #222;object-fit:cover}
    canvas{max-width:100%;display:block;margin-top:12px;border:1px solid #333;background:#000}
    #log{color:#9f9;margin-top:12px;white-space:pre-wrap;font-family:monospace;font-size:12px;max-height:360px;overflow-y:auto;background:#091012;padding:10px;border-radius:8px}
    .status{background:#111;padding:8px;border-radius:4px;margin:8px 0;display:inline-block;border:1px solid rgba(255,255,255,0.03)}
    .connected{color:#4CAF50;}
    .disconnected{color:#f44336;}
    .viewer-info{background:#0b0d0f;padding:10px;border-radius:5px;margin:10px 0}
    .viewer-history{background:#08090a;padding:10px;border-radius:5px;margin:10px 0;max-height:240px;overflow-y:auto}
    .viewer-item{margin:5px 0;padding:5px;background:#0a0b0c;border-radius:3px}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    label.inline{display:inline-flex;gap:8px;align-items:center}
    .small{font-size:13px;padding:6px 10px}
    .info-block{background:#0b0c0d;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);margin-bottom:12px;max-width:100%}
    #webcamPreview{width:480px;height:360px;background:#000;border:1px solid #222;display:block;margin-top:10px;border-radius:6px;object-fit:cover}
    @media(max-width:900px){#webcamPreview{width:320px;height:240px}}
    .muted{color:var(--muted)}
    .flex-col{display:flex;flex-direction:column}
    .viz-link{color:#9ad1ff;word-break:break-all;display:inline-block;margin-top:6px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>üì∏ Cabine Fotogr√°fica ‚Äî Operador</h1>
      <div id="connectionStatus" class="status disconnected">üî¥ Desconectado</div>
    </div>

    <div class="buttons-row">
      <button id="genQr" class="small" disabled>Gerar QR Celular</button>
      <button id="genVisualizadorQr" class="small" disabled>Gerar QR Visualizador</button>
      <button id="finalizarSessao" class="small danger" disabled>Finalizar Sess√£o</button>
      <button id="printBtn" class="small secondary" disabled>Imprimir (5x15)</button>
      <button id="limparVisualizadorBtn" class="small secondary">Limpar Visualizador</button>
      <button id="debugBtn" class="small secondary">Debug</button>
    </div>
  </header>

  <div class="info-block">
    <div>Sess√£o: <strong id="sessionId">‚Äî</strong></div>
    <div style="margin-top:6px" id="sessionControls">
      <label class="inline"><input id="autoStartWebcam" type="checkbox"> Auto-start webcam ao conectar</label>
    </div>
  </div>

  <div class="qrcode-section">
    <h3>QR Code para Celular (Cabine)</h3>
    <div id="qrcode" class="qrcode-container"></div>
  </div>

  <div class="qrcode-section">
    <h3>QR Code do Visualizador (Convidado)</h3>
    <div id="qrcodeVisualizador" class="qrcode-container"></div>
    <div id="viewerInfo" class="viewer-info" style="display:none;">
      <p><strong>Visualizador link:</strong> <span id="viewerSessionId">‚Äî</span></p>
      <p><strong>Expira em:</strong> 7 dias</p>
    </div>
  </div>

  <div class="qrcode-section">
    <h3>Hist√≥rico de Visualizadores</h3>
    <div id="viewerHistory" class="viewer-history">
      <div class="viewer-item">Nenhum visualizador gerado ainda</div>
    </div>
  </div>

  <h3>Controle da Webcam (opcional)</h3>
  <div class="controls-row">
    <button id="startWebcamBtn">Iniciar Webcam</button>
    <button id="stopWebcamBtn" disabled>Parar Webcam</button>
    <button id="startStreamBtn" disabled>Iniciar Stream</button>
    <button id="stopStreamBtn" disabled>Parar Stream</button>
    <select id="streamSelect" style="min-width:220px">
      <option value="">Enviar para sess√£o (autom√°tico request)</option>
    </select>
  </div>
  <video id="webcamPreview" autoplay muted playsinline></video>

  <h3>Fotos recebidas (√∫ltimas)</h3>
  <div id="thumbs"></div>

  <h3>Preview ‚Äî Montagem Stories (alto-res)</h3>
  <canvas id="storiesCanvas" width="3375" height="6000" style="display:block;border:1px solid #222;margin-top:12px;max-width:100%"></canvas>

  <h3>Preview ‚Äî Impress√£o (5x15)</h3>
  <canvas id="printCanvas" width="1845" height="5536" style="display:block;border:1px solid #222;margin-top:12px;max-width:100%"></canvas>

  <div id="log"></div>

<script>
(function(){
  // -----------------------
  // CONFIG
  // -----------------------
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const FIXED_SESSION = "cabine-fixa";
  const IMGBB_KEY = "fc52605669365cdf28ea379d10f2a341"; // if set, operator uploads directly; otherwise server will upload
  const STORIES_TEMPLATE = "storiesdavi.png";
  const PRINT_TEMPLATE = "imprimirdavi.png";
  const FRAME_OVERLAY = "moldura.png";
  const MAX_WAIT_MS_FOR_BATCH = 1400;
  const UPLOAD_TIMEOUT_MS = 20000;

  // -----------------------
  // DOM refs
  // -----------------------
  const el = id => document.getElementById(id);
  const qrcodeEl = el('qrcode'), qrcodeVisualizadorEl = el('qrcodeVisualizador');
  const sessionIdEl = el('sessionId'), viewerSessionIdEl = el('viewerSessionId');
  const viewerInfoEl = el('viewerInfo'), viewerHistoryEl = el('viewerHistory');
  const thumbsEl = el('thumbs'), storiesCanvas = el('storiesCanvas'), printCanvas = el('printCanvas');
  const logEl = el('log'), connectionStatusEl = el('connectionStatus');

  const genQrBtn = el('genQr'), finalizarBtn = el('finalizarSessao');
  const genVisualizadorQrBtn = el('genVisualizadorQr'), printBtn = el('printBtn');
  const debugBtn = el('debugBtn'), limparVisualizadorBtn = el('limparVisualizadorBtn');

  const startWebcamBtn = el('startWebcamBtn'), stopWebcamBtn = el('stopWebcamBtn');
  const startStreamBtn = el('startStreamBtn'), stopStreamBtn = el('stopStreamBtn');
  const streamSelect = el('streamSelect'), webcamPreview = el('webcamPreview');
  const autoStartWebcamCheckbox = el('autoStartWebcam');

  // -----------------------
  // STATE
  // -----------------------
  let socket = null;
  let lastPhotos = [];
  let viewerHistory = [];
  let localStream = null;
  let streamingInterval = null;
  let currentStoriesMontageDataUrl = null;
  let currentPrintMontageDataUrl = null;
  let currentBoomerangUrl = null;

  // pendingVisualizers holds objects keyed by viewerId when the server announces visualizador early
  const pendingVisualizers = {}; // viewerId -> { visualizadorUrl, waitingSince }

  const pendingBySession = {};

  // -----------------------
  // UTIL / LOG
  // -----------------------
  function log(msg){
    const ts = new Date().toLocaleTimeString();
    logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
    console.log(msg);
  }
  function setStatus(text, cssClass){
    connectionStatusEl.textContent = text;
    connectionStatusEl.className = 'status';
    if(cssClass) connectionStatusEl.classList.add(cssClass);
  }

  function parseViewerIdFromVisualizerUrl(url){
    try {
      const u = new URL(url, location.origin);
      // look for session param
      if (u.searchParams.has('session')) return u.searchParams.get('session');
      // fallback: last path segment
      const segs = u.pathname.split('/').filter(Boolean);
      return segs[segs.length-1] || null;
    } catch(e){ return null; }
  }

  // -----------------------
  // SOCKET INIT
  // -----------------------
  function initSocket(){
    if (socket && socket.connected) return;
    log('üì° Inicializando socket para ' + SERVER_URL);
    socket = io(SERVER_URL, {
      transports: ['websocket','polling'],
      reconnection: true,
      reconnectionAttempts: 20,
      reconnectionDelay: 2000,
      timeout: 20000,
      path: '/socket.io'
    });

    socket.on('connect', () => {
      log('‚úÖ Conectado ao servidor: ' + SERVER_URL + ' (id: ' + socket.id + ')');
      setStatus('üü¢ Conectado', 'connected');
      socket.emit('join_session', { session: FIXED_SESSION, role: 'operator' });
      sessionIdEl.textContent = FIXED_SESSION;
      genQrBtn.disabled = false;
      finalizarBtn.disabled = false;
      genVisualizadorQrBtn.disabled = false;
      printBtn.disabled = false;
      if (autoStartWebcamCheckbox.checked) attemptAutoStartWebcam();
    });

    socket.on('disconnect', (reason) => {
      log('‚ùå Desconectado: ' + reason);
      setStatus('üî¥ Desconectado', 'disconnected');
      genQrBtn.disabled = true;
      finalizarBtn.disabled = true;
    });

    socket.on('connect_error', (err) => {
      log('‚ùå Erro de conex√£o: ' + (err && err.message ? err.message : err));
      setStatus('‚ö†Ô∏è Erro de conex√£o', null);
    });

    // photos_ready can arrive before stories are uploaded on the server.
    // We will NOT show visualizador here unless the server included storiesUrl.
    socket.on('photos_ready', ({ session, uploaded, visualizadorUrl, storiesUrl, printUrl }) => {
      log('üì• photos_ready recebido (uploaded:' + (uploaded ? uploaded.length : 0) + ')');
      if (uploaded && uploaded.length) {
        lastPhotos = uploaded.slice(0,3);
        renderThumbs();
      }
      if (storiesUrl) {
        // server already has stories -> safe to show
        log('‚úÖ photos_ready cont√©m storiesUrl -> exibindo visualizador');
        if (visualizadorUrl) showVisualizadorQr(normalizeVisualizerUrl(visualizadorUrl));
      } else {
        // no stories yet: store pending visualizer and wait for viewer_photos_ready
        if (visualizadorUrl) {
          const vid = parseViewerIdFromVisualizerUrl(visualizadorUrl) || (Date.now().toString());
          pendingVisualizers[vid] = { visualizadorUrl: normalizeVisualizerUrl(visualizadorUrl), waitingSince: Date.now() };
          log('‚è≥ Visualizador pendente armazenado para viewer=' + vid + ' ‚Äî aguardando stories montages do servidor');
        } else {
          log('‚ö†Ô∏è photos_ready sem visualizadorUrl e sem storiesUrl ‚Äî aguardando servidor.');
        }
      }
    });

    // viewer_photos_ready is the definitive payload (it may include storiesMontage once server finishes uploads)
    socket.on('viewer_photos_ready', ({ session, photos, storiesMontage, print, viewerId, visualizadorUrl }) => {
      log('üì° viewer_photos_ready recebido (session:' + session + ', viewer:' + (viewerId||'‚Äî') + ')');
      // update photos if provided
      if (Array.isArray(photos) && photos.length) {
        lastPhotos = photos.slice(0,3);
        renderThumbs();
      }
      // If the server included storiesMontage, now we can show the visualizer.
      const vid = viewerId || parseViewerIdFromVisualizerUrl(visualizadorUrl) || null;
      if (storiesMontage) {
        log('‚úÖ viewer_photos_ready cont√©m storiesMontage (mostrando visualizador) for viewer=' + (vid||'‚Äî'));
        // prefer provided visualizadorUrl, else use pending, else build one
        const pending = (vid && pendingVisualizers[vid]) ? pendingVisualizers[vid].visualizadorUrl : null;
        const urlToShow = visualizadorUrl || pending || (vid ? `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(vid)}` : visualizadorUrl);
        if (urlToShow) showVisualizadorQr(normalizeVisualizerUrl(urlToShow));
        // cleanup pending entry
        if (vid && pendingVisualizers[vid]) delete pendingVisualizers[vid];
      } else {
        // no stories yet in this payload; if visualizadorUrl present and no pending, store it
        if (visualizadorUrl) {
          const pv = parseViewerIdFromVisualizerUrl(visualizadorUrl) || viewerId || (Date.now().toString());
          if (!pendingVisualizers[pv]) {
            pendingVisualizers[pv] = { visualizadorUrl: normalizeVisualizerUrl(visualizadorUrl), waitingSince: Date.now() };
            log('‚è≥ Visualizador pendente (viewer_photos_ready sem stories) para ' + pv);
          }
        }
      }
    });

    socket.on('boomerang_ready', ({ session, videoUrl, visualizadorUrl }) => {
      log('üéû boomerang_ready recebido (viewer:' + (session||'‚Äî') + ')');
      currentBoomerangUrl = videoUrl || null;
      renderBoomerangPreview(currentBoomerangUrl);
      if (visualizadorUrl) {
        // same rule: only show if server indicates montage is ready ‚Äî boomerang_ready often includes visualizadorUrl after processing
        const vid = parseViewerIdFromVisualizerUrl(visualizadorUrl);
        pendingVisualizers[vid] = { visualizadorUrl: normalizeVisualizerUrl(visualizadorUrl), waitingSince: Date.now() };
        // if boomerangReady includes content we can show immediately (assume server finished), so show:
        showVisualizadorQr(normalizeVisualizerUrl(visualizadorUrl));
      }
    });

    socket.on('viewer_session_created', ({ viewerId }) => {
      log('üéâ Sess√£o do visualizador criada no servidor: ' + viewerId);
      addToViewerHistory(viewerId, lastPhotos.length);
      // do NOT show the visualizador here ‚Äî wait for stories to be ready
    });

    socket.on('reset_session', ({ session }) => {
      log('üîÅ reset_session recebido para ' + session);
      lastPhotos = [];
      renderThumbs();
      clearCanvases();
      qrcodeVisualizadorEl.innerHTML = '';
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      // clear pending visualizers
      for (const k of Object.keys(pendingVisualizers)) delete pendingVisualizers[k];
    });

    socket.on('stream_frame', ({ session, frame }) => {
      log('üîÅ stream_frame relay recebido (len=' + (frame ? frame.length : 0) + ')');
    });
  } // initSocket

  // -----------------------
  // PENDING BATCH MANAGEMENT
  // -----------------------
  function appendToPendingAndMaybeProcess(session, photosArray, viewerId) {
    if (!pendingBySession[session]) pendingBySession[session] = { photos: [], timer: null, viewerId: viewerId || null };
    const p = pendingBySession[session];
    p.photos.push(...photosArray);
    if (viewerId) p.viewerId = viewerId;
    if (p.photos.length >= 3) {
      const take = p.photos.slice(0,3);
      p.photos = p.photos.slice(3);
      const vid = p.viewerId;
      clearTimeout(p.timer);
      p.timer = null;
      processPhotosAndUpload(take, vid).catch(e => log('‚ùå processPhotosAndUpload error: ' + e));
      return;
    }
    if (p.timer) clearTimeout(p.timer);
    p.timer = setTimeout(() => {
      const take = p.photos.splice(0,3);
      const vid = p.viewerId;
      p.timer = null;
      if (take && take.length) processPhotosAndUpload(take, vid).catch(e => log('‚ùå processPhotosAndUpload error: ' + e));
    }, MAX_WAIT_MS_FOR_BATCH);
  }

  // -----------------------
  // QR Generation & Normalization
  // -----------------------
  function generateQrCodeForCell(){
    qrcodeEl.innerHTML = '';
    const url = `${SERVER_URL.replace(/\/+$/,'')}/celular.html?session=${encodeURIComponent(FIXED_SESSION)}`;
    const canvas = document.createElement('canvas');
    QRCode.toCanvas(canvas, url, { width: 220 }, (err) => { if(err) log('‚ùå Erro ao gerar QR Code: ' + err); });
    qrcodeEl.appendChild(canvas);
    log('üì± QR Code Celular gerado: ' + url);
  }

  function normalizeVisualizerUrl(url){
    if(!url) return url;
    try {
      if (url.indexOf('visualizador.html') !== -1) return url;
      const m = url.match(/\/visualizador(?:\/session)?\/([^\/\?]+)/i);
      if (m && m[1]) {
        const sid = decodeURIComponent(m[1]);
        const base = SERVER_URL.replace(/\/+$/,'');
        return `${base}/visualizador.html?session=${encodeURIComponent(sid)}`;
      }
      return url;
    } catch(e){ return url; }
  }

  function showVisualizadorQr(visualizadorUrl){
    if (!visualizadorUrl) return;
    qrcodeVisualizadorEl.innerHTML = '';
    const qrCanvas = document.createElement('canvas');
    QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 220 }, (err) => { if (err) log('‚ùå Erro ao gerar QR: ' + err); });
    qrcodeVisualizadorEl.appendChild(qrCanvas);

    const a = document.createElement('a');
    a.href = visualizadorUrl;
    a.target = '_blank';
    a.rel = 'noopener';
    a.className = 'viz-link';
    a.textContent = visualizadorUrl;
    viewerSessionIdEl.innerHTML = '';
    viewerSessionIdEl.appendChild(a);

    viewerInfoEl.style.display = 'block';
    log('üîó Visualizador pronto: ' + visualizadorUrl);
  }

  // -----------------------
  // THUMBS AND MONTAGES (with moldura overlay)
  // -----------------------
  function renderThumbs(){
    thumbsEl.innerHTML = '';
    lastPhotos.forEach((p, idx) => {
      const img = document.createElement('img'); img.src = p; img.alt = 'foto-' + (idx+1);
      thumbsEl.appendChild(img);
    });
    // trigger draws but do not block here
    // drawStories and drawPrint will be awaited by processPhotosAndUpload when necessary
    drawStories(lastPhotos).catch(()=>{});
    drawPrint(lastPhotos).catch(()=>{});
  }

  function clearCanvases(){
    try { storiesCanvas.getContext('2d').clearRect(0,0,storiesCanvas.width,storiesCanvas.height); } catch(e){}
    try { printCanvas.getContext('2d').clearRect(0,0,printCanvas.width,printCanvas.height); } catch(e){}
    currentStoriesMontageDataUrl = null;
    currentPrintMontageDataUrl = null;
    printBtn.disabled = true;
  }

  function drawImageCover(ctx, img, x, y, w, h){
    const imgRatio = img.width / img.height;
    const boxRatio = w / h;
    let sx = 0, sy = 0, sw = img.width, sh = img.height;
    if (imgRatio > boxRatio) {
      sw = img.height * boxRatio; sx = (img.width - sw) / 2;
    } else {
      sh = img.width / boxRatio; sy = (img.height - sh) / 2;
    }
    ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
  }

  const STORIES_COORDS = [
    { x:366, y:203, w:2997 - 366, h:1657 - 203 },
    { x:363, y:1773, w:2997 - 363, h:3227 - 1773 },
    { x:363, y:3346, w:2997 - 363, h:4794 - 3346 }
  ];
  const PRINT_COORDS = [
    { x:158, y:202, w:1685 - 158, h:1432 - 202 },
    { x:158, y:1502, w:1685 - 158, h:2733 - 1502 },
    { x:158, y:2808, w:1684 - 158, h:4036 - 2808 }
  ];

  // Returns a Promise that resolves to the dataURL (or null)
  function drawStories(photos){
    return new Promise((resolve) => {
      try {
        const ctx = storiesCanvas.getContext('2d');
        ctx.clearRect(0,0,storiesCanvas.width,storiesCanvas.height);
        const bg = new Image();
        bg.crossOrigin = 'anonymous';
        bg.onload = async () => {
          try {
            ctx.drawImage(bg, 0, 0, storiesCanvas.width, storiesCanvas.height);
          } catch(e){ log('‚ö†Ô∏è draw bg stories error: ' + e); }
          // load all photos
          const loaders = photos.slice(0,3).map((p, i) => new Promise((res) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => res({ ok:true, img, i });
            img.onerror = () => res({ ok:false, img:null, i });
            img.src = p;
          }));
          const results = await Promise.all(loaders);
          results.forEach(r => {
            if (r.ok && r.img) {
              const i = r.i;
              const c = STORIES_COORDS[i] || STORIES_COORDS[0];
              try {
                drawImageCover(ctx, r.img, c.x, c.y, c.w, c.h);
                log(`‚úÖ Foto ${i+1} posicionada no stories: ${c.x},${c.y} ${c.w}x${c.h}`);
              } catch(e){ log('‚ö†Ô∏è drawImageCover stories error: ' + e); }
            } else {
              log(`‚ö†Ô∏è Foto ${r.i+1} falhou ao carregar para stories`);
            }
          });

          // apply frame overlay (if exists)
          const frame = new Image();
          frame.crossOrigin = 'anonymous';
          frame.onload = () => {
            try {
              ctx.drawImage(frame, 0, 0, storiesCanvas.width, storiesCanvas.height);
              log('‚úÖ Moldura aplicada sobre stories (moldura.png)');
            } catch(e) { log('‚ö†Ô∏è Erro ao desenhar moldura: ' + e); }
            try {
              currentStoriesMontageDataUrl = storiesCanvas.toDataURL('image/jpeg', 0.95);
              log('‚úÖ stories montage dataURL gerado');
            } catch(e){ log('‚ö†Ô∏è toDataURL stories failed: ' + e); currentStoriesMontageDataUrl = null; }
            resolve(currentStoriesMontageDataUrl);
          };
          frame.onerror = () => {
            try {
              currentStoriesMontageDataUrl = storiesCanvas.toDataURL('image/jpeg', 0.95);
              log('‚ö†Ô∏è Moldura n√£o encontrada (moldura.png). Continuing without frame.');
              log('‚úÖ stories montage dataURL gerado (sem moldura)');
            } catch(e){ log('‚ö†Ô∏è toDataURL stories failed (no frame): ' + e); currentStoriesMontageDataUrl = null; }
            resolve(currentStoriesMontageDataUrl);
          };
          frame.src = FRAME_OVERLAY;
        };
        bg.onerror = () => {
          log('‚ùå Erro ao carregar background stories (verifique STORIES_TEMPLATE path)');
          // still attempt to load photos directly onto blank background
          const ctx2 = storiesCanvas.getContext('2d');
          ctx2.fillStyle = '#000';
          ctx2.fillRect(0,0,storiesCanvas.width,storiesCanvas.height);
          // then load photos (same logic)
          (async () => {
            const loaders = photos.slice(0,3).map((p, i) => new Promise((res) => {
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = () => res({ ok:true, img, i });
              img.onerror = () => res({ ok:false, img:null, i });
              img.src = p;
            }));
            const results = await Promise.all(loaders);
            results.forEach(r => {
              if (r.ok && r.img) {
                const c = STORIES_COORDS[r.i] || STORIES_COORDS[0];
                try { drawImageCover(ctx2, r.img, c.x, c.y, c.w, c.h); } catch(e){}
              }
            });
            try { currentStoriesMontageDataUrl = storiesCanvas.toDataURL('image/jpeg', 0.95); log('‚úÖ stories montage dataURL gerado (bg fail)'); } catch(e){ currentStoriesMontageDataUrl = null; }
            resolve(currentStoriesMontageDataUrl);
          })();
        };
        bg.src = STORIES_TEMPLATE;
      } catch(e){
        log('‚ùå drawStories fatal error: ' + e);
        resolve(null);
      }
    });
  }

  function drawPrint(photos){
    return new Promise((resolve) => {
      try {
        const ctx = printCanvas.getContext('2d');
        ctx.clearRect(0,0,printCanvas.width,printCanvas.height);
        const bg = new Image();
        bg.crossOrigin = 'anonymous';
        bg.onload = async () => {
          try { ctx.drawImage(bg, 0, 0, printCanvas.width, printCanvas.height); } catch(e){ log('‚ö†Ô∏è draw bg print error: ' + e); }
          const loaders = photos.slice(0,3).map((p, i) => new Promise((res) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => res({ ok:true, img, i });
            img.onerror = () => res({ ok:false, img:null, i });
            img.src = p;
          }));
          const results = await Promise.all(loaders);
          results.forEach(r => {
            if (r.ok && r.img) {
              const c = PRINT_COORDS[r.i] || PRINT_COORDS[0];
              try {
                drawImageCover(ctx, r.img, c.x, c.y, c.w, c.h);
                log(`‚úÖ Foto ${r.i+1} posicionada no print: ${c.x},${c.y} ${c.w}x${c.h}`);
              } catch(e){ log('‚ö†Ô∏è drawImageCover print error: ' + e); }
            } else {
              log(`‚ö†Ô∏è Foto ${r.i+1} falhou ao carregar para print`);
            }
          });
          try { currentPrintMontageDataUrl = printCanvas.toDataURL('image/jpeg', 0.95); log('‚úÖ print montage dataURL gerado'); } catch(e){ log('‚ö†Ô∏è toDataURL print failed: ' + e); currentPrintMontageDataUrl = null; }
          if (currentPrintMontageDataUrl) printBtn.disabled = false;
          resolve(currentPrintMontageDataUrl);
        };
        bg.onerror = () => {
          log('‚ùå Erro ao carregar background print (verifique PRINT_TEMPLATE path)');
          // fall back: blank bg and still try to place images
          const ctx2 = printCanvas.getContext('2d');
          ctx2.fillStyle = '#000';
          ctx2.fillRect(0,0,printCanvas.width,printCanvas.height);
          (async () => {
            const loaders = photos.slice(0,3).map((p, i) => new Promise((res) => {
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = () => res({ ok:true, img, i });
              img.onerror = () => res({ ok:false, img:null, i });
              img.src = p;
            }));
            const results = await Promise.all(loaders);
            results.forEach(r => {
              if (r.ok && r.img) {
                const c = PRINT_COORDS[r.i] || PRINT_COORDS[0];
                try { drawImageCover(ctx2, r.img, c.x, c.y, c.w, c.h); } catch(e){}
              }
            });
            try { currentPrintMontageDataUrl = printCanvas.toDataURL('image/jpeg', 0.95); log('‚úÖ print montage dataURL gerado (bg fail)'); } catch(e){ currentPrintMontageDataUrl = null; }
            if (currentPrintMontageDataUrl) printBtn.disabled = false;
            resolve(currentPrintMontageDataUrl);
          })();
        };
        bg.src = PRINT_TEMPLATE;
      } catch(e){
        log('‚ùå drawPrint fatal error: ' + e);
        resolve(null);
      }
    });
  }

  // -----------------------
  // IMGBB upload util (client-side optional)
  // -----------------------
  async function uploadToImgbb(dataUrl, name = 'cabine_photo') {
    if (!IMGBB_KEY) {
      log('‚ÑπÔ∏è IMGBB_KEY n√£o configurada no index ‚Äî pulando upload local (use server para upload).');
      return null;
    }
    try {
      const base64 = dataUrl.replace(/^data:image\/\w+;base64,/, '');
      const form = new FormData();
      form.append('key', IMGBB_KEY);
      form.append('image', base64);
      form.append('name', name);
      const controller = new AbortController();
      const id = setTimeout(()=>controller.abort(), UPLOAD_TIMEOUT_MS);
      const res = await fetch('https://api.imgbb.com/1/upload', { method: 'POST', body: form, signal: controller.signal });
      clearTimeout(id);
      const json = await res.json();
      if (json && json.success && json.data && (json.data.url || json.data.display_url)) {
        return json.data.display_url || json.data.url;
      }
      throw new Error('IMGBB upload failed: ' + JSON.stringify(json));
    } catch(e){
      log('‚ùå Falha upload IMGBB: ' + (e.message || e));
      return null;
    }
  }

  // -----------------------
  // PROCESS PHOTOS / PUBLISH VISUALIZADOR (AUTO) ‚Äî updated ordering & waits
  // -----------------------
  async function processPhotosAndUpload(photosArray, viewerId){
    try {
      if (!Array.isArray(photosArray) || photosArray.length === 0) { log('Nenhuma foto para processar'); return; }
      const photos = photosArray.slice(0,3);
      while (photos.length < 3) photos.push(photos[photos.length - 1] || photosArray[0]);

      log('üîÑ Gerando montagem stories e print automaticamente...');
      lastPhotos = photos.slice(0,3);
      // ensure canvases are generated and wait for them (reliable)
      const storiesDataUrl = await drawStories(photos);
      const printDataUrl = await drawPrint(photos);

      // now we have currentStoriesMontageDataUrl and currentPrintMontageDataUrl
      const storiesMontage = storiesDataUrl || currentStoriesMontageDataUrl || null;
      const printMontage = printDataUrl || currentPrintMontageDataUrl || null;

      genVisualizadorQrBtn.disabled = true;

      const viewerIdLocal = viewerId || (FIXED_SESSION + ':' + Date.now());

      const uploadedPhotos = [];
      let storiesUrl = null;
      let printUrl = null;

      if (IMGBB_KEY) {
        // operator uploads directly to IMGBB ‚Äî ensure we upload stories before showing visualizer
        for (let i = 0; i < 3; i++){
          log('‚è´ Upload foto ' + (i+1) + ' para IMGBB...');
          const u = await uploadToImgbb(photos[i], `cabine_photo_${Date.now()}_${i+1}`);
          uploadedPhotos.push(u || photos[i]);
          log('‚úÖ foto ' + (i+1) + ' -> ' + (u || 'dataURL fallback'));
        }
        if (storiesMontage) {
          log('‚è´ Upload montagem stories...');
          const u = await uploadToImgbb(storiesMontage, `cabine_stories_${Date.now()}`);
          storiesUrl = u || storiesMontage;
          log('‚úÖ stories -> ' + (u || 'dataURL fallback'));
        } else {
          log('‚ö†Ô∏è storiesMontage n√£o dispon√≠vel no operador (n√£o ser√° mostrado at√© o servidor processar).');
        }
        if (printMontage) {
          log('‚è´ Upload montagem print...');
          const u = await uploadToImgbb(printMontage, `cabine_print_${Date.now()}`);
          printUrl = u || printMontage;
          log('‚úÖ print -> ' + (u || 'dataURL fallback'));
        }

        // send create_viewer_session to server with final URLs (storiesUrl may be null if failed)
        socket.emit('create_viewer_session', {
          session: FIXED_SESSION,
          photos: uploadedPhotos,
          storiesMontage: storiesUrl || storiesMontage,
          print: printUrl || printMontage
        });
        log('‚úÖ create_viewer_session emitido (com URLs IMGBB, storiesUrl=' + Boolean(storiesUrl) + ').');

        // Only show visualizer if storiesUrl is present (we require montage to appear)
        if (storiesUrl) {
          try {
            const visualizadorUrl = `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`;
            socket.emit('show_qr_on_viewer', { session: FIXED_SESSION, viewerId: viewerIdLocal, visualizadorUrl, qrUrl: storiesUrl || visualizadorUrl });
            log('üì≤ show_qr_on_viewer emitido (stories pronto).');
          } catch(e){ log('‚ö†Ô∏è emit show_qr_on_viewer falhou: ' + (e.message||e)); }

          const visualizadorUrl = `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`;
          showVisualizadorQr(visualizadorUrl);
          addToViewerHistory(viewerIdLocal, uploadedPhotos.length || photos.length);
          genVisualizadorQrBtn.disabled = false;
          printBtn.disabled = false;
          log('üéâ Visualizador criado automaticamente. viewerId: ' + viewerIdLocal);
        } else {
          // stories not uploaded successfully ‚Äî store pending visualizer and wait for server to update
          const visualizadorUrl = `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`;
          pendingVisualizers[viewerIdLocal] = { visualizadorUrl, waitingSince: Date.now() };
          genVisualizadorQrBtn.disabled = false;
          printBtn.disabled = false;
          addToViewerHistory(viewerIdLocal, uploadedPhotos.length || photos.length);
          log('‚è≥ Visualizador pendente (stories n√£o dispon√≠vel do operador). Ser√° exibido quando server fornecer storiesMontage.');
        }

      } else {
        // Try server-side upload via JSON endpoint
        try {
          log('‚è´ Enviando montagem (operador) para o servidor para obter URL remota...');
          const payloadPhotos = photos.map(p => p);
          const body = { photos: payloadPhotos, montage: storiesMontage || null };
          const controller = new AbortController();
          const id = setTimeout(()=>controller.abort(), UPLOAD_TIMEOUT_MS);
          const resp = await fetch(`${SERVER_URL.replace(/\/+$/,'')}/upload-to-imgbb`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: controller.signal
          });
          clearTimeout(id);

          if (!resp.ok) {
            const text = await resp.text().catch(()=>null);
            log(`‚ùå /upload-to-imgbb HTTP ${resp.status} ${text ? text : ''}`);
            throw new Error('Upload endpoint returned non-OK status');
          }

          const json = await resp.json().catch(()=>null);
          if (!json || !json.ok || !json.urls) {
            log('‚ùå /upload-to-imgbb n√£o retornou URLs v√°lidas; resposta: ' + JSON.stringify(json));
            throw new Error('Invalid response from /upload-to-imgbb');
          }

          const urls = json.urls || {};
          const maybePhotoUrls = [];
          if (urls.photo1) maybePhotoUrls.push(urls.photo1);
          if (urls.photo2) maybePhotoUrls.push(urls.photo2);
          if (urls.photo3) maybePhotoUrls.push(urls.photo3);
          while (maybePhotoUrls.length < 3) {
            const idx = maybePhotoUrls.length;
            maybePhotoUrls.push(photos[idx] || null);
          }
          storiesUrl = urls.montage || storiesMontage || null;

          // emit create_viewer_session with the remote URLs returned by server
          socket.emit('create_viewer_session', {
            session: FIXED_SESSION,
            photos: maybePhotoUrls,
            storiesMontage: storiesUrl || null,
            print: printMontage || null
          });
          log('‚úÖ create_viewer_session emitido (com URLs do servidor). storiesUrl=' + Boolean(storiesUrl));

          // Only show the visualizer if server returned a stories URL (we require montage)
          if (storiesUrl) {
            try {
              const visualizadorUrl = `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`;
              socket.emit('show_qr_on_viewer', { session: FIXED_SESSION, viewerId: viewerIdLocal, visualizadorUrl, qrUrl: storiesUrl || visualizadorUrl });
              log('üì≤ Solicita√ß√£o show_qr_on_viewer enviada (servidor possui URLs).');
            } catch(e){ log('‚ö†Ô∏è emit show_qr_on_viewer falhou: ' + (e.message||e)); }

            const visualizadorUrl = `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`;
            showVisualizadorQr(visualizadorUrl);
            genVisualizadorQrBtn.disabled = false;
            printBtn.disabled = false;
            addToViewerHistory(viewerIdLocal, maybePhotoUrls.length || photos.length);
            log('üéâ Visualizador criado com URLs do servidor. viewerId: ' + viewerIdLocal);
          } else {
            // server didn't provide montage URLs yet -> fallback to send dataURLs via socket and keep visualizer pending
            pendingVisualizers[viewerIdLocal] = { visualizadorUrl: `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`, waitingSince: Date.now() };
            socket.emit('create_viewer_session', {
              session: FIXED_SESSION,
              photos: photos, // dataURLs
              storiesMontage: storiesMontage || null,
              print: printMontage || null
            });
            log('‚ö†Ô∏è /upload-to-imgbb n√£o retornou URLs; fallback create_viewer_session (dataURLs) enviado e visualizador pendente.');
            genVisualizadorQrBtn.disabled = false;
            printBtn.disabled = false;
            addToViewerHistory(viewerIdLocal, photos.length);
          }

        } catch (err) {
          log('‚ö†Ô∏è /upload-to-imgbb falhou completamente: ' + (err.message || err));
          // fallback: server couldn't handle /upload-to-imgbb, send raw dataURLs via socket like before
          try {
            socket.emit('create_viewer_session', {
              session: FIXED_SESSION,
              photos: photos, // dataURLs
              storiesMontage: storiesMontage || null,
              print: printMontage || null
            });
            // mark visualizer pending and wait for server to emit viewer_photos_ready with storiesMontage
            pendingVisualizers[viewerIdLocal] = { visualizadorUrl: `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`, waitingSince: Date.now() };
            log('üîÅ Fallback create_viewer_session (dataURLs) enviado ao servidor para viewer: ' + viewerIdLocal);
            genVisualizadorQrBtn.disabled = false;
            printBtn.disabled = false;
            addToViewerHistory(viewerIdLocal, photos.length);
          } catch(e) {
            log('‚ùå Erro no fallback create_viewer_session: ' + (e && (e.message || e)));
          }
        }
      }
    } catch(e){
      log('‚ùå ERRO no processo auto: ' + (e.message || e));
      genVisualizadorQrBtn.disabled = false;
    }
  }

  // -----------------------
  // BOOMERANG / HISTORY / WEBCAM / STREAM / PRINT
  // -----------------------
  async function processBoomerangAndPublish(videoUrlOrData, viewerId){
    try {
      if (!videoUrlOrData) { log('‚ö†Ô∏è boomerang sem URL/data'); return; }
      if (typeof videoUrlOrData === 'string' && videoUrlOrData.startsWith('data:')) {
        log('‚è´ Enviando boomerang (dataURL) para o servidor (upload server-side recomendado)...');
        socket.emit('boomerang_ready', { session: FIXED_SESSION, viewerId, data: videoUrlOrData, filename: `boomerang_${Date.now()}.webm` });
      } else {
        socket.emit('boomerang_ready', { session: FIXED_SESSION, viewerId, videoUrl: videoUrlOrData });
      }
      const visualizadorUrl = `${location.origin}/visualizador.html?data=${encodeURIComponent(btoa(JSON.stringify({ photos: lastPhotos.slice(0,3), boomerang: videoUrlOrData })))}`;
      showVisualizadorQr(visualizadorUrl);
      addToViewerHistory(visualizadorUrl, lastPhotos.length);
      log('üéâ Visualizador do boomerang (fluxo iniciado): ' + visualizadorUrl);
    } catch(e){
      log('‚ùå ERRO processBoomerangAndPublish: ' + (e.message || e));
    }
  }

  function renderBoomerangPreview(url){
    if (!url) return;
    log('‚ñ∂Ô∏è Preview boomerang dispon√≠vel: ' + url);
    const existing = document.getElementById('boomerangPreview');
    if (existing) existing.remove();
    const v = document.createElement('video');
    v.id = 'boomerangPreview';
    v.style.width = '280px';
    v.style.display = 'block';
    v.style.marginTop = '8px';
    v.controls = true;
    v.loop = true;
    v.src = url;
    thumbsEl.appendChild(v);
    v.play().catch(()=>{});
  }

  function addToViewerHistory(id, photosCount){
    viewerHistory.unshift({ id, timestamp: new Date().toLocaleString(), photosCount });
    updateViewerHistory();
  }
  function updateViewerHistory(){
    viewerHistoryEl.innerHTML = '';
    if (!viewerHistory.length) { viewerHistoryEl.innerHTML = '<div class="viewer-item">Nenhum visualizador gerado ainda</div>'; return; }
    viewerHistory.forEach(it => {
      const div = document.createElement('div'); div.className = 'viewer-item';
      div.innerHTML = `<strong>${it.timestamp}</strong> - ${it.photosCount || 0} fotos - <span style="word-break:break-all">${it.id}</span>`;
      viewerHistoryEl.appendChild(div);
    });
  }

  // WEBCAM, STREAM, captureHighRes similar as before (kept unchanged)
  async function startWebcam(){
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false });
      webcamPreview.srcObject = localStream;
      await webcamPreview.play().catch(()=>{});
      startWebcamBtn.disabled = true;
      stopWebcamBtn.disabled = false;
      startStreamBtn.disabled = false;
      log('üé• Webcam iniciada (operador)');
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        streamSelect.innerHTML = '<option value="">Enviar para sess√£o (autom√°tico request)</option>';
        devices.filter(d => d.kind === 'videoinput').forEach(d => {
          const opt = document.createElement('option');
          opt.value = FIXED_SESSION;
          opt.textContent = (d.label || 'C√¢mera') + ' ‚Äî sess√£o atual';
          streamSelect.appendChild(opt);
        });
      } catch(e){}
    } catch(e) {
      log('‚ùå Erro ao iniciar webcam: ' + (e.message || e));
      throw e;
    }
  }
  function stopWebcam(){
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
    webcamPreview.srcObject = null;
    startWebcamBtn.disabled = false;
    stopWebcamBtn.disabled = true;
    startStreamBtn.disabled = true;
    stopStream();
    log('üõë Webcam parada');
  }

  async function captureHighResAndSend(index, viewerId){
    if(!localStream){ log('‚ö†Ô∏è Webcam n√£o ativa para captura high-res'); return; }
    try {
      const v = document.createElement('video');
      v.srcObject = localStream;
      v.muted = true;
      await v.play().catch(()=>{});
      const c = document.createElement('canvas');
      c.width = v.videoWidth || 1920;
      c.height = v.videoHeight || 1080;
      const ctx = c.getContext('2d');
      ctx.save(); ctx.translate(c.width, 0); ctx.scale(-1, 1);
      ctx.drawImage(v, 0, 0, c.width, c.height);
      ctx.restore();
      const photo = c.toDataURL('image/jpeg', 0.95);
      socket.emit('photo_ready', { session: FIXED_SESSION, index, viewerId, photo });
      log('‚úÖ photo_ready enviado para ' + viewerId + ' (index ' + index + ')');
    } catch(e){
      log('‚ùå Erro capture high-res: ' + (e.message || e));
    }
  }

  function startStreamingToSession(session){
    if(!localStream){ log('‚ö†Ô∏è Webcam n√£o iniciada'); return; }
    const fps = 18;
    const intervalMs = Math.max(16, Math.round(1000 / fps));
    const v = document.createElement('video'); v.srcObject = localStream; v.muted = true; v.playsInline = true;
    v.play().catch(()=>{});
    const canvas = document.createElement('canvas');
    canvas.width = 1200; canvas.height = 800;
    const ctx = canvas.getContext('2d');

    if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; }

    streamingInterval = setInterval(() => {
      try {
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
        ctx.restore();
        const frame = canvas.toDataURL('image/jpeg', 0.6);
        socket.emit('stream_frame', { session: session || FIXED_SESSION, frame });
      } catch(e){}
    }, intervalMs);

    startStreamBtn.disabled = true;
    stopStreamBtn.disabled = false;
    log('‚ñ∂Ô∏è Iniciando stream para sess√£o ' + (session||FIXED_SESSION) + ' @ ~' + fps + 'fps');
  }
  function stopStream(){
    if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; log('‚è∏ Stream parado'); }
    stopStreamBtn.disabled = true;
    startStreamBtn.disabled = false;
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // PRINT button (no changes in behavior except ensuring jsPDF loaded)
  printBtn.addEventListener('click', async () => {
    try {
      const data = currentPrintMontageDataUrl || printCanvas.toDataURL('image/png');
      if (!data) { alert('Montagem de impress√£o n√£o dispon√≠vel ainda.'); return; }

      const { jsPDF } = window.jspdf;
      if (!jsPDF) { alert('jsPDF n√£o carregado. Verifique conex√£o e recarregue a p√°gina.'); return; }
      const pdf = new jsPDF({ unit: 'mm', format: [50,150], orientation: 'portrait' });
      pdf.addImage(data, 'JPEG', 0, 0, 50, 150);
      const blob = pdf.output('blob');
      const url = URL.createObjectURL(blob);
      // open print page in new tab with embed and auto-print
      const html = '<!doctype html><html><head><meta charset="utf-8"><title>Impress√£o 5x15</title>' +
        '<style>html,body{height:100%;margin:0;background:#fff} embed{width:100%;height:100%;display:block;border:0}</style>' +
        '</head><body><embed id="pdfEmbed" src="' + url + '" type="application/pdf"></embed>' +
        '<script>function tryPrint(){ try{ window.focus(); setTimeout(function(){ window.print(); }, 300); }catch(e){} }' +
        'var embed = document.getElementById("pdfEmbed"); if (embed) { embed.addEventListener("load", tryPrint); } setTimeout(tryPrint, 800);<\/script></body></html>';
      const w = window.open('', '_blank', 'noopener');
      if (!w) { alert('Permita popups para abrir a janela de impress√£o.'); return; }
      w.document.open();
      w.document.write(html);
      w.document.close();
    } catch(e){ log('‚ùå Erro imprimir: ' + (e.message || e)); }
  });

  // BUTTONS wiring
  genQrBtn.addEventListener('click', generateQrCodeForCell);
  limparVisualizadorBtn.addEventListener('click', () => {
    if (confirm('Limpar visualizador da UI?')) {
      qrcodeVisualizadorEl.innerHTML = '';
      viewerInfoEl.style.display = 'none';
      log('üßπ Visualizador limpo da interface');
    }
  });

  debugBtn.addEventListener('click', () => {
    log('üêõ DEBUG - Estado atual:');
    log('- Sess√£o FIXA: ' + FIXED_SESSION);
    log('- Socket conectado: ' + (socket ? socket.connected : false));
    log('- Socket ID: ' + (socket ? socket.id : '‚Äî'));
    log('- Fotos recebidas: ' + lastPhotos.length);
    log('- Visualizadores no hist√≥rico: ' + viewerHistory.length);
    fetch(SERVER_URL + '/health').then(r => r.json()).then(data => { log('ü©∫ Health: ' + JSON.stringify(data)); }).catch(e => { log('‚ùå Health check falhou: ' + (e.message || e)); });
  });

  finalizarBtn.addEventListener('click', () => {
    if (!confirm('Finalizar sess√£o e limpar fotos?')) return;
    lastPhotos = [];
    renderThumbs();
    clearCanvases();
    qrcodeVisualizadorEl.innerHTML = '';
    genVisualizadorQrBtn.disabled = true;
    printBtn.disabled = true;
    try { socket && socket.emit('reset_session', { session: FIXED_SESSION }); log('üîÅ reset_session emitido'); } catch(e){ log('Erro ao emitir reset_session: ' + e); }
  });

  genVisualizadorQrBtn.addEventListener('click', async () => {
    if (!lastPhotos.length) { log('‚ùå Nenhuma foto para gerar visualizador'); return; }
    await processPhotosAndUpload(lastPhotos, null);
  });

  startWebcamBtn.addEventListener('click', async () => { try { await startWebcam(); } catch(e){} });
  stopWebcamBtn.addEventListener('click', stopWebcam);
  startStreamBtn.addEventListener('click', () => startStreamingToSession(streamSelect.value || FIXED_SESSION));
  stopStreamBtn.addEventListener('click', () => { try { socket && socket.emit('stop_stream', { session: FIXED_SESSION }); } catch(e){} stopStream(); });

  window.addEventListener('DOMContentLoaded', () => {
    initSocket();
    genVisualizadorQrBtn.disabled = true;
    printBtn.disabled = true;
    generateQrCodeForCell();
    log('Operador pronto. Aguardando intera√ß√£o e/ou fotos do celular.');
    if (typeof streamingInterval === 'undefined') streamingInterval = null;
  });

  async function attemptAutoStartWebcam(){ try { await startWebcam(); } catch(e) { log('Auto-start webcam falhou: ' + e.message); } }

  window._operator = {
    socketRef: () => socket,
    lastPhotosRef: () => lastPhotos,
    sendTestPhotos: () => {
      const fake = [ 'data:image/png;base64, ...' ];
      socket.emit('photos_from_cell', { session: FIXED_SESSION, photos: fake });
    }
  };

})();
</script>
</body>
</html>
