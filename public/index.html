<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Operador</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/favicon.ico">

  <!-- Socket.io + QRCode (CDN) + jsPDF -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-1M/7wQd9pRkM1B6r2o+YJ2z7H0J6m5E1mX6m0u1k3tqY0Y8h4F1Y+oZqXHq6W0+5F8/0um8iQ2YF3p5l5V4V0g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    /* --- Layout / apar√™ncia --- */
    :root{--bg:#0f1113;--panel:#0b0d0f;--accent:#0b84ff;--muted:#7f8c8d}
    *{box-sizing:border-box}
    body{font-family:Inter, Arial, Helvetica, sans-serif;background:var(--bg);color:#eee;margin:0;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0 0 8px 0;font-size:20px}
    .buttons-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:var(--accent);color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;margin-right:8px}
    button.secondary{background:#333}
    button.danger{background:#dc3545}
    button:disabled{background:#444;cursor:not-allowed;opacity:0.7}
    .qrcode-container{margin:12px 0;padding:10px;background:#111;border-radius:8px;display:inline-block}
    .qrcode-section{margin:20px 0}
    #thumbs{display:flex;flex-wrap:wrap;gap:8px}
    #thumbs img{width:170px;height:auto;border-radius:6px;border:2px solid #222;object-fit:cover}
    canvas{max-width:100%;display:block;margin-top:12px;border:1px solid #333;background:#000}
    #log{color:#9f9;margin-top:12px;white-space:pre-wrap;font-family:monospace;font-size:12px;max-height:360px;overflow-y:auto;background:#091012;padding:10px;border-radius:8px}
    .status{background:#111;padding:8px;border-radius:4px;margin:8px 0;display:inline-block;border:1px solid rgba(255,255,255,0.03)}
    .connected{color:#4CAF50;}
    .disconnected{color:#f44336;}
    .viewer-info{background:#0b0d0f;padding:10px;border-radius:5px;margin:10px 0}
    .viewer-history{background:#08090a;padding:10px;border-radius:5px;margin:10px 0;max-height:240px;overflow-y:auto}
    .viewer-item{margin:5px 0;padding:5px;background:#0a0b0c;border-radius:3px}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    label.inline{display:inline-flex;gap:8px;align-items:center}
    .small{font-size:13px;padding:6px 10px}
    .info-block{background:#0b0c0d;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);margin-bottom:12px;max-width:100%}
    #webcamPreview{width:480px;height:360px;background:#000;border:1px solid #222;display:block;margin-top:10px;border-radius:6px;object-fit:cover}
    @media(max-width:900px){#webcamPreview{width:320px;height:240px}}
    /* extra UI niceties */
    .muted{color:var(--muted)}
    .flex-col{display:flex;flex-direction:column}

    /* small helpers for link */
    .viz-link{color:#9ad1ff;word-break:break-all;display:inline-block;margin-top:6px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>üì∏ Cabine Fotogr√°fica ‚Äî Operador</h1>
      <div id="connectionStatus" class="status disconnected">üî¥ Desconectado</div>
    </div>

    <div class="buttons-row">
      <button id="genQr" class="small" disabled>Gerar QR Celular</button>
      <button id="genVisualizadorQr" class="small" disabled>Gerar QR Visualizador</button>
      <button id="finalizarSessao" class="small danger" disabled>Finalizar Sess√£o</button>
      <button id="printBtn" class="small secondary" disabled>Imprimir (5x15)</button>
      <button id="limparVisualizadorBtn" class="small secondary">Limpar Visualizador</button>
      <button id="debugBtn" class="small secondary">Debug</button>
    </div>
  </header>

  <div class="info-block">
    <div>Sess√£o: <strong id="sessionId">‚Äî</strong></div>
    <div style="margin-top:6px" id="sessionControls">
      <label class="inline"><input id="autoStartWebcam" type="checkbox"> Auto-start webcam ao conectar</label>
    </div>
  </div>

  <div class="qrcode-section">
    <h3>QR Code para Celular (Cabine)</h3>
    <div id="qrcode" class="qrcode-container"></div>
  </div>

  <div class="qrcode-section">
    <h3>QR Code do Visualizador (Convidado)</h3>
    <div id="qrcodeVisualizador" class="qrcode-container"></div>
    <div id="viewerInfo" class="viewer-info" style="display:none;">
      <p><strong>Visualizador link:</strong> <span id="viewerSessionId">‚Äî</span></p>
      <p><strong>Expira em:</strong> 7 dias</p>
    </div>
  </div>

  <div class="qrcode-section">
    <h3>Hist√≥rico de Visualizadores</h3>
    <div id="viewerHistory" class="viewer-history">
      <div class="viewer-item">Nenhum visualizador gerado ainda</div>
    </div>
  </div>

  <h3>Controle da Webcam (opcional)</h3>
  <div class="controls-row">
    <button id="startWebcamBtn">Iniciar Webcam</button>
    <button id="stopWebcamBtn" disabled>Parar Webcam</button>
    <button id="startStreamBtn" disabled>Iniciar Stream</button>
    <button id="stopStreamBtn" disabled>Parar Stream</button>
    <select id="streamSelect" style="min-width:220px">
      <option value="">Enviar para sess√£o (autom√°tico request)</option>
    </select>
  </div>
  <video id="webcamPreview" autoplay muted playsinline></video>

  <h3>Fotos recebidas (√∫ltimas)</h3>
  <div id="thumbs"></div>

  <h3>Preview ‚Äî Montagem Stories (alto-res)</h3>
  <canvas id="storiesCanvas" width="3375" height="6000" style="display:block;border:1px solid #222;margin-top:12px;max-width:100%"></canvas>

  <h3>Preview ‚Äî Impress√£o (5x15)</h3>
  <!-- print canvas ajustado para 1845 x 5536 px (5cm x 15cm propor√ß√£o) -->
  <canvas id="printCanvas" width="1845" height="5536" style="display:block;border:1px solid #222;margin-top:12px;max-width:100%"></canvas>

  <div id="log"></div>

  <script>
  (function(){
    // -----------------------
    // CONFIG
    // -----------------------
    const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
    const FIXED_SESSION = "cabine-fixa";
    const IMGBB_KEY = ""; // keep empty on client to avoid slow client uploads
    const STORIES_TEMPLATE = "storiesdavi.png";
    const PRINT_TEMPLATE = "imprimirdavi.png";
    const FRAME_OVERLAY = "moldura.png";
    const BOOMERANG_TEMPLATE = "bomerang.png";

    // -----------------------
    // DOM refs
    // -----------------------
    const el = id => document.getElementById(id);
    const qrcodeEl = el('qrcode'), qrcodeVisualizadorEl = el('qrcodeVisualizador');
    const sessionIdEl = el('sessionId'), viewerSessionIdEl = el('viewerSessionId');
    const viewerInfoEl = el('viewerInfo'), viewerHistoryEl = el('viewerHistory');
    const thumbsEl = el('thumbs'), storiesCanvas = el('storiesCanvas'), printCanvas = el('printCanvas');
    const logEl = el('log'), connectionStatusEl = el('connectionStatus');

    const genQrBtn = el('genQr'), finalizarBtn = el('finalizarSessao');
    const genVisualizadorQrBtn = el('genVisualizadorQr'), printBtn = el('printBtn');
    const debugBtn = el('debugBtn'), limparVisualizadorBtn = el('limparVisualizadorBtn');

    const startWebcamBtn = el('startWebcamBtn'), stopWebcamBtn = el('stopWebcamBtn');
    const startStreamBtn = el('startStreamBtn'), stopStreamBtn = el('stopStreamBtn');
    const streamSelect = el('streamSelect'), webcamPreview = el('webcamPreview');
    const autoStartWebcamCheckbox = el('autoStartWebcam');

    // -----------------------
    // STATE
    // -----------------------
    let socket = null;
    let lastPhotos = [];
    let viewerHistory = [];
    let localStream = null;
    let streamingInterval = null;
    let currentStoriesMontageDataUrl = null;
    let currentPrintMontageDataUrl = null;
    let currentBoomerangUrl = null;
    let pendingCreateViewer = false; // avoid duplicate create_viewer_session calls

    // -----------------------
    // UTIL / LOG
    // -----------------------
    function log(msg){
      const ts = new Date().toLocaleTimeString();
      logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }
    function setStatus(text, cssClass){
      connectionStatusEl.textContent = text;
      connectionStatusEl.className = 'status';
      if(cssClass) connectionStatusEl.classList.add(cssClass);
    }

    // -----------------------
    // SOCKET INIT
    // -----------------------
    function initSocket(){
      if (socket && socket.connected) return;
      log('üì° Inicializando socket para ' + SERVER_URL);
      socket = io(SERVER_URL, {
        transports: ['websocket','polling'],
        reconnection: true,
        reconnectionAttempts: 20,
        reconnectionDelay: 2000,
        timeout: 20000,
        withCredentials: true,
        path: '/socket.io'
      });

      socket.on('connect', () => {
        log('‚úÖ Conectado ao servidor: ' + SERVER_URL + ' (id: ' + socket.id + ')');
        setStatus('üü¢ Conectado', 'connected');
        socket.emit('join_session', { session: FIXED_SESSION, role: 'operator' });
        sessionIdEl.textContent = FIXED_SESSION;
        genQrBtn.disabled = false;
        finalizarBtn.disabled = false;
        genVisualizadorQrBtn.disabled = false;
        printBtn.disabled = false;
        if (autoStartWebcamCheckbox.checked) attemptAutoStartWebcam();
      });

      socket.on('disconnect', (reason) => {
        log('‚ùå Desconectado: ' + reason);
        setStatus('üî¥ Desconectado', 'disconnected');
        genQrBtn.disabled = true;
        finalizarBtn.disabled = true;
      });

      socket.on('connect_error', (err) => {
        log('‚ùå Erro de conex√£o: ' + (err && err.message ? err.message : err));
        setStatus('‚ö†Ô∏è Erro de conex√£o', null);
      });

      // When photos come from cell/server ‚Äî render *immediately* then process
      function onPhotosReceived(payload){
        try {
          const viewerId = payload && (payload.viewerId || payload.viewer || payload.viewer_id || 'unknown');
          const photos = Array.isArray(payload.photos) ? payload.photos : (payload.uploaded || payload.photosArray || []);
          log('üì• Fotos recebidas (via socket) ‚Äî viewer:' + (viewerId||'‚Äî') + ' count:' + (photos ? photos.length : 0));

          // immediate UX: render thumbnails locally without waiting for uploads
          if (Array.isArray(photos) && photos.length) {
            lastPhotos = photos.slice(0,3);
            renderThumbs(); // draws and triggers montage generation
            // automatically start the create_viewer_session flow (non-blocking)
            if (!pendingCreateViewer) {
              pendingCreateViewer = true;
              // send create_viewer_session to server so it stores & emits viewer payload faster
              try {
                socket.emit('create_viewer_session', { session: FIXED_SESSION, photos: photos, storiesMontage: null, print: null }, (ack) => {
                  // ack optional
                });
                log('üîÅ create_viewer_session emitido automaticamente ao receber fotos.');
              } catch(e) {
                log('‚ö†Ô∏è Falha emit create_viewer_session: ' + (e.message || e));
              }
              // clear pending flag after small delay to avoid duplicates
              setTimeout(()=> pendingCreateViewer = false, 1500);
            }
          }
        } catch(err){ console.error('onPhotosReceived error', err); }
      }

      socket.on('photos_from_cell', onPhotosReceived);
      socket.on('photos_submit', onPhotosReceived);
      socket.on('photos_submit_saved', onPhotosReceived);

      socket.on('photos_ready', ({ session, uploaded, visualizadorUrl, storiesUrl, printUrl }) => {
        log('üì• photos_ready recebido (uploaded:' + (uploaded ? uploaded.length : 0) + ')');
        if (uploaded && uploaded.length) {
          lastPhotos = uploaded.slice(0,3);
          renderThumbs();
        }
        if (visualizadorUrl) {
          const normalized = normalizeVisualizerUrl(visualizadorUrl);
          showVisualizadorQr(normalized);
        }
        if (storiesUrl) {
          log('‚úÖ Stories montage available: ' + storiesUrl);
          // quickly show stories montage if provided
          currentStoriesMontageDataUrl = storiesUrl;
          // render montage container
          renderGalleryStoriesPreview(storiesUrl);
        }
        if (printUrl) {
          currentPrintMontageDataUrl = printUrl;
        }
      });

      socket.on('viewer_photos_ready', ({ session, photos, storiesMontage, print, visualizadorUrl }) => {
        log('üì° viewer_photos_ready recebido (session:' + session + ')');
        if (Array.isArray(photos) && photos.length) {
          lastPhotos = photos.slice(0,3);
          renderThumbs();
        }
        if (storiesMontage) {
          currentStoriesMontageDataUrl = storiesMontage;
          renderGalleryStoriesPreview(storiesMontage);
        }
        if (print) currentPrintMontageDataUrl = print;
        if (visualizadorUrl) showVisualizadorQr(normalizeVisualizerUrl(visualizadorUrl));
      });

      socket.on('boomerang_ready', ({ session, videoUrl, visualizadorUrl }) => {
        log('üéû boomerang_ready recebido (viewer:' + (session||'‚Äî') + ')');
        currentBoomerangUrl = videoUrl || null;
        renderBoomerangPreview(currentBoomerangUrl);
        if (visualizadorUrl) {
          showVisualizadorQr(normalizeVisualizerUrl(visualizadorUrl));
        }
      });

      socket.on('viewer_session_created', ({ viewerId }) => {
        log('üéâ Sess√£o do visualizador criada no servidor: ' + viewerId);
        addToViewerHistory(viewerId, lastPhotos.length);
      });

      socket.on('reset_session', ({ session }) => {
        log('üîÅ reset_session recebido para ' + session);
        lastPhotos = [];
        renderThumbs();
        clearCanvases();
        qrcodeVisualizadorEl.innerHTML = '';
        genVisualizadorQrBtn.disabled = true;
        printBtn.disabled = true;
      });

      socket.on('stream_frame', ({ session, frame }) => {
        log('üîÅ stream_frame relay recebido (len=' + (frame ? frame.length : 0) + ')');
      });
    } // initSocket

    // -----------------------
    // QR Generation & Normalization
    // -----------------------
    function generateQrCodeForCell(){
      qrcodeEl.innerHTML = '';
      const url = `${SERVER_URL.replace(/\/+$/,'')}/celular.html?session=${encodeURIComponent(FIXED_SESSION)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 220 }, (err) => { if(err) log('‚ùå Erro ao gerar QR Code: ' + err); });
      qrcodeEl.appendChild(canvas);
      log('üì± QR Code Celular gerado: ' + url);
    }

    function normalizeVisualizerUrl(url){
      if(!url) return url;
      try {
        if (url.indexOf('visualizador.html') !== -1) return url;
        const m = url.match(/\/visualizador(?:\/session)?\/([^\/\?]+)/i);
        if (m && m[1]) {
          const sid = decodeURIComponent(m[1]);
          const base = SERVER_URL.replace(/\/+$/,'');
          return `${base}/visualizador.html?session=${encodeURIComponent(sid)}`;
        }
        return url;
      } catch(e){ return url; }
    }

    function showVisualizadorQr(visualizadorUrl){
      qrcodeVisualizadorEl.innerHTML = '';
      const qrCanvas = document.createElement('canvas');
      QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 220 }, (err) => { if (err) log('‚ùå Erro ao gerar QR: ' + err); });
      qrcodeVisualizadorEl.appendChild(qrCanvas);

      // show clickable link (anchor) so browsers treat it as a link (avoid Safari search behavior)
      const a = document.createElement('a');
      a.href = visualizadorUrl;
      a.target = '_blank';
      a.rel = 'noopener';
      a.className = 'viz-link';
      a.textContent = visualizadorUrl;
      viewerSessionIdEl.innerHTML = '';
      viewerSessionIdEl.appendChild(a);

      viewerInfoEl.style.display = 'block';
      log('üîó Visualizador pronto: ' + visualizadorUrl);
    }

    // helper to render stories montage inside gallery for operator preview
    function renderGalleryStoriesPreview(src){
      try {
        // if already present, update img; otherwise create small preview block
        let existing = document.getElementById('storiesPreviewBlock');
        if (!existing) {
          const container = document.createElement('div');
          container.id = 'storiesPreviewBlock';
          container.className = 'photo-container stories-container';
          const title = document.createElement('div'); title.className = 'stories-title'; title.textContent = 'üì± Pronto para o Instagram';
          const img = document.createElement('img'); img.id = 'storiesPreviewImg'; img.loading = 'lazy'; img.alt = 'Stories Preview';
          const instagramBtn = document.createElement('button'); instagramBtn.className = 'instagram-btn'; instagramBtn.textContent = 'üì• Baixar Pronto pro Instagram';
          instagramBtn.onclick = () => downloadImage(src, `pronto-instagram-${Date.now()}.jpg`);
          container.appendChild(title); container.appendChild(img); container.appendChild(instagramBtn);
          // insert at top of thumbs area
          thumbsEl.parentNode.insertBefore(container, thumbsEl);
          existing = container;
        }
        const imgEl = document.getElementById('storiesPreviewImg');
        imgEl.src = src;
      } catch(e){ log('‚ö†Ô∏è renderGalleryStoriesPreview error: ' + e); }
    }

    // -----------------------
    // THUMBS AND MONTAGES (with moldura overlay)
    // -----------------------
    function renderThumbs(){
      thumbsEl.innerHTML = '';
      lastPhotos.forEach((p, idx) => {
        const img = document.createElement('img'); img.src = p; img.alt = 'foto-' + (idx+1);
        thumbsEl.appendChild(img);
      });
      if (lastPhotos.length) {
        drawStories(lastPhotos);
        drawPrint(lastPhotos);
        // enable print once montages are generated (we set a short timeout, montages finalize via onload/timeouts)
        setTimeout(()=> {
          if (currentPrintMontageDataUrl || typeof printCanvas.toDataURL === 'function') {
            printBtn.disabled = false;
          } else {
            // still enable to allow attempting to create pdf from canvas
            printBtn.disabled = false;
          }
        }, 900);
      } else {
        printBtn.disabled = true;
      }
    }

    function clearCanvases(){
      try { storiesCanvas.getContext('2d').clearRect(0,0,storiesCanvas.width,storiesCanvas.height); } catch(e){}
      try { printCanvas.getContext('2d').clearRect(0,0,printCanvas.width,printCanvas.height); } catch(e){}
      currentStoriesMontageDataUrl = null;
      currentPrintMontageDataUrl = null;
    }

    function drawImageCover(ctx, img, x, y, w, h){
      const imgRatio = img.width / img.height;
      const boxRatio = w / h;
      let sx = 0, sy = 0, sw = img.width, sh = img.height;
      if (imgRatio > boxRatio) {
        sw = img.height * boxRatio; sx = (img.width - sw) / 2;
      } else {
        sh = img.width / boxRatio; sy = (img.height - sh) / 2;
      }
      ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
    }

    const STORIES_COORDS = [
      { x:366, y:203, w:2997 - 366, h:1657 - 203 },
      { x:363, y:1773, w:2997 - 363, h:3227 - 1773 },
      { x:363, y:3346, w:2997 - 363, h:4794 - 3346 }
    ];
    const PRINT_COORDS = [
      { x:158, y:202, w:1685 - 158, h:1432 - 202 },
      { x:158, y:1502, w:1685 - 158, h:2733 - 1502 },
      { x:158, y:2808, w:1684 - 158, h:4036 - 2808 }
    ];

    function drawStories(photos){
      try {
        const ctx = storiesCanvas.getContext('2d');
        ctx.clearRect(0,0,storiesCanvas.width,storiesCanvas.height);
        const bg = new Image();
        bg.crossOrigin = 'anonymous';
        bg.src = STORIES_TEMPLATE;
        bg.onload = () => {
          ctx.drawImage(bg, 0, 0, storiesCanvas.width, storiesCanvas.height);
          let loaded = 0;
          photos.forEach((p, i) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = p;
            img.onload = () => {
              const c = STORIES_COORDS[i] || STORIES_COORDS[0];
              drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
              loaded++;
              log(`‚úÖ Foto ${i+1} posicionada no stories: ${c.x},${c.y} ${c.w}x${c.h}`);
              if (loaded === photos.length) {
                // apply moldura
                const frame = new Image();
                frame.crossOrigin = 'anonymous';
                frame.src = FRAME_OVERLAY;
                frame.onload = () => {
                  try {
                    ctx.drawImage(frame, 0, 0, storiesCanvas.width, storiesCanvas.height);
                  } catch(e) { /* continue */ }
                  try { currentStoriesMontageDataUrl = storiesCanvas.toDataURL('image/jpeg', 0.95); } catch(e){ log('‚ö†Ô∏è toDataURL stories failed: ' + e); }
                };
                frame.onerror = () => {
                  try { currentStoriesMontageDataUrl = storiesCanvas.toDataURL('image/jpeg', 0.95); } catch(e){ log('‚ö†Ô∏è toDataURL stories failed: ' + e); }
                  log('‚ö†Ô∏è Moldura n√£o encontrada (moldura.png). Continuando sem moldura.');
                };
              }
            };
            img.onerror = () => {
              log('‚ö†Ô∏è Erro ao carregar foto para stories preview');
              loaded++;
            };
          });
        };
        bg.onerror = () => log('‚ùå Erro ao carregar background stories (verifique STORIES_TEMPLATE path)');
      } catch(e){ log('‚ö†Ô∏è drawStories error: ' + e); }
    }

    function drawPrint(photos){
      try {
        const ctx = printCanvas.getContext('2d');
        ctx.clearRect(0,0,printCanvas.width,printCanvas.height);
        const bg = new Image();
        bg.crossOrigin = "anonymous";
        bg.src = PRINT_TEMPLATE;
        bg.onload = () => {
          ctx.drawImage(bg, 0, 0, printCanvas.width, printCanvas.height);
          let loaded = 0;
          photos.forEach((p, i) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = p;
            img.onload = () => {
              const c = PRINT_COORDS[i] || PRINT_COORDS[0];
              drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
              loaded++;
              log(`‚úÖ Foto ${i+1} posicionada no print: ${c.x},${c.y} ${c.w}x${c.h}`);
              if (loaded === photos.length) {
                try { currentPrintMontageDataUrl = printCanvas.toDataURL('image/jpeg', 0.95); } catch(e){ log('‚ö†Ô∏è toDataURL print failed: ' + e); }
              }
            };
            img.onerror = () => { log('‚ö†Ô∏è Erro ao carregar foto para print preview'); loaded++; };
          });
        };
        bg.onerror = () => log('‚ùå Erro ao carregar background print (verifique PRINT_TEMPLATE path)');
      } catch(e){ log('‚ö†Ô∏è drawPrint error: ' + e); }
    }

    // -----------------------
    // DOWNLOAD helper robust (handles data:, same-origin & cross-origin http(s) via fetch->blob)
    // -----------------------
    async function downloadImage(dataUrlOrUrl, filename){
      try {
        if (!dataUrlOrUrl) return;
        // data URL: direct
        if (/^data:/.test(dataUrlOrUrl)) {
          const a = document.createElement('a');
          a.href = dataUrlOrUrl;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          return;
        }
        // same-origin direct link: try direct anchor download
        try {
          const urlObj = new URL(dataUrlOrUrl, location.href);
          const sameOrigin = urlObj.origin === location.origin;
          if (sameOrigin) {
            const a = document.createElement('a');
            a.href = dataUrlOrUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            return;
          }
        } catch(e){ /* ignore URL parse errors */ }

        // cross-origin or unknown: fetch as blob then download
        const res = await fetch(dataUrlOrUrl, { mode: 'cors' });
        if (!res.ok) throw new Error('Fetch failed: ' + res.status);
        const blob = await res.blob();
        const objUrl = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = objUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=> URL.revokeObjectURL(objUrl), 15000);
      } catch (e) {
        log('‚ùå downloadImage failed: ' + (e && e.message ? e.message : e));
        // fallback: open in new tab
        try { window.open(dataUrlOrUrl, '_blank', 'noopener'); } catch(e2){}
      }
    }

    // -----------------------
    // PROCESS PHOTOS / PUBLISH VISUALIZADOR
    // -----------------------
    async function processPhotosAndUpload(photosArray, viewerId){
      // KEEP: this function still supports uploading via IMGBB if key present.
      // But we now prefer server-side create_viewer_session flow for speed.
      try {
        if (!Array.isArray(photosArray) || photosArray.length === 0) { log('Nenhuma foto para processar'); return; }
        const photos = photosArray.slice(0,3);
        while (photos.length < 3) photos.push(photos[photos.length - 1] || photosArray[0]);

        log('üîÑ Gerando montagem stories e print localmente...');
        drawStories(photos);
        drawPrint(photos);
        // wait a bit for canvases to finalize
        await sleep(900);

        const storiesMontage = currentStoriesMontageDataUrl || (storiesCanvas.toDataURL ? storiesCanvas.toDataURL('image/jpeg', 0.95) : null);
        const printMontage = currentPrintMontageDataUrl || (printCanvas.toDataURL ? printCanvas.toDataURL('image/jpeg', 0.95) : null);

        genVisualizadorQrBtn.disabled = true;

        // Generate viewerIdLocal to create a unique visualizer if not provided.
        const viewerIdLocal = viewerId || (FIXED_SESSION + ':' + Date.now());

        // Do NOT perform slow client uploads (IMGBB) by default. Prefer server-side.
        try {
          socket.emit('photos_from_cell', { session: FIXED_SESSION, viewerId: viewerIdLocal, photos: photosArray, storiesMontage: storiesMontage || null, print: printMontage || null });
          log('üîÅ Fotos brutas enviadas ao servidor (photos_from_cell).');
        } catch(e){ log('‚ö†Ô∏è emit photos_from_cell failed: ' + e); }

        // Also trigger create_viewer_session so server stores and emits viewer payload faster
        try {
          socket.emit('create_viewer_session', { session: FIXED_SESSION, viewerId: viewerIdLocal, photos: photosArray, storiesMontage: storiesMontage || null, print: printMontage || null });
          log('üîÅ create_viewer_session emitido automaticamente (processPhotosAndUpload).');
        } catch(e){ log('‚ö†Ô∏è emit create_viewer_session failed: ' + e); }

        // Show visualizer QR locally as soon as we have a URL (we craft a local URL to show)
        const visualizadorUrl = `${SERVER_URL.replace(/\/+$/,'')}/visualizador.html?session=${encodeURIComponent(viewerIdLocal)}`;
        showVisualizadorQr(visualizadorUrl);

        genVisualizadorQrBtn.disabled = false;
        printBtn.disabled = false;

        addToViewerHistory(viewerIdLocal, photos.length);
        log('üéâ Visualizador criado localmente: ' + viewerIdLocal);
      } catch(e){
        log('‚ùå ERRO no processo local: ' + (e.message || e));
        genVisualizadorQrBtn.disabled = false;
      }
    }

    // -----------------------
    // PROCESS BOOMERANG (video) AND PUBLISH
    // -----------------------
    async function processBoomerangAndPublish(videoUrlOrData, viewerId){
      try {
        if (!videoUrlOrData) { log('‚ö†Ô∏è boomerang sem URL/data'); return; }
        if (typeof videoUrlOrData === 'string' && videoUrlOrData.startsWith('data:')) {
          log('‚è´ Enviando boomerang (dataURL) para o servidor (upload server-side recomendado)...');
          socket.emit('boomerang_ready', { session: FIXED_SESSION, viewerId, data: videoUrlOrData, filename: `boomerang_${Date.now()}.webm` });
        } else {
          socket.emit('boomerang_ready', { session: FIXED_SESSION, viewerId, videoUrl: videoUrlOrData });
        }
        const visualizadorUrl = `${location.origin}/visualizador.html?data=${encodeURIComponent(btoa(JSON.stringify({ photos: lastPhotos.slice(0,3), boomerang: videoUrlOrData })))}`;
        showVisualizadorQr(visualizadorUrl);
        addToViewerHistory(visualizadorUrl, lastPhotos.length);
        log('üéâ Visualizador do boomerang (fluxo iniciado): ' + visualizadorUrl);
      } catch(e){
        log('‚ùå ERRO processBoomerangAndPublish: ' + (e.message || e));
      }
    }

    function renderBoomerangPreview(url){
      if (!url) return;
      log('‚ñ∂Ô∏è Preview boomerang dispon√≠vel: ' + url);
      const existing = document.getElementById('boomerangPreview');
      if (existing) existing.remove();
      const v = document.createElement('video');
      v.id = 'boomerangPreview';
      v.style.width = '280px';
      v.style.display = 'block';
      v.style.marginTop = '8px';
      v.controls = true;
      v.loop = true;
      v.src = url;
      thumbsEl.appendChild(v);
      v.play().catch(()=>{});
    }

    // -----------------------
    // HISTORY
    // -----------------------
    function addToViewerHistory(id, photosCount){
      viewerHistory.unshift({ id, timestamp: new Date().toLocaleString(), photosCount });
      updateViewerHistory();
    }
    function updateViewerHistory(){
      viewerHistoryEl.innerHTML = '';
      if (!viewerHistory.length) { viewerHistoryEl.innerHTML = '<div class="viewer-item">Nenhum visualizador gerado ainda</div>'; return; }
      viewerHistory.forEach(it => {
        const div = document.createElement('div'); div.className = 'viewer-item';
        div.innerHTML = `<strong>${it.timestamp}</strong> - ${it.photosCount || 0} fotos - <span style="word-break:break-all">${it.id}</span>`;
        viewerHistoryEl.appendChild(div);
      });
    }

    // -----------------------
    // WEBCAM (optional for operator)
    // -----------------------
    async function startWebcam(){
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false });
        webcamPreview.srcObject = localStream;
        await webcamPreview.play().catch(()=>{});
        startWebcamBtn.disabled = true;
        stopWebcamBtn.disabled = false;
        startStreamBtn.disabled = false;
        log('üé• Webcam iniciada (operador)');
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          streamSelect.innerHTML = '<option value="">Enviar para sess√£o (autom√°tico request)</option>';
          devices.filter(d => d.kind === 'videoinput').forEach(d => {
            const opt = document.createElement('option');
            opt.value = FIXED_SESSION;
            opt.textContent = (d.label || 'C√¢mera') + ' ‚Äî sess√£o atual';
            streamSelect.appendChild(opt);
          });
        } catch(e){}
      } catch(e) {
        log('‚ùå Erro ao iniciar webcam: ' + (e.message || e));
        throw e;
      }
    }
    function stopWebcam(){
      if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      webcamPreview.srcObject = null;
      startWebcamBtn.disabled = false;
      stopWebcamBtn.disabled = true;
      startStreamBtn.disabled = true;
      stopStream();
      log('üõë Webcam parada');
    }

    async function captureHighResAndSend(index, viewerId){
      if(!localStream){ log('‚ö†Ô∏è Webcam n√£o ativa para captura high-res'); return; }
      try {
        const v = document.createElement('video');
        v.srcObject = localStream;
        v.muted = true;
        await v.play().catch(()=>{});
        const c = document.createElement('canvas');
        c.width = v.videoWidth || 1920;
        c.height = v.videoHeight || 1080;
        const ctx = c.getContext('2d');
        ctx.save(); ctx.translate(c.width, 0); ctx.scale(-1, 1);
        ctx.drawImage(v, 0, 0, c.width, c.height);
        ctx.restore();
        const photo = c.toDataURL('image/jpeg', 0.95);
        socket.emit('photo_ready', { session: FIXED_SESSION, index, viewerId, photo });
        log('‚úÖ photo_ready enviado para ' + viewerId + ' (index ' + index + ')');
      } catch(e){
        log('‚ùå Erro capture high-res: ' + (e.message || e));
      }
    }

    // -----------------------
    // STREAM
    // -----------------------
    function startStreamingToSession(session){
      if(!localStream){ log('‚ö†Ô∏è Webcam n√£o iniciada'); return; }
      const fps = 18;
      const intervalMs = Math.max(16, Math.round(1000 / fps));
      const v = document.createElement('video'); v.srcObject = localStream; v.muted = true; v.playsInline = true;
      v.play().catch(()=>{});
      const canvas = document.createElement('canvas');
      canvas.width = 1200; canvas.height = 800;
      const ctx = canvas.getContext('2d');

      if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; }

      streamingInterval = setInterval(() => {
        try {
          ctx.save();
          ctx.translate(canvas.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
          ctx.restore();
          const frame = canvas.toDataURL('image/jpeg', 0.6);
          socket.emit('stream_frame', { session: session || FIXED_SESSION, frame });
        } catch(e){}
      }, intervalMs);

      startStreamBtn.disabled = true;
      stopStreamBtn.disabled = false;
      log('‚ñ∂Ô∏è Iniciando stream para sess√£o ' + (session||FIXED_SESSION) + ' @ ~' + fps + 'fps');
    }
    function stopStream(){
      if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; log('‚è∏ Stream parado'); }
      stopStreamBtn.disabled = true;
      startStreamBtn.disabled = false;
    }

    // -----------------------
    // UTIL sleep
    // -----------------------
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    // -----------------------
    // UI Buttons wiring
    // -----------------------
    genQrBtn.addEventListener('click', generateQrCodeForCell);
    limparVisualizadorBtn.addEventListener('click', () => {
      if (confirm('Limpar visualizador da UI?')) {
        qrcodeVisualizadorEl.innerHTML = '';
        viewerInfoEl.style.display = 'none';
        log('üßπ Visualizador limpo da interface');
      }
    });

    debugBtn.addEventListener('click', () => {
      log('üêõ DEBUG - Estado atual:');
      log('- Sess√£o FIXA: ' + FIXED_SESSION);
      log('- Socket conectado: ' + (socket ? socket.connected : false));
      log('- Socket ID: ' + (socket ? socket.id : '‚Äî'));
      log('- Fotos recebidas: ' + lastPhotos.length);
      log('- Visualizadores no hist√≥rico: ' + viewerHistory.length);
      fetch(SERVER_URL + '/health').then(r => r.json()).then(data => { log('ü©∫ Health: ' + JSON.stringify(data)); }).catch(e => { log('‚ùå Health check falhou: ' + (e.message || e)); });
    });

    finalizarBtn.addEventListener('click', () => {
      if (!confirm('Finalizar sess√£o e limpar fotos?')) return;
      lastPhotos = [];
      renderThumbs();
      clearCanvases();
      qrcodeVisualizadorEl.innerHTML = '';
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      try { socket && socket.emit('reset_session', { session: FIXED_SESSION }); log('üîÅ reset_session emitido'); } catch(e){ log('Erro ao emitir reset_session: ' + e); }
    });

    // PRINT button: cria PDF (5x15) usando jsPDF, abre em nova aba embutido e chama print()
    printBtn.addEventListener('click', async () => {
      try {
        const data = currentPrintMontageDataUrl || (printCanvas.toDataURL ? printCanvas.toDataURL('image/png') : null);
        if (!data) {
          alert('Montagem de impress√£o n√£o dispon√≠vel ainda.');
          return;
        }
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: [50,150], orientation: 'portrait' });
        pdf.addImage(data, 'JPEG', 0, 0, 50, 150);
        const blob = pdf.output('blob');
        const url = URL.createObjectURL(blob);
        // open new tab and embed PDF to trigger browser viewer (and allow ctrl+P)
        const html = `<!doctype html><html><head><meta charset="utf-8"><title>Impress√£o 5x15</title>
          <style>html,body{height:100%;margin:0;background:#fff} embed{width:100%;height:100%;display:block;border:0}</style>
          </head><body><embed id="pdfEmbed" src="${url}" type="application/pdf"></embed>
          <script>
            function tryPrint(){
              try{ window.focus(); setTimeout(()=>{ window.print(); }, 300); } catch(e){}
            }
            document.getElementById('pdfEmbed').addEventListener('load', tryPrint);
            setTimeout(tryPrint, 800);
          <\/script></body></html>`;
        const w = window.open('', '_blank', 'noopener');
        if (!w) { alert('Permita popups para abrir a janela de impress√£o.'); return; }
        w.document.open();
        w.document.write(html);
        w.document.close();
      } catch(e){ log('‚ùå Erro imprimir: ' + (e.message || e)); }
    });

    // webcam buttons
    startWebcamBtn.addEventListener('click', async () => { try { await startWebcam(); } catch(e){} });
    stopWebcamBtn.addEventListener('click', stopWebcam);
    startStreamBtn.addEventListener('click', () => startStreamingToSession(streamSelect.value || FIXED_SESSION));
    stopStreamBtn.addEventListener('click', () => { try { socket && socket.emit('stop_stream', { session: FIXED_SESSION }); } catch(e){} stopStream(); });

    genVisualizadorQrBtn.addEventListener('click', async () => {
      if (!lastPhotos.length) { log('‚ùå Nenhuma foto para gerar visualizador'); return; }
      await processPhotosAndUpload(lastPhotos, null);
    });

    // -----------------------
    // RENDER INIT
    // -----------------------
    window.addEventListener('DOMContentLoaded', () => {
      initSocket();
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      generateQrCodeForCell();
      log('Operador pronto. Aguardando intera√ß√£o e/ou fotos do celular.');
      if (typeof streamingInterval === 'undefined') streamingInterval = null;
    });

    async function attemptAutoStartWebcam(){ try { await startWebcam(); } catch(e) { log('Auto-start webcam falhou: ' + e.message); } }

    window._operator = {
      socketRef: () => socket,
      lastPhotosRef: () => lastPhotos,
      sendTestPhotos: () => {
        const fake = [ 'data:image/png;base64, ...' ];
        socket.emit('photos_from_cell', { session: FIXED_SESSION, photos: fake });
      }
    };

  })();
  </script>
</body>
</html>
