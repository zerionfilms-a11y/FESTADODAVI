<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Operador</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/favicon.ico">

  <!-- Socket.IO + QR lib -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

  <style>
    /* ============================
       Estilos gerais
       ============================ */
    :root{
      --bg:#0f1113;
      --panel:#0b0c0d;
      --muted:#888;
      --accent:#b07e09;
      --accent-dark:#8a6406;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#eee}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;padding:18px}
    h1{margin:0;font-size:20px}
    .buttons-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:#0b84ff;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;margin-right:8px}
    button.small{padding:8px 10px;font-size:13px}
    button.secondary{background:#333;color:#fff}
    button.danger{background:#dc3545}
    button:disabled{background:#444;cursor:not-allowed;opacity:0.6}
    .qrcode-container{margin:12px 0;padding:10px;background:#111;border-radius:8px;display:inline-block}
    .qrcode-section{margin:20px 0}
    #thumbs{display:flex;flex-wrap:wrap;gap:8px}
    #thumbs img{width:170px;height:auto;border-radius:6px;border:2px solid #222;object-fit:cover}
    .panel{background:var(--panel);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);margin:10px 0}
    .status{background:var(--panel);padding:8px;border-radius:6px;margin:8px 0;display:inline-block;border:1px solid rgba(255,255,255,0.02)}
    .connected{color:#4CAF50}
    .disconnected{color:#f44336}
    .viewer-history{background:#08090a;padding:10px;border-radius:8px;margin-top:8px;max-height:260px;overflow:auto}
    .viewer-item{padding:8px;border-radius:6px;background:#070809;margin-bottom:6px;word-break:break-word}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    label.inline{display:inline-flex;align-items:center;gap:8px}
    #log{color:#9f9;margin-top:12px;white-space:pre-wrap;font-family:monospace;font-size:12px;max-height:240px;overflow-y:auto;background:#071010;padding:10px;border-radius:8px}
    canvas{max-width:100%;display:block;margin-top:12px;border:1px solid #222;background:#000}
    @media (max-width:900px){ header{padding:12px} }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>üì∏ Cabine Fotogr√°fica ‚Äî Operador</h1>
      <div id="connectionStatus" class="status disconnected">üî¥ Desconectado</div>
    </div>

    <div class="buttons-row">
      <button id="genQr" class="small" disabled>Gerar QR Celular</button>
      <button id="genVisualizadorQr" class="small" disabled>Gerar QR Visualizador</button>
      <button id="finalizarSessao" class="small danger" disabled>Finalizar Sess√£o</button>
      <button id="printBtn" class="small secondary" disabled>Imprimir (10x15)</button>
      <button id="limparVisualizadorBtn" class="small secondary">Limpar Visualizador</button>
      <button id="debugBtn" class="small secondary">Debug</button>
    </div>
  </header>

  <main style="padding:18px;max-width:1200px;margin:auto">
    <section class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div>
          <div>Sess√£o: <strong id="sessionId">‚Äî</strong></div>
          <div style="font-size:13px;color:var(--muted)">ID fixo da cabine / sess√£o</div>
        </div>

        <div>
          <label class="inline"><input id="autoStartWebcam" type="checkbox"> Auto-start webcam (opcional)</label>
        </div>
      </div>
    </section>

    <section class="qrcode-section panel">
      <h3>QR Code para Celular (Cabine)</h3>
      <div id="qrcode" class="qrcode-container"></div>
    </section>

    <section class="qrcode-section panel">
      <h3>QR Code do Visualizador (Convidado)</h3>
      <div id="qrcodeVisualizador" class="qrcode-container"></div>
      <div id="viewerInfo" style="display:none;margin-top:10px">
        <p><strong>Visualizador link:</strong> <span id="viewerSessionId">‚Äî</span></p>
        <p><strong>Expira em:</strong> 7 dias</p>
      </div>
    </section>

    <section class="panel">
      <h3>Hist√≥rico de Visualizadores</h3>
      <div id="viewerHistory" class="viewer-history">
        <div class="viewer-item">Nenhum visualizador gerado ainda</div>
      </div>
    </section>

    <section class="panel">
      <h3>Controle da Webcam (opcional)</h3>
      <div class="controls-row">
        <button id="startWebcamBtn">Iniciar Webcam</button>
        <button id="stopWebcamBtn" disabled>Parar Webcam</button>
        <button id="startStreamBtn" disabled>Iniciar Stream</button>
        <button id="stopStreamBtn" disabled>Parar Stream</button>
        <select id="streamSelect" style="min-width:220px">
          <option value="">Enviar para sess√£o (autom√°tico request)</option>
        </select>
      </div>
      <video id="webcamPreview" autoplay muted playsinline style="width:100%;max-width:480px;margin-top:12px;border-radius:8px;background:#000;display:none"></video>
      <div style="font-size:13px;color:var(--muted);margin-top:8px">
        Nota: A webcam √© opcional ‚Äî a cabine pode usar somente a c√¢mera do celular. Marque o checkbox "Auto-start webcam" para permitir auto-start.
      </div>
    </section>

    <section class="panel">
      <h3>Fotos recebidas (√∫ltimas)</h3>
      <div id="thumbs" style="display:flex;flex-wrap:wrap;gap:10px"></div>
    </section>

    <section class="panel">
      <h3>Preview ‚Äî Montagem Stories (alto-res)</h3>
      <canvas id="storiesCanvas" width="3375" height="6000"></canvas>
    </section>

    <section class="panel">
      <h3>Preview ‚Äî Impress√£o (10x15)</h3>
      <canvas id="printCanvas" width="3691" height="5536"></canvas>
    </section>

    <section class="panel">
      <h3>Log / Debug</h3>
      <div id="log"></div>
    </section>
  </main>

  <!-- ============================
       Script principal (index.js embutido)
       ============================ -->
  <script>
  (function(){
    /**
     * index.html (OPERADOR) - completo
     * - Backend URL atualizado para: festadodavi-production-0591.up.railway.app
     * - Mantive todas as fun√ß√µes (webcam opcional, streaming, upload, montagem, QR, hist√≥rico)
     * - N√ÉO REMOVI funcionalidades do seu fluxo original
     */

    // -----------------------
    // CONFIG
    // -----------------------
    const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
    const FIXED_SESSION = "cabine-fixa";
    const IMGBB_KEY = "fc52605669365cdf28ea379d10f2a341"; // troque se precisar
    const STORIES_TEMPLATE = "storiesdavi.png";
    const PRINT_TEMPLATE = "imprimirdavi.png";
    const BOOMERANG_TEMPLATE = "bomerang.png"; // opcional

    // -----------------------
    // DOM helpers
    // -----------------------
    const $ = id => document.getElementById(id);
    const qrcodeEl = $('qrcode'), qrcodeVisualizadorEl = $('qrcodeVisualizador');
    const sessionIdEl = $('sessionId'), viewerSessionIdEl = $('viewerSessionId');
    const viewerInfoEl = $('viewerInfo'), viewerHistoryEl = $('viewerHistory');
    const thumbsEl = $('thumbs'), storiesCanvas = $('storiesCanvas'), printCanvas = $('printCanvas');
    const logEl = $('log'), connectionStatusEl = $('connectionStatus');
    const genQrBtn = $('genQr'), genVisualizadorQrBtn = $('genVisualizadorQr');
    const finalizarBtn = $('finalizarSessao'), printBtn = $('printBtn');
    const limparVisualizadorBtn = $('limparVisualizadorBtn'), debugBtn = $('debugBtn');
    const startWebcamBtn = $('startWebcamBtn'), stopWebcamBtn = $('stopWebcamBtn');
    const startStreamBtn = $('startStreamBtn'), stopStreamBtn = $('stopStreamBtn');
    const streamSelect = $('streamSelect'), webcamPreview = $('webcamPreview');
    const autoStartWebcamCheckbox = $('autoStartWebcam');

    // -----------------------
    // State
    // -----------------------
    let socket = null;
    let lastPhotos = [];
    let viewerHistory = [];
    let localStream = null;
    let streamingInterval = null;
    let currentStoriesMontageDataUrl = null;
    let currentPrintMontageDataUrl = null;
    let currentBoomerangUrl = null;

    // -----------------------
    // Utilities
    // -----------------------
    function log(msg){
      const ts = new Date().toLocaleString();
      logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    function setStatus(text, cssClass){
      connectionStatusEl.textContent = text;
      connectionStatusEl.className = 'status';
      if(cssClass) connectionStatusEl.classList.add(cssClass);
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    // -----------------------
    // Socket initialization
    // -----------------------
    function initSocket(){
      if (socket && socket.connected) return;
      log('üì° Inicializando conex√£o com backend: ' + SERVER_URL);

      try {
        socket = io(SERVER_URL, {
          transports: ['websocket','polling'],
          reconnection: true,
          reconnectionAttempts: 20,
          reconnectionDelay: 2000,
          timeout: 20000,
          withCredentials: true,
          path: '/socket.io'
        });
      } catch(err){
        log('‚ùå Erro ao criar socket: ' + err);
        return;
      }

      socket.on('connect', () => {
        log('‚úÖ Conectado ao servidor (id: ' + socket.id + ')');
        setStatus('üü¢ Conectado', 'connected');
        socket.emit('join_session', { session: FIXED_SESSION, role: 'operator' });
        sessionIdEl.textContent = FIXED_SESSION;
        genQrBtn.disabled = false;
        genVisualizadorQrBtn.disabled = false;
        finalizarBtn.disabled = false;
        printBtn.disabled = false;

        if (autoStartWebcamCheckbox.checked) {
          attemptAutoStartWebcam().catch(e => log('‚ö†Ô∏è autoStartWebcam falhou: ' + e));
        }
      });

      socket.on('disconnect', (reason) => {
        log('‚ùå Desconectado: ' + reason);
        setStatus('üî¥ Desconectado', 'disconnected');
        genQrBtn.disabled = true;
        genVisualizadorQrBtn.disabled = true;
        finalizarBtn.disabled = true;
      });

      socket.on('connect_error', (err) => {
        log('‚ùå Erro de conex√£o: ' + (err && err.message ? err.message : err));
        setStatus('‚ö†Ô∏è Erro de conex√£o', null);
      });

      // Requests that operator should stream (viewer requests stream)
      socket.on('request_stream', ({ session, viewerId }) => {
        log('üì° Pedido de stream recebido para sess√£o: ' + session + (viewerId ? ' (viewer: ' + viewerId + ')' : ''));
        if (localStream) startStreamingToSession(session || FIXED_SESSION);
      });

      // When server instructs operator to take a photo via local webcam
      socket.on('take_photo', ({ session, index, viewerId }) => {
        log('üì∏ Pedido take_photo (index:' + index + ', viewer:' + viewerId + ')');
        if (localStream) captureHighResAndSend(index, viewerId);
        else log('‚ö†Ô∏è Webcam n√£o ativa ‚Äî phone-driven flow deve enviar fotos_submit');
      });

      // Client (phone) submitted photos array
      socket.on('photos_submit', ({ viewerId, photos }) => {
        log('üì• photos_submit recebido (viewer:' + viewerId + ', fotos:' + (Array.isArray(photos)?photos.length:0) + ')');
        lastPhotos = Array.isArray(photos) ? photos.slice(0,3) : [];
        renderThumbs();
        processPhotosAndUpload(lastPhotos, viewerId).catch(e => log('‚ùå process error: ' + e));
      });

      // boomerang (video) ready
      socket.on('boomerang_ready', ({ viewerId, videoUrl, dataUrl }) => {
        log('üéû boomerang_ready recebido (viewer:' + viewerId + ')');
        currentBoomerangUrl = videoUrl || dataUrl || null;
        processBoomerangAndPublish(currentBoomerangUrl, viewerId).catch(e => log('‚ùå boomerang process error: ' + e));
      });

      socket.on('viewer_session_created', ({ viewerId }) => {
        log('üéâ Sess√£o do visualizador criada no servidor: ' + viewerId);
        addToViewerHistory(viewerId, lastPhotos.length);
      });

      socket.on('reset_session', ({ session }) => {
        log('üîÅ reset_session recebido para ' + session);
        lastPhotos = [];
        renderThumbs();
        clearCanvases();
        qrcodeVisualizadorEl.innerHTML = '';
        genVisualizadorQrBtn.disabled = true;
        printBtn.disabled = true;
      });

      // stream_frame debug relay
      socket.on('stream_frame', ({ session, frame }) => {
        // little log so operator can see sizes
        if(frame) log('üîÅ stream_frame relay recebido (len=' + frame.length + ')');
      });
    }

    // -----------------------
    // QR generation (cell)
    // -----------------------
    function generateQrCodeForCell(){
      qrcodeEl.innerHTML = '';
      // direct link to celular.html on same origin with session param
      const url = `${location.origin}/celular.html?session=${encodeURIComponent(FIXED_SESSION)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 220 }, (err) => { if(err) log('‚ùå Erro ao gerar QR: ' + err); });
      qrcodeEl.appendChild(canvas);
      log('üì± QR Code Celular gerado: ' + url);
    }

    // -----------------------
    // THUMBS & MONTAGES (stories / print)
    // -----------------------
    function renderThumbs(){
      thumbsEl.innerHTML = '';
      lastPhotos.forEach((p, idx) => {
        const img = document.createElement('img');
        img.src = p;
        img.alt = 'foto-' + (idx+1);
        img.style.width = '170px';
        img.style.borderRadius = '6px';
        thumbsEl.appendChild(img);
      });
      if (lastPhotos.length) {
        drawStories(lastPhotos);
        drawPrint(lastPhotos);
      } else {
        // clear canvases
        clearCanvases();
      }
    }

    function clearCanvases(){
      try { storiesCanvas.getContext('2d').clearRect(0,0,storiesCanvas.width,storiesCanvas.height); } catch(e){}
      try { printCanvas.getContext('2d').clearRect(0,0,printCanvas.width,printCanvas.height); } catch(e){}
      currentStoriesMontageDataUrl = null;
      currentPrintMontageDataUrl = null;
    }

    // cover cropping draw (keeps center)
    function drawImageCover(ctx, img, x, y, w, h){
      const imgRatio = img.width / img.height;
      const boxRatio = w / h;
      let sx = 0, sy = 0, sw = img.width, sh = img.height;
      if (imgRatio > boxRatio) {
        sw = img.height * boxRatio;
        sx = (img.width - sw) / 2;
      } else {
        sh = img.width / boxRatio;
        sy = (img.height - sh) / 2;
      }
      ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
    }

    // coordinates (keep same as original requested)
    const STORIES_COORDS = [
      { x:289, y:242, w:2776 - 289, h:1809 - 242 },
      { x:292, y:2026, w:2776 - 292, h:3593 - 2026 },
      { x:289, y:3754, w:2776 - 289, h:5324 - 3754 }
    ];
    const PRINT_COORDS = [
      { x:267, y:212, w:3010 - 267, h:1718 - 212 },
      { x:267, y:1887, w:3017 - 267, h:3393 - 1887 },
      { x:274, y:3556, w:3023 - 274, h:5061 - 3556 }
    ];

    function drawStories(photos){
      const ctx = storiesCanvas.getContext('2d');
      ctx.clearRect(0,0,storiesCanvas.width,storiesCanvas.height);
      const bg = new Image();
      bg.src = STORIES_TEMPLATE;
      bg.crossOrigin = "anonymous";
      bg.onload = () => {
        ctx.drawImage(bg, 0, 0, storiesCanvas.width, storiesCanvas.height);
        photos.forEach((p, i) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = p;
          img.onload = () => {
            const c = STORIES_COORDS[i] || STORIES_COORDS[0];
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
            log(`‚úÖ Foto ${i+1} posicionada no stories: ${c.x},${c.y} ${c.w}x${c.h}`);
          };
          img.onerror = () => log('‚ö†Ô∏è Erro ao carregar foto para stories preview');
        });
        setTimeout(() => {
          try { currentStoriesMontageDataUrl = storiesCanvas.toDataURL('image/jpeg', 0.95); } catch(e){ log('‚ö†Ô∏è toDataURL stories failed: ' + e); }
        }, 450);
      };
      bg.onerror = () => log('‚ùå Erro ao carregar background stories (verifique STORIES_TEMPLATE)');
    }

    function drawPrint(photos){
      const ctx = printCanvas.getContext('2d');
      ctx.clearRect(0,0,printCanvas.width,printCanvas.height);
      const bg = new Image();
      bg.src = PRINT_TEMPLATE;
      bg.crossOrigin = "anonymous";
      bg.onload = () => {
        ctx.drawImage(bg, 0, 0, printCanvas.width, printCanvas.height);
        photos.forEach((p, i) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = p;
          img.onload = () => {
            const c = PRINT_COORDS[i] || PRINT_COORDS[0];
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
            log(`‚úÖ Foto ${i+1} posicionada no print: ${c.x},${c.y} ${c.w}x${c.h}`);
          };
          img.onerror = () => log('‚ö†Ô∏è Erro ao carregar foto para print preview');
        });
        setTimeout(() => {
          try { currentPrintMontageDataUrl = printCanvas.toDataURL('image/jpeg', 0.95); } catch(e){ log('‚ö†Ô∏è toDataURL print failed: ' + e); }
        }, 450);
      };
      bg.onerror = () => log('‚ùå Erro ao carregar background print (verifique PRINT_TEMPLATE)');
    }

    // -----------------------
    // IMGBB upload (client side)
    // -----------------------
    async function uploadToImgbb(dataUrl, name = 'cabine_photo') {
      if (!IMGBB_KEY) throw new Error('IMGBB key n√£o configurada');
      const base64 = dataUrl.replace(/^data:image\/\w+;base64,/, '');
      const form = new FormData();
      form.append('key', IMGBB_KEY);
      form.append('image', base64);
      form.append('name', name);
      const res = await fetch('https://api.imgbb.com/1/upload', { method: 'POST', body: form });
      const json = await res.json();
      if (json && json.success && json.data && (json.data.url || json.data.display_url)) {
        return json.data.display_url || json.data.url;
      }
      throw new Error('IMGBB upload failed: ' + JSON.stringify(json));
    }

    // -----------------------
    // Process photos, upload and create visualizador
    // -----------------------
    async function processPhotosAndUpload(photosArray, viewerId){
      try {
        if (!Array.isArray(photosArray) || photosArray.length === 0) { log('Nenhuma foto para processar'); return; }
        const photos = photosArray.slice(0,3);
        while (photos.length < 3) photos.push(photos[photos.length - 1] || photosArray[0]);

        log('üîÑ Gerando montagem stories e print...');
        drawStories(photos);
        drawPrint(photos);
        await sleep(700);

        const storiesMontage = currentStoriesMontageDataUrl || storiesCanvas.toDataURL('image/jpeg', 0.95);
        const printMontage = currentPrintMontageDataUrl || printCanvas.toDataURL('image/jpeg', 0.95);

        genVisualizadorQrBtn.disabled = true;
        printBtn.disabled = true;

        const uploadedPhotos = [];
        for (let i = 0; i < 3; i++){
          log('‚è´ Upload foto ' + (i+1));
          const url = await uploadToImgbb(photos[i], `cabine_photo_${Date.now()}_${i+1}`);
          uploadedPhotos.push(url);
          log('‚úÖ foto ' + (i+1) + ' uploadada: ' + url);
        }

        log('‚è´ Upload montagem stories...');
        const storiesUrl = await uploadToImgbb(storiesMontage, `cabine_stories_${Date.now()}`);
        let printUrl = null;
        try { printUrl = await uploadToImgbb(printMontage, `cabine_print_${Date.now()}`); } catch(e){ log('‚ö†Ô∏è Falha upload print: ' + (e.message || e)); }

        const viewerPayload = { photos: uploadedPhotos, storiesMontage: storiesUrl, print: printUrl, createdAt: new Date().toISOString() };
        const payloadStr = JSON.stringify(viewerPayload);
        const b64 = btoa(unescape(encodeURIComponent(payloadStr)));
        const visualizadorUrl = `${location.origin}/visualizador.html?data=${encodeURIComponent(b64)}`;

        // UI: show QR
        qrcodeVisualizadorEl.innerHTML = '';
        const qrCanvas = document.createElement('canvas');
        QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 220 }, (err) => { if (err) log('‚ùå Erro ao gerar QR: ' + err); });
        qrcodeVisualizadorEl.appendChild(qrCanvas);
        viewerSessionIdEl.textContent = visualizadorUrl;
        viewerInfoEl.style.display = 'block';

        // notify viewers
        if (viewerId) {
          socket.emit('show_qr_on_viewer', { viewerId, visualizadorUrl });
        } else {
          socket.emit('show_qr_to_session', { session: FIXED_SESSION, visualizadorUrl });
        }

        socket.emit('create_viewer_session', { session: FIXED_SESSION, photos: uploadedPhotos, storiesMontage: storiesUrl, print: printUrl });

        genVisualizadorQrBtn.disabled = false;
        printBtn.disabled = false;

        addToViewerHistory(visualizadorUrl, uploadedPhotos.length);
        log('üéâ Visualizador criado: ' + visualizadorUrl);
      } catch(e){
        log('‚ùå ERRO no processo IMGBB: ' + (e.message || e));
        genVisualizadorQrBtn.disabled = false;
        printBtn.disabled = false;
      }
    }

    // -----------------------
    // Boomerang handling
    // -----------------------
    async function processBoomerangAndPublish(videoUrlOrData, viewerId){
      try {
        if (!videoUrlOrData) { log('‚ö†Ô∏è boomerang sem URL/data'); return; }

        let finalVideoUrl = videoUrlOrData;

        // If it's data:video, forward to server for upload (server must implement upload)
        if (typeof videoUrlOrData === 'string' && videoUrlOrData.startsWith('data:video')) {
          log('‚è´ Enviando boomerang (dataURL) para servidor para upload...');
          socket.emit('upload_boomerang', { session: FIXED_SESSION, viewerId, dataUrl: videoUrlOrData });
          // wait for server event with uploaded url
          finalVideoUrl = await waitForServerBoomerangUrl(15000);
          if (!finalVideoUrl) log('‚ö†Ô∏è Servidor n√£o retornou URL de boomerang em tempo');
        }

        const viewerPayload = { photos: lastPhotos.slice(0,3), boomerang: finalVideoUrl || null, createdAt: new Date().toISOString() };
        const b64 = btoa(unescape(encodeURIComponent(JSON.stringify(viewerPayload))));
        const visualizadorUrl = `${location.origin}/visualizador.html?data=${encodeURIComponent(b64)}`;

        qrcodeVisualizadorEl.innerHTML = '';
        const qrCanvas = document.createElement('canvas');
        QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 220 }, (err) => { if (err) log('‚ùå Erro ao gerar QR: ' + err); });
        qrcodeVisualizadorEl.appendChild(qrCanvas);
        viewerSessionIdEl.textContent = visualizadorUrl;
        viewerInfoEl.style.display = 'block';

        socket.emit('show_qr_to_session', { session: FIXED_SESSION, visualizadorUrl });
        socket.emit('create_viewer_session', { session: FIXED_SESSION, photos: lastPhotos, boomerang: finalVideoUrl });

        addToViewerHistory(visualizadorUrl, lastPhotos.length);
        log('üéâ Visualizador do boomerang criado: ' + visualizadorUrl);
      } catch(e){
        log('‚ùå ERRO processBoomerangAndPublish: ' + (e.message || e));
      }
    }

    function waitForServerBoomerangUrl(timeoutMs = 10000){
      return new Promise((resolve) => {
        let resolved = false;
        function onEvent(data){
          if (data && data.url) {
            resolved = true;
            socket.off('viewer_boomerang_uploaded', onEvent);
            resolve(data.url);
          }
        }
        socket.on('viewer_boomerang_uploaded', onEvent);
        setTimeout(() => {
          if (!resolved) {
            socket.off('viewer_boomerang_uploaded', onEvent);
            resolve(null);
          }
        }, timeoutMs);
      });
    }

    // -----------------------
    // Viewer history
    // -----------------------
    function addToViewerHistory(id, photosCount){
      viewerHistory.unshift({ id, timestamp: new Date().toLocaleString(), photosCount });
      updateViewerHistory();
    }
    function updateViewerHistory(){
      viewerHistoryEl.innerHTML = '';
      if (!viewerHistory.length) { viewerHistoryEl.innerHTML = '<div class="viewer-item">Nenhum visualizador gerado ainda</div>'; return; }
      viewerHistory.forEach(it => {
        const div = document.createElement('div');
        div.className = 'viewer-item';
        div.innerHTML = `<strong>${it.timestamp}</strong> ‚Äî ${it.photosCount || 0} fotos<br><small style="color:#999;word-break:break-all">${it.id}</small>`;
        viewerHistoryEl.appendChild(div);
      });
    }

    // -----------------------
    // Webcam optional (operator)
    // -----------------------
    async function startWebcam(){
      try {
        // Only start when user explicitly clicks (no auto-start by default)
        localStream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false });
        webcamPreview.srcObject = localStream;
        webcamPreview.style.display = 'block';
        await webcamPreview.play().catch(()=>{});
        startWebcamBtn.disabled = true;
        stopWebcamBtn.disabled = false;
        startStreamBtn.disabled = false;
        log('üé• Webcam iniciada (operator)');
        // populate devices
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          streamSelect.innerHTML = '<option value="">Enviar para sess√£o (autom√°tico request)</option>';
          devices.filter(d => d.kind === 'videoinput').forEach(d => {
            const opt = document.createElement('option');
            opt.value = FIXED_SESSION;
            opt.textContent = (d.label || 'C√¢mera') + ' ‚Äî sess√£o atual';
            streamSelect.appendChild(opt);
          });
        } catch(e){}
      } catch(e) {
        log('‚ùå Erro ao iniciar webcam: ' + (e.message || e));
        throw e;
      }
    }

    function stopWebcam(){
      if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      webcamPreview.srcObject = null;
      webcamPreview.style.display = 'none';
      startWebcamBtn.disabled = false;
      stopWebcamBtn.disabled = true;
      startStreamBtn.disabled = true;
      stopStream();
      log('üõë Webcam parada (operator)');
    }

    // capture high-res photo from webcam
    async function captureHighResAndSend(index, viewerId){
      if(!localStream){ log('‚ö†Ô∏è Webcam n√£o ativa para captura high-res'); return; }
      try {
        const v = document.createElement('video');
        v.srcObject = localStream;
        v.muted = true;
        await v.play().catch(()=>{});
        const c = document.createElement('canvas');
        c.width = v.videoWidth || 1920;
        c.height = v.videoHeight || 1080;
        const ctx = c.getContext('2d');
        // Mirror (user expects mirrored preview -> send mirrored so preview/print match)
        ctx.save(); ctx.translate(c.width, 0); ctx.scale(-1, 1);
        ctx.drawImage(v, 0, 0, c.width, c.height);
        ctx.restore();
        const photo = c.toDataURL('image/jpeg', 0.95);
        socket.emit('photo_ready', { session: FIXED_SESSION, index, viewerId, photo });
        log('‚úÖ photo_ready enviado para ' + viewerId + ' (index ' + index + ')');
      } catch(e){
        log('‚ùå Erro capture high-res: ' + (e.message || e));
      }
    }

    // -----------------------
    // Streaming (low-res frames) from operator webcam
    // -----------------------
    function startStreamingToSession(session){
      if(!localStream){ log('‚ö†Ô∏è Webcam n√£o iniciada'); return; }
      const fps = 18;
      const intervalMs = Math.max(16, Math.round(1000 / fps));
      const v = document.createElement('video'); v.srcObject = localStream; v.muted = true; v.playsInline = true;
      v.play().catch(()=>{});
      const canvas = document.createElement('canvas');
      canvas.width = 1200; canvas.height = 800;
      const ctx = canvas.getContext('2d');

      if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; }

      streamingInterval = setInterval(() => {
        try {
          ctx.save();
          ctx.translate(canvas.width, 0);
          ctx.scale(-1, 1); // mirror for preview consistency on viewer
          ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
          ctx.restore();
          const frame = canvas.toDataURL('image/jpeg', 0.6);
          socket.emit('stream_frame', { session: session || FIXED_SESSION, frame });
        } catch(e){}
      }, intervalMs);

      startStreamBtn.disabled = true;
      stopStreamBtn.disabled = false;
      log('‚ñ∂Ô∏è Iniciando stream para sess√£o ' + (session||FIXED_SESSION) + ' @ ~' + fps + 'fps');
    }

    function stopStream(){
      if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; log('‚è∏ Stream parado'); }
      stopStreamBtn.disabled = true;
      startStreamBtn.disabled = false;
    }

    // -----------------------
    // Autos & helpers (permissions)
    // -----------------------
    let __autoStartClickHandlerAdded = false;
    async function attemptAutoStartWebcam() {
      if (localStream) return;
      try {
        if (navigator.permissions && navigator.permissions.query) {
          const p = await navigator.permissions.query({ name: 'camera' });
          if (p.state === 'granted') {
            log('üîê Permiss√£o de c√¢mera = granted ‚Üí iniciando webcam automaticamente');
            await startWebcam().catch(e => log('‚ùå Falha auto-start (granted): ' + e));
            return;
          } else if (p.state === 'prompt') {
            log('üîî Permiss√£o de c√¢mera = prompt ‚Üí tentando solicitar permiss√£o');
            try {
              await startWebcam();
              return;
            } catch (e) {
              log('‚ö†Ô∏è startWebcam solicitou permiss√£o mas foi bloqueado/negado: ' + (e.message||e));
            }
          } else {
            log('üö´ Permiss√£o de c√¢mera = denied (usu√°rio negou)');
          }
        } else {
          log('‚ÑπÔ∏è Permissions API n√£o dispon√≠vel ‚Üí tentando startWebcam() (pode abrir prompt)');
          try { await startWebcam(); return; } catch(e){ log('‚ö†Ô∏è startWebcam falhou (sem Permissions API): '+(e.message||e)); }
        }
      } catch (err) {
        log('‚ö†Ô∏è Erro ao checar permiss√µes: ' + (err.message || err));
      }

      if (!__autoStartClickHandlerAdded) {
        const handler = async function userGestureTryStart() {
          try {
            log('üëÜ Primeiro gesto detectado ‚Äî tentando iniciar webcam');
            await startWebcam();
          } catch(e) {
            log('‚ùå Ainda n√£o foi poss√≠vel iniciar a webcam ap√≥s o gesto: ' + (e.message||e));
          } finally {
            document.documentElement.removeEventListener('click', handler);
            __autoStartClickHandlerAdded = false;
          }
        };
        document.documentElement.addEventListener('click', handler);
        __autoStartClickHandlerAdded = true;
        log('‚ÑπÔ∏è Registrado listener para primeiro clique ‚Äî ao tocar, tentarei iniciar a webcam');
      }
    }

    // -----------------------
    // Event wiring (buttons)
    // -----------------------
    genQrBtn.addEventListener('click', generateQrCodeForCell);
    limparVisualizadorBtn.addEventListener('click', () => {
      if (confirm('Limpar visualizador da UI?')) {
        qrcodeVisualizadorEl.innerHTML = '';
        viewerInfoEl.style.display = 'none';
        log('üßπ Visualizador limpo da interface');
      }
    });

    debugBtn.addEventListener('click', () => {
      log('üêõ DEBUG - Estado atual:');
      log('- Sess√£o FIXA: ' + FIXED_SESSION);
      log('- Socket conectado: ' + (socket ? socket.connected : false));
      log('- Socket ID: ' + (socket ? socket.id : '‚Äî'));
      log('- Fotos recebidas: ' + lastPhotos.length);
      log('- Visualizadores no hist√≥rico: ' + viewerHistory.length);
      fetch(SERVER_URL + '/health').then(r => r.json()).then(data => { log('ü©∫ Health: ' + JSON.stringify(data)); }).catch(e => { log('‚ùå Health check falhou: ' + (e.message || e)); });
    });

    finalizarBtn.addEventListener('click', () => {
      if (!confirm('Finalizar sess√£o e limpar fotos?')) return;
      lastPhotos = [];
      renderThumbs();
      clearCanvases();
      qrcodeVisualizadorEl.innerHTML = '';
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      try { socket && socket.emit('reset_session', { session: FIXED_SESSION }); log('üîÅ reset_session emitido'); } catch(e){ log('Erro ao emitir reset_session: ' + e); }
    });

    printBtn.addEventListener('click', () => {
      try {
        const data = printCanvas.toDataURL('image/png');
        const w = window.open('', '_blank', 'toolbar=0,location=0,menubar=0');
        w.document.write(`<!doctype html><html><head><meta charset="utf-8"><title>Impress√£o 10x15</title>
          <style>html,body{margin:0;padding:0;height:100%;} .page{width:10cm;height:15cm;margin:0 auto;display:flex;align-items:center;justify-content:center} img{width:100%;height:100%;object-fit:cover} @page{size:10cm 15cm;margin:0} @media print{body,html{margin:0;padding:0}}</style>
          </head><body><div class="page"><img src="${data}"></div><script>window.onload=function(){setTimeout(()=>{window.focus();window.print();},300)}<\/script></body></html>`);
        w.document.close();
      } catch(e){ log('‚ùå Erro imprimir: ' + (e.message || e)); }
    });

    startWebcamBtn.addEventListener('click', async () => { try { await startWebcam(); } catch(e){} });
    stopWebcamBtn.addEventListener('click', stopWebcam);
    startStreamBtn.addEventListener('click', () => startStreamingToSession(streamSelect.value || FIXED_SESSION));
    stopStreamBtn.addEventListener('click', () => { try { socket && socket.emit('stop_stream', { session: FIXED_SESSION }); } catch(e){} stopStream(); });

    genVisualizadorQrBtn.addEventListener('click', async () => {
      if (!lastPhotos.length) { log('‚ùå Nenhuma foto para gerar visualizador'); return; }
      await processPhotosAndUpload(lastPhotos, null);
    });

    // -----------------------
    // Render init
    // -----------------------
    window.addEventListener('DOMContentLoaded', () => {
      initSocket();
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      generateQrCodeForCell();
      log('Operador pronto. Aguardando intera√ß√£o e/ou fotos do celular.');
    });

    // safety
    if (typeof streamingInterval === 'undefined') streamingInterval = null;

    // -----------------------
    // Helper: add to viewer history UI
    // -----------------------
    function addToViewerHistoryEntry(id, photosCount){
      // expose to both addToViewerHistory and others
      addToViewerHistory(id, photosCount);
    }

    // Expose some functions for console debugging (optional)
    window._operator = {
      initSocket, startWebcam, stopWebcam, startStreamingToSession, stopStream, processPhotosAndUpload, processBoomerangAndPublish
    };

    // backward-compat helper: implement addToViewerHistory used above
    function addToViewerHistory(id, photosCount){
      viewerHistory.unshift({ id, timestamp: new Date().toLocaleString(), photosCount });
      updateViewerHistory();
    }

    // update UI
    function updateViewerHistory(){
      viewerHistoryEl.innerHTML = '';
      if (!viewerHistory.length) { viewerHistoryEl.innerHTML = '<div class="viewer-item">Nenhum visualizador gerado ainda</div>'; return; }
      viewerHistory.forEach(it => {
        const div = document.createElement('div');
        div.className = 'viewer-item';
        div.innerHTML = `<strong>${it.timestamp}</strong> ‚Äî ${it.photosCount || 0} fotos<br><small style="color:#999;word-break:break-all">${it.id}</small>`;
        viewerHistoryEl.appendChild(div);
      });
    }

  })();
  </script>
</body>
</html>
