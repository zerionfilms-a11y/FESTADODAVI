<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Operador (Webcam + IMGBB)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    body{font-family:Arial, sans-serif; background:#111; color:#eee; margin:0; padding:18px;}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0 0 8px 0}
    button{background:#0b84ff;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;margin-right:8px}
    button:disabled{background:#444;cursor:not-allowed}
    .qrcode-container{margin:12px 0;padding:10px;background:#222;border-radius:8px;display:inline-block}
    .qrcode-section{margin:20px 0}
    #thumbs{display:flex;flex-wrap:wrap;gap:8px}
    #thumbs img{width:170px;height:auto;border-radius:6px;border:2px solid #222}
    canvas{max-width:100%;display:block;margin-top:12px;border:1px solid #333;background:#000}
    #log{color:#9f9;margin-top:12px;white-space:pre-wrap;font-family:monospace;font-size:12px}
    .status{background:#333;padding:8px;border-radius:4px;margin:8px 0}
    .connected{color:#4CAF50;}
    .disconnected{color:#f44336;}
    .viewer-info{background:#333;padding:10px;border-radius:5px;margin:10px 0}
    .viewer-history{background:#222;padding:10px;border-radius:5px;margin:10px 0;max-height:200px;overflow-y:auto}
    .viewer-item{margin:5px 0;padding:5px;background:#333;border-radius:3px}
    /* Webcam preview */
    #webcamPreview { width: 360px; height: 270px; background:#000; border:1px solid #333; display:block; margin-top:10px; border-radius:6px; object-fit:cover;}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>üì∏ Cabine Fotogr√°fica ‚Äî Operador</h1>
      <div id="connectionStatus" class="status disconnected">üî¥ Desconectado</div>
    </div>
    <div style="display:flex;align-items:center;">
      <button id="genQr" disabled>Gerar QR Code Celular</button>
      <button id="finalizarSessao" disabled>Finalizar Sess√£o</button>
      <button id="genVisualizadorQr" disabled>Gerar QR Visualizador + IMGBB</button>
      <button id="printBtn" disabled>Imprimir (9x14)</button>
      <button id="debugBtn">Debug</button>
      <button id="testImgbbBtn" style="background:#28a745" disabled>Testar IMGBB</button>
      <button id="limparVisualizadorBtn" style="background:#dc3545">Limpar Visualizador</button>
    </div>
  </header>

  <div id="sessionInfo">
    <div>Sess√£o: <strong id="sessionId">‚Äî</strong></div>
    
    <div class="qrcode-section">
      <h3>QR Code para Celular (Cabine - SESS√ÉO FIXA)</h3>
      <div id="qrcode" class="qrcode-container"></div>
    </div>
    
    <div class="qrcode-section">
      <h3>QR Code para Visualizador (Cliente - SESS√ÉO √öNICA)</h3>
      <div id="qrcodeVisualizador" class="qrcode-container"></div>
      <div id="viewerInfo" class="viewer-info" style="display:none;">
        <p><strong>Sess√£o Visualizador:</strong> <span id="viewerSessionId">‚Äî</span></p>
        <p><strong>Expira em:</strong> 7 dias</p>
      </div>
    </div>

    <!-- Hist√≥rico de visualizadores -->
    <div class="qrcode-section">
      <h3>Hist√≥rico de Visualizadores</h3>
      <div id="viewerHistory" class="viewer-history">
        <div class="viewer-item">Nenhum visualizador gerado ainda</div>
      </div>
    </div>
  </div>

  <h3>Controle da Webcam / Stream</h3>
  <div class="controls-row">
    <button id="startWebcamBtn">Iniciar Webcam</button>
    <button id="stopWebcamBtn" disabled>Parar Webcam</button>
    <button id="startStreamBtn" disabled>Iniciar Stream para Celular</button>
    <button id="stopStreamBtn" disabled>Parar Stream</button>
    <select id="streamSelect" style="min-width:220px">
      <option value="">Enviar para sess√£o (autom√°tico request)</option>
    </select>
  </div>
  <video id="webcamPreview" autoplay muted playsinline></video>

  <h3>Fotos recebidas</h3>
  <div id="thumbs"></div>

  <h3>Preview ‚Äî Montagem Stories</h3>
  <canvas id="storiesCanvas" width="3375" height="6000"></canvas>

  <h3>Preview ‚Äî Impress√£o (9x14)</h3>
  <canvas id="printCanvas" width="3322" height="5167"></canvas>

  <div id="log"></div>

  <script>
    /**
     * Vers√£o completa do index.html do operador.
     * Mantido todo o comportamento original (QR, IMGBB, montagem stories/print, finalizar sess√£o...)
     * + funcionalidades novas de WEBCAM e STREAM (PC -> celular via socket.emit('stream_frame')).
     *
     * N√ÉO REMOVI nada do seu c√≥digo original ‚Äî juntei as partes e acrescentei streaming.
     */

    const SERVER_URL = "https://festadodavi.onrender.com/";

    // COORDENADAS PARA STORIES (caralho (1).png - 3375x6000)
    const STORIES_COORDS = [
      { x: 155, y: 381,  w: 2225, h: 1341 },   // √Årea 1
      { x: 155, y: 1817, w: 2225, h: 1341 },   // √Årea 2
      { x: 155, y: 3262, w: 2225, h: 1341 }    // √Årea 3
    ];

    // COORDENADAS PARA IMPRESS√ÉO 9x14 (3322x5167)
    const PRINT_COORDS = [
      { x: 191, y: 184,  w: 2163, h: 1308 },   // √Årea 1
      { x: 188, y: 1578, w: 2163, h: 1308 },   // √Årea 2
      { x: 191, y: 2970, w: 2163, h: 1308 }    // √Årea 3
    ];

    // Element helpers
    const el = id => document.getElementById(id);
    const qrcodeEl = el('qrcode'), qrcodeVisualizadorEl = el('qrcodeVisualizador');
    const sessionIdEl = el('sessionId'), viewerSessionIdEl = el('viewerSessionId');
    const viewerInfoEl = el('viewerInfo'), viewerHistoryEl = el('viewerHistory');
    const thumbsEl = el('thumbs'), storiesCanvas = el('storiesCanvas'), printCanvas = el('printCanvas');
    const logEl = el('log'), connectionStatusEl = el('connectionStatus');

    const genQrBtn = el('genQr'), finalizarBtn = el('finalizarSessao');
    const genVisualizadorQrBtn = el('genVisualizadorQr'), printBtn = el('printBtn');
    const debugBtn = el('debugBtn'), testImgbbBtn = el('testImgbbBtn');
    const limparVisualizadorBtn = el('limparVisualizadorBtn');

    const startWebcamBtn = el('startWebcamBtn'), stopWebcamBtn = el('stopWebcamBtn');
    const startStreamBtn = el('startStreamBtn'), stopStreamBtn = el('stopStreamBtn');
    const streamSelect = el('streamSelect'), webcamPreview = el('webcamPreview');

    let currentSession = null;
    let currentViewerSession = null;
    let lastPhotos = [];
    let viewerHistory = [];

    function log(msg){
      const timestamp = new Date().toLocaleTimeString();
      logEl.textContent += `[${timestamp}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function updateConnectionStatus(connected) {
      if (connected) {
        connectionStatusEl.innerHTML = 'üü¢ Conectado ao Servidor';
        connectionStatusEl.className = 'status connected';
      } else {
        connectionStatusEl.innerHTML = 'üî¥ Desconectado';
        connectionStatusEl.className = 'status disconnected';
      }
    }

    // Socket.IO client
    const socket = io(SERVER_URL, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: 10,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 30000,
      forceNew: true,
      withCredentials: true
    });

    // --- Socket events ---
    socket.on('connect', () => {
      log('‚úÖ CONECTADO ao servidor: ' + SERVER_URL);
      updateConnectionStatus(true);
      // registrar como operador na sess√£o fixa
      socket.emit('operator_connected');
    });

    socket.on('session_ready', ({ sessionId }) => {
      currentSession = sessionId;
      sessionIdEl.textContent = sessionId;
      generateQrCode();
      log('‚úÖ Sess√£o FIXA conectada: ' + sessionId);
      genQrBtn.disabled = false;
      finalizarBtn.disabled = false;
      startStreamBtn.disabled = false;
      // adiciona op√ß√£o no select para envio manual
      const opt = document.createElement('option'); opt.value = sessionId; opt.textContent = `Sess√£o fixa: ${sessionId}`; streamSelect.appendChild(opt);
    });

    socket.on('disconnect', (reason) => {
      log('‚ùå DESCONECTADO: ' + reason);
      updateConnectionStatus(false);
    });

    socket.on('connect_error', (error) => {
      log('‚ùå ERRO de conex√£o: ' + (error && error.message ? error.message : error));
      updateConnectionStatus(false);
      console.error('Socket.IO error:', error);
    });

    socket.on('reconnect_attempt', (attempt) => {
      log(`üîÑ Tentativa de reconex√£o ${attempt}`);
    });

    socket.on('reconnect', (attempt) => {
      log(`‚úÖ Reconectado ap√≥s ${attempt} tentativas`);
      updateConnectionStatus(true);
      if (currentSession) socket.emit('operator_connected');
    });

    // Quando o servidor informar que uma sess√£o de visualizador foi criada
    socket.on('viewer_session_created', ({ viewerId }) => {
      log(`üéâ Sess√£o do visualizador criada: ${viewerId}`);
      generateVisualizadorQrCode(viewerId);
    });

    socket.on('viewer_session_error', ({ error }) => {
      log('‚ùå ERRO ao criar visualizador: ' + error);
      genVisualizadorQrBtn.disabled = false;
      genVisualizadorQrBtn.textContent = 'Gerar QR Visualizador + IMGBB';
    });

    // Recebe fotos do celular
    socket.on('photos_ready', (photos) => {
      log(`üì∏ FOTOS RECEBIDAS: ${Array.isArray(photos) ? photos.length : '??' } fotos`);
      if (!Array.isArray(photos)) {
        log('‚ùå Fotos n√£o s√£o um array');
        return;
      }
      lastPhotos = photos.slice(0, 3);
      renderThumbs();
      drawStories(lastPhotos);
      drawPrint(lastPhotos);
      genVisualizadorQrBtn.disabled = false;
      printBtn.disabled = false;
      testImgbbBtn.disabled = false;
      log('‚úÖ Fotos renderizadas com sucesso');
    });

    // Recebe pedido de stream do celular -> operador √© notificado para enviar frames
    socket.on('want_stream', ({ session }) => {
      log('üì° Pedido de stream recebido para sess√£o: ' + session);
      // se webcam ativa, start automatic; se n√£o, s√≥ log
      if (webcamStreamActive) {
        // inicia stream automaticamente para a sess√£o pedida
        startStreamingToSession(session);
      } else {
        log('‚ö†Ô∏è Webcam n√£o ativada ‚Äî inicie a webcam para atender pedido de stream.');
      }
    });

    // Recebe frames reencaminhados (relay) ‚Äî apenas log, normalmente o operador emite stream_frame
    socket.on('stream_frame', ({ session, frame }) => {
      // normalmente o operador √© quem emite; este handler s√≥ serve se o servidor relays frames
      log(`üì• (relay) stream_frame recebido para sess√£o ${session} (tamanho: ${frame.length} chars)`);
    });

    // --- Fun√ß√µes originais do seu index (preservadas) ---

    // ‚úÖ Otimiza√ß√£o de imagem para IMGBB (mant√©m resolu√ß√£o, ajusta qualidade)
    function optimizeImageForImgbb(dataUrl, quality = 0.9) {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = dataUrl;
            img.onload = () => {
                console.log(`üìä Imagem original carregada: ${img.width}x${img.height}`);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const out = canvas.toDataURL('image/jpeg', quality);
                console.log(`‚úÖ Otimizada: ${Math.round(out.length / 1024)} KB`);
                resolve(out);
            };
            img.onerror = () => {
                console.warn('‚ö†Ô∏è Erro ao carregar imagem para otimiza√ß√£o, mantendo original');
                resolve(dataUrl);
            };
        });
    }

    // --- Bot√µes (originais mantidos) ---
    genQrBtn.addEventListener('click', () => {
      generateQrCode();
    });

    genVisualizadorQrBtn.addEventListener('click', async () => {
      if (lastPhotos.length === 0) {
        log('‚ùå Nenhuma foto dispon√≠vel para gerar visualizador');
        return;
      }
      log('üîç INICIANDO PROCESSO IMGBB...');
      log(`üìä Dados: ${lastPhotos.length} fotos, sess√£o: ${currentSession}`);

      try {
        // Otimiza (mantendo resolu√ß√£o alta) cada foto
        const optimizedPhotos = [];
        for (let i = 0; i < lastPhotos.length; i++) {
          log(`üîÑ Otimizando foto ${i+1}`);
          const optimized = await optimizeImageForImgbb(lastPhotos[i], 0.9);
          optimizedPhotos.push(optimized);
          log(`‚úÖ Foto ${i+1} otimizada (${Math.round(optimized.length/1024)}KB)`);
        }

        // Montagem stories em alta qualidade
        log('üîÑ Gerando montagem stories em alta qualidade...');
        const storiesMontage = storiesCanvas.toDataURL('image/jpeg', 0.95);
        const optimizedStories = await optimizeImageForImgbb(storiesMontage, 0.9);
        log(`‚úÖ Montagem stories otimizada (${Math.round(optimizedStories.length/1024)}KB)`);

        // Envia para o servidor criar a sess√£o do visualizador
        genVisualizadorQrBtn.disabled = true;
        genVisualizadorQrBtn.textContent = 'Enviando...';

        // Promise com timeout para cria√ß√£o da sess√£o do visualizador (servidor far√° upload IMGBB)
        const sendPromise = new Promise((resolve, reject) => {
          socket.emit('create_viewer_session', { photos: optimizedPhotos, storiesMontage: optimizedStories });

          const successHandler = ({ viewerId }) => {
            socket.off('viewer_session_created', successHandler);
            socket.off('viewer_session_error', errorHandler);
            resolve(viewerId);
          };
          const errorHandler = ({ error }) => {
            socket.off('viewer_session_created', successHandler);
            socket.off('viewer_session_error', errorHandler);
            reject(new Error(error));
          };
          socket.on('viewer_session_created', successHandler);
          socket.on('viewer_session_error', errorHandler);
        });

        const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout no envio para IMGBB')), 60000));
        const viewerId = await Promise.race([sendPromise, timeout]);

        log('üéâ Sess√£o do visualizador criada com sucesso: ' + viewerId);
        // viewer_session_created handler tamb√©m chamar√° a UI update
      } catch (error) {
        log('‚ùå ERRO no processo IMGBB: ' + (error.message || error));
        genVisualizadorQrBtn.disabled = false;
        genVisualizadorQrBtn.textContent = 'Gerar QR Visualizador + IMGBB';
        if (error.message && error.message.includes('Timeout')) {
          log('üîÑ Timeout detectado ‚Äî tentando reconectar socket...');
          socket.connect();
        }
      }
    });

    // Bot√£o teste IMGBB - envia uma foto para API diretamente para testar
    testImgbbBtn.addEventListener('click', async () => {
      if (lastPhotos.length === 0) {
        log('‚ùå Nenhuma foto para testar IMGBB');
        return;
      }

      try {
        log('üß™ TESTE IMGBB - enviando foto de teste...');
        const testPhoto = await optimizeImageForImgbb(lastPhotos[0], 0.9);
        const base64 = testPhoto.split(',')[1];
        const form = new FormData();
        form.append('key', '6734e028b20f88d5795128d242f85582');
        form.append('image', base64);

        const res = await fetch('https://api.imgbb.com/1/upload', { method: 'POST', body: form });
        const data = await res.json();
        if (data && data.success) {
          log('‚úÖ TESTE IMGBB SUCESSO: ' + data.data.url);
        } else {
          log('‚ùå TESTE IMGBB FALHOU: ' + JSON.stringify(data));
        }
      } catch (e) {
        log('‚ùå ERRO no teste IMGBB: ' + e.message);
      }
    });

    // Gera QR do celular (sess√£o fixa)
    function generateQrCode() {
      qrcodeEl.innerHTML = '';
      const url = `${SERVER_URL}/celular.html?session=${encodeURIComponent(currentSession)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 220 }, (err) => {
        if (err) log('‚ùå Erro ao gerar QR Code: ' + err);
      });
      qrcodeEl.appendChild(canvas);
      log('üì± QR Code Celular gerado para sess√£o FIXA: ' + currentSession);
    }

    // Gera QR do visualizador e atualiza hist√≥rico
    function generateVisualizadorQrCode(viewerId) {
      qrcodeVisualizadorEl.innerHTML = '';
      const url = `${SERVER_URL}/visualizador.html?viewerId=${encodeURIComponent(viewerId)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 220 }, (err) => { if (err) log('‚ùå Erro ao gerar QR Visualizador: ' + err); });
      qrcodeVisualizadorEl.appendChild(canvas);
      viewerSessionIdEl.textContent = viewerId;
      viewerInfoEl.style.display = 'block';
      currentViewerSession = viewerId;

      // hist√≥rico
      const item = { id: viewerId, timestamp: new Date().toLocaleTimeString(), photosCount: lastPhotos.length };
      viewerHistory.unshift(item);
      updateViewerHistory();

      log('üëÄ NOVO QR Code Visualizador gerado: ' + viewerId);
      log('‚úÖ Fotos enviadas para IMGBB com sucesso (ou fallback aplicado)');
      genVisualizadorQrBtn.disabled = false;
      genVisualizadorQrBtn.textContent = 'Gerar QR Visualizador + IMGBB';
      testImgbbBtn.disabled = false;
      printBtn.disabled = false;
    }

    function updateViewerHistory() {
      viewerHistoryEl.innerHTML = '';
      if (viewerHistory.length === 0) {
        viewerHistoryEl.innerHTML = '<div class="viewer-item">Nenhum visualizador gerado ainda</div>';
        return;
      }
      viewerHistory.forEach(item => {
        const div = document.createElement('div');
        div.className = 'viewer-item';
        div.innerHTML = `<strong>${item.timestamp}</strong> - ${item.photosCount} fotos - ID: ${item.id.substring(0,8)}...`;
        viewerHistoryEl.appendChild(div);
      });
    }

    // Recebe evento do servidor confirmando sess√£o criada (caso emitter do servidor)
    socket.on('viewer_session_created', ({ viewerId }) => {
      // se chegou por aqui, atualizamos a UI (evita duplicar)
      if (!currentViewerSession || currentViewerSession !== viewerId) {
        generateVisualizadorQrCode(viewerId);
      }
    });

    socket.on('viewer_session_error', ({ error }) => {
      log('‚ùå ERRO recebido do servidor ao criar visualizador: ' + error);
      genVisualizadorQrBtn.disabled = false;
      genVisualizadorQrBtn.textContent = 'Gerar QR Visualizador + IMGBB';
    });

    // Renderiza miniaturas
    function renderThumbs(){
      thumbsEl.innerHTML = '';
      lastPhotos.forEach((p, idx) => {
        const img = document.createElement('img');
        img.src = p;
        img.alt = 'foto-' + (idx+1);
        thumbsEl.appendChild(img);
      });
    }

    // Fun√ß√£o utilit√°ria de "cover" para manter enquadramento
    function drawImageCover(ctx, img, x, y, w, h){
      const imgRatio = img.width / img.height;
      const boxRatio = w / h;
      let sx = 0, sy = 0, sw = img.width, sh = img.height;
      if (imgRatio > boxRatio) {
        sw = img.height * boxRatio;
        sx = (img.width - sw) / 2;
      } else {
        sh = img.width / boxRatio;
        sy = (img.height - sh) / 2;
      }
      ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
    }

    // Desenha montagem stories
    function drawStories(photos){
      const ctx = storiesCanvas.getContext('2d');
      ctx.clearRect(0, 0, storiesCanvas.width, storiesCanvas.height);
      const bg = new Image();
      bg.src = 'caralho (1).png';
      bg.onload = () => {
        log('‚úÖ Background stories carregado: caralho (1).png');
        ctx.drawImage(bg, 0, 0, storiesCanvas.width, storiesCanvas.height);
        photos.forEach((p, i) => {
          const img = new Image();
          img.src = p;
          img.onload = () => {
            const c = STORIES_COORDS[i];
            if (!c) return;
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
            log(`‚úÖ Foto ${i+1} posicionada no stories: ${c.x}, ${c.y}, ${c.w}x${c.h} (Resolu√ß√£o: ${img.width}x${img.height})`);
          };
          img.onerror = () => log('‚ùå Erro ao carregar imagem para stories: ' + (p && p.substring ? p.substring(0,50) : 'data'));
        });
      };
      bg.onerror = () => log('‚ùå Erro ao carregar background stories');
    }

    // Desenha montagem para impress√£o 9x14
    function drawPrint(photos){
      const ctx = printCanvas.getContext('2d');
      ctx.clearRect(0, 0, printCanvas.width, printCanvas.height);
      const bg = new Image();
      bg.src = 'imprimir (1).png';
      bg.onload = () => {
        log('‚úÖ Background print carregado: imprimir (1).png - 9x14');
        ctx.drawImage(bg, 0, 0, printCanvas.width, printCanvas.height);
        photos.forEach((p, i) => {
          const img = new Image();
          img.src = p;
          img.onload = () => {
            const c = PRINT_COORDS[i];
            if (!c) return;
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
            log(`‚úÖ Foto ${i+1} posicionada no print: ${c.x}, ${c.y}, ${c.w}x${c.h} (Resolu√ß√£o: ${img.width}x${img.height})`);
          };
          img.onerror = () => log('‚ùå Erro ao carregar imagem para print: ' + (p && p.substring ? p.substring(0,50) : 'data'));
        });
      };
      bg.onerror = () => log('‚ùå Erro ao carregar background print');
    }

    // Impress√£o (abre nova janela com a imagem gerada para imprimir)
    printBtn.addEventListener('click', () => {
      if (!lastPhotos.length) return alert('Nenhuma foto.');
      const data = printCanvas.toDataURL('image/png');
      const w = window.open('');
      w.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Impress√£o Cabine Fotogr√°fica</title>
          <style>
            body { margin: 0; padding: 0; background: white; display:flex; justify-content:center; align-items:center; min-height:100vh; }
            img { max-width:100%; max-height:100vh; display:block; margin:0 auto; }
            @media print {
              body { margin:0; padding:0; }
              img { max-width:100% !important; max-height:100vh !important; width:auto !important; height:auto !important; page-break-inside:avoid; }
              @page { margin:0; size:auto; }
            }
          </style>
        </head>
        <body>
          <img src="${data}" alt="Foto da Cabine" onload="window.print()">
        </body>
        </html>
      `);
      w.document.close();
      w.onload = function() {
        setTimeout(() => { w.print(); }, 500);
      };
    });

    // === FINALIZAR SESS√ÉO ===
    finalizarBtn.addEventListener('click', () => {
      if (!currentSession) return alert('Nenhuma sess√£o ativa.');

      // Avisar o servidor para resetar o celular
      socket.emit('end_session');

      // Limpar miniaturas
      thumbsEl.innerHTML = '';

      // Limpar array local de fotos
      lastPhotos = [];

      // Desabilitar bot√µes que dependem de fotos
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      testImgbbBtn.disabled = true;

      // Limpar QR do visualizador atual e esconder as infos
      qrcodeVisualizadorEl.innerHTML = '';
      viewerInfoEl.style.display = 'none';
      currentViewerSession = null;

      // Limpar canvas (stories e print)
      try {
        const storiesCtx = storiesCanvas.getContext('2d');
        storiesCtx.clearRect(0, 0, storiesCanvas.width, storiesCanvas.height);
      } catch (e) {
        console.warn('‚ö†Ô∏è Erro ao limpar storiesCanvas:', e);
      }
      try {
        const printCtx = printCanvas.getContext('2d');
        printCtx.clearRect(0, 0, printCanvas.width, printCanvas.height);
      } catch (e) {
        console.warn('‚ö†Ô∏è Erro ao limpar printCanvas:', e);
      }

      log('üßπ Sess√£o finalizada - Todas as fotos apagadas e interface resetada');

      // Pequeno delay pra garantir que o emit foi enviado e os logs mostrados
      setTimeout(() => {
        log('üîÅ Recarregando a p√°gina (F5) para reiniciar UI do operador');
        location.reload();
      }, 500);
    });

    // Bot√£o para limpar apenas a interface do visualizador
    limparVisualizadorBtn.addEventListener('click', () => {
      if (confirm('Tem certeza que deseja limpar o visualizador atual? Isso n√£o afetar√° visualizadores j√° compartilhados.')) {
        qrcodeVisualizadorEl.innerHTML = '';
        viewerInfoEl.style.display = 'none';
        currentViewerSession = null;
        log('üßπ Visualizador limpo da interface (visualizadores compartilhados continuam funcionando)');
      }
    });

    // Debug: mostra estado atual e healthcheck
    debugBtn.addEventListener('click', () => {
      log('üêõ DEBUG - Estado atual:');
      log('- Sess√£o FIXA: ' + currentSession);
      log('- Socket conectado: ' + socket.connected);
      log('- Socket ID: ' + socket.id);
      log('- Fotos recebidas: ' + lastPhotos.length);
      log('- Visualizadores no hist√≥rico: ' + viewerHistory.length);

      fetch(SERVER_URL + '/health')
        .then(r => r.json())
        .then(data => {
          log('ü©∫ Health check OK: ' + JSON.stringify(data));
        })
        .catch(e => {
          log('‚ùå Health check FALHOU: ' + (e && e.message ? e.message : e));
        });
    });

    // Inicializa√ß√£o (carregar estado)
    window.addEventListener('DOMContentLoaded', () => {
      log('üîÑ Connecting to fixed session...');
    });

    function addToViewerHistory(viewerId, photosCount) {
      const item = { id: viewerId, timestamp: new Date().toLocaleTimeString(), photosCount };
      viewerHistory.unshift(item);
      updateViewerHistory();
    }

    // Seguran√ßa: quando o servidor confirmar a cria√ß√£o, atualiza o hist√≥rico (tamb√©m via event handler)
    socket.on('viewer_session_created', ({ viewerId }) => {
      addToViewerHistory(viewerId, lastPhotos.length);
    });

    // ===================================================================
    // === ADI√á√ïES: WEBCAM e STREAMING (PC -> celular via stream_frame) ===
    // ===================================================================

    let localStream = null;
    let webcamStreamActive = false;
    let streamingInterval = null;
    let streamingTargetSession = null; // session id receiving frames

    async function startWebcam(){
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 }, audio:false });
        webcamPreview.srcObject = localStream;
        webcamStreamActive = true;
        startWebcamBtn.disabled = true;
        stopWebcamBtn.disabled = false;
        startStreamBtn.disabled = false;
        log('üé• Webcam iniciada');
        // populate video input devices in select (optional)
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          streamSelect.innerHTML = '<option value="">Enviar para sess√£o (autom√°tico request)</option>';
          devices.filter(d => d.kind === 'videoinput').forEach((d) => {
            const opt = document.createElement('option');
            opt.value = currentSession ? currentSession : '';
            opt.textContent = (d.label || 'C√¢mera') + ' ‚Äî sess√£o atual';
            streamSelect.appendChild(opt);
          });
        } catch(e){ /* ignore */ }
      } catch(e){
        log('‚ùå Erro ao iniciar webcam: ' + (e && e.message ? e.message : e));
      }
    }
    function stopWebcam(){
      if(localStream){ localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      webcamPreview.srcObject = null;
      webcamStreamActive = false;
      startWebcamBtn.disabled = false;
      stopWebcamBtn.disabled = true;
      startStreamBtn.disabled = true;
      stopStream(); // also stop any current streaming
      log('üõë Webcam parada');
    }

    // inicia streaming de frames para uma sess√£o (envia dataURLs a cada 100ms)
    function startStreamingToSession(session){
      if(!webcamStreamActive || !localStream){ log('‚ö†Ô∏è Webcam n√£o iniciada'); return; }
      if(streamingInterval) clearInterval(streamingInterval);
      streamingTargetSession = session || currentSession;
      const v = document.createElement('video'); v.playsInline = true; v.muted = true; v.srcObject = localStream;
      v.play().catch(()=>{});
      const canvas = document.createElement('canvas');
      // tamanho razo√°vel para transmit: 800x600
      canvas.width = 800; canvas.height = 600;
      const ctx = canvas.getContext('2d');

      streamingInterval = setInterval(() => {
        try {
          ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
          const frame = canvas.toDataURL('image/jpeg', 0.6); // compress to reduce size
          // emitir frame com a sess√£o alvo
          socket.emit('stream_frame', { session: streamingTargetSession, frame });
        } catch(e){ /* ignore drawing errors */ }
      }, 100); // ~10fps

      stopStreamBtn.disabled = false;
      startStreamBtn.disabled = true;
      log(`‚ñ∂Ô∏è Iniciando stream para sess√£o ${streamingTargetSession} (frames ~10fps)`);
    }
    function stopStream(){
      if(streamingInterval){ clearInterval(streamingInterval); streamingInterval = null; log('‚è∏ Stream parado'); }
      streamingTargetSession = null;
      stopStreamBtn.disabled = true;
      startStreamBtn.disabled = false;
    }

    // UI buttons
    startWebcamBtn.addEventListener('click', startWebcam);
    stopWebcamBtn.addEventListener('click', stopWebcam);

    startStreamBtn.addEventListener('click', () => {
      const target = streamSelect.value || currentSession;
      if(!target){ return alert('Nenhuma sess√£o selecionada. Gere/ou conecte uma sess√£o primeiro.'); }
      startStreamingToSession(target);
    });
    stopStreamBtn.addEventListener('click', () => {
      if(streamingTargetSession) {
        socket.emit('stop_stream', { session: streamingTargetSession });
      }
      stopStream();
    });

    // ===================================================================
    // Fim das adi√ß√µes de webcam/stream. O resto do comportamento original permanece.
    // ===================================================================
  </script>
</body>
</html>
