<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Operador (Webcam + IMGBB)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/favicon.ico">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    body{font-family:Arial, sans-serif; background:#111; color:#eee; margin:0; padding:18px;}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{margin:0 0 8px 0}
    button{background:#0b84ff;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;margin-right:8px}
    button:disabled{background:#444;cursor:not-allowed}
    .qrcode-container{margin:12px 0;padding:10px;background:#222;border-radius:8px;display:inline-block}
    .qrcode-section{margin:20px 0}
    #thumbs{display:flex;flex-wrap:wrap;gap:8px}
    #thumbs img{width:170px;height:auto;border-radius:6px;border:2px solid #222}
    canvas{max-width:100%;display:block;margin-top:12px;border:1px solid #333;background:#000}
    #log{color:#9f9;margin-top:12px;white-space:pre-wrap;font-family:monospace;font-size:12px;max-height:240px;overflow-y:auto}
    .status{background:#333;padding:8px;border-radius:4px;margin:8px 0}
    .connected{color:#4CAF50;}
    .disconnected{color:#f44336;}
    .viewer-info{background:#333;padding:10px;border-radius:5px;margin:10px 0}
    .viewer-history{background:#222;padding:10px;border-radius:5px;margin:10px 0;max-height:200px;overflow-y:auto}
    .viewer-item{margin:5px 0;padding:5px;background:#333;border-radius:3px}
    /* Webcam preview */
    #webcamPreview { width: 640px; height: 480px; background:#000; border:1px solid #333; display:block; margin-top:10px; border-radius:6px; object-fit:cover;}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    /* small responsive adjustments */
    @media(max-width:900px){
      #webcamPreview{width:320px;height:240px}
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>üì∏ Cabine Fotogr√°fica ‚Äî Operador</h1>
      <div id="connectionStatus" class="status disconnected">üî¥ Desconectado</div>
    </div>
    <div style="display:flex;align-items:center;">
      <button id="genQr" disabled>Gerar QR Code Celular</button>
      <button id="finalizarSessao" disabled>Finalizar Sess√£o</button>
      <button id="genVisualizadorQr" disabled>Gerar QR Visualizador + IMGBB</button>
      <button id="printBtn" disabled>Imprimir (10x15)</button>
      <button id="debugBtn">Debug</button>
      <button id="testImgbbBtn" style="background:#28a745" disabled>Testar IMGBB</button>
      <button id="limparVisualizadorBtn" style="background:#dc3545">Limpar Visualizador</button>
    </div>
  </header>

  <div id="sessionInfo">
    <div>Sess√£o: <strong id="sessionId">‚Äî</strong></div>
    
    <div class="qrcode-section">
      <h3>QR Code para Celular (Cabine - SESS√ÉO FIXA)</h3>
      <div id="qrcode" class="qrcode-container"></div>
    </div>
    
    <div class="qrcode-section">
      <h3>QR Code para Visualizador (Cliente - SESS√ÉO √öNICA)</h3>
      <div id="qrcodeVisualizador" class="qrcode-container"></div>
      <div id="viewerInfo" class="viewer-info" style="display:none;">
        <p><strong>Sess√£o Visualizador:</strong> <span id="viewerSessionId">‚Äî</span></p>
        <p><strong>Expira em:</strong> 7 dias</p>
      </div>
    </div>

    <!-- Hist√≥rico de visualizadores -->
    <div class="qrcode-section">
      <h3>Hist√≥rico de Visualizadores</h3>
      <div id="viewerHistory" class="viewer-history">
        <div class="viewer-item">Nenhum visualizador gerado ainda</div>
      </div>
    </div>
  </div>

  <h3>Controle da Webcam / Stream</h3>
  <div class="controls-row">
    <button id="startWebcamBtn">Iniciar Webcam</button>
    <button id="stopWebcamBtn" disabled>Parar Webcam</button>
    <button id="startStreamBtn" disabled>Iniciar Stream para Celular</button>
    <button id="stopStreamBtn" disabled>Parar Stream</button>
    <select id="streamSelect" style="min-width:220px">
      <option value="">Enviar para sess√£o (autom√°tico request)</option>
    </select>
  </div>
  <video id="webcamPreview" autoplay muted playsinline></video>

  <h3>Fotos recebidas</h3>
  <div id="thumbs"></div>

  <h3>Preview ‚Äî Montagem Stories</h3>
  <canvas id="storiesCanvas" width="3375" height="6000"></canvas>

  <h3>Preview ‚Äî Impress√£o (10x15)</h3>
  <canvas id="printCanvas" width="3691" height="5536"></canvas>

  <div id="log"></div>

  <script>
    /* ============================================================
       Index (Operador) completo e corrigido
       - corrige duplica√ß√£o de streamingInterval
       - mant√©m QR, IMGBB, montagem, print, stream, capture
       ============================================================ */

    // CONFIG
    const FIXED_SESSION = 'cabine-fixa';
    const SERVER_URL = (typeof SERVER_URL !== 'undefined') ? SERVER_URL : (location.origin || 'https://festadodavi.onrender.com');

    // elements
    const el = id => document.getElementById(id);
    const qrcodeEl = el('qrcode'), qrcodeVisualizadorEl = el('qrcodeVisualizador');
    const sessionIdEl = el('sessionId'), viewerSessionIdEl = el('viewerSessionId');
    const viewerInfoEl = el('viewerInfo'), viewerHistoryEl = el('viewerHistory');
    const thumbsEl = el('thumbs'), storiesCanvas = el('storiesCanvas'), printCanvas = el('printCanvas');
    const logEl = el('log'), connectionStatusEl = el('connectionStatus');

    const genQrBtn = el('genQr'), finalizarBtn = el('finalizarSessao');
    const genVisualizadorQrBtn = el('genVisualizadorQr'), printBtn = el('printBtn');
    const debugBtn = el('debugBtn'), testImgbbBtn = el('testImgbbBtn');
    const limparVisualizadorBtn = el('limparVisualizadorBtn');

    const startWebcamBtn = el('startWebcamBtn'), stopWebcamBtn = el('stopWebcamBtn');
    const startStreamBtn = el('startStreamBtn'), stopStreamBtn = el('stopStreamBtn');
    const streamSelect = el('streamSelect'), webcamPreview = el('webcamPreview');

    // internal state
    let socket = null;
    let currentSession = FIXED_SESSION;
    let lastPhotos = [];
    let viewerHistory = [];
    let localStream = null;
    let streamingTargetSession = null;

    // DECLARE streamingInterval only ONCE (fixes SyntaxError)
    let streamingInterval = null;

    // small utility
    function log(msg){
      const timestamp = new Date().toLocaleTimeString();
      logEl.textContent = `[${timestamp}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }
    function updateConnectionStatus(connected) {
      if (connected) {
        connectionStatusEl.innerHTML = 'üü¢ Conectado ao Servidor';
        connectionStatusEl.className = 'status connected';
      } else {
        connectionStatusEl.innerHTML = 'üî¥ Desconectado';
        connectionStatusEl.className = 'status disconnected';
      }
    }

    // SOCKET INIT
    function initSocket(){
      if (socket && socket.connected) return;
      socket = io(SERVER_URL, { transports:['websocket'], reconnection:true, timeout:30000 });
      socket.on('connect', () => {
        log('‚úÖ CONECTADO ao servidor: ' + SERVER_URL);
        updateConnectionStatus(true);
        socket.emit('join_session', { session: FIXED_SESSION, role: 'operator' });
        sessionIdEl.textContent = FIXED_SESSION;
        generateQrCode();
        // try to auto-start stream if possible (best-effort)
        tryAutoStart();
        genQrBtn.disabled = false;
        finalizarBtn.disabled = false;
      });
      socket.on('disconnect', (reason) => { log('‚ùå DESCONECTADO: ' + reason); updateConnectionStatus(false); });
      socket.on('connect_error', (err) => { log('‚ùå ERRO conex√£o: ' + (err && err.message ? err.message : err)); updateConnectionStatus(false); });
      socket.on('viewer_session_created', ({ viewerId }) => {
        log('üéâ Sess√£o do visualizador criada (server): ' + viewerId);
        addToViewerHistory(viewerId, lastPhotos.length);
        genVisualizadorQrBtn.disabled = false;
        printBtn.disabled = false;
        testImgbbBtn.disabled = false;
      });
      socket.on('photos_submit', ({ viewerId, photos }) => {
        log(`üì• photos_submit recebido de ${viewerId} (${(photos && photos.length) || 0} fotos)`);
        lastPhotos = Array.isArray(photos) ? photos.slice(0,3) : [];
        renderThumbs();
        // automatically process & upload (or allow manual)
        processPhotosAndUpload(lastPhotos, viewerId);
      });
      socket.on('request_stream', ({ session }) => {
        log('üì° Pedido de stream recebido para sess√£o: ' + session);
        if (localStream) startStreamingToSession(session);
      });
      socket.on('take_photo', ({ session, index, viewerId }) => {
        log('üì∏ Pedido take_photo recebido (do viewer) ‚Äî capturar no operador e enviar');
        captureHighResAndSend(index, viewerId);
      });
      socket.on('photo_ready', ({ index, photo }) => {
        // operator normally doesn't receive this, but log anyway
        log('üîÅ photo_ready relay recebido (opera√ß√£o local)');
      });
      socket.on('reset_session', ({ session }) => {
        log('üîÅ reset_session recebido ‚Äî limpando interface');
        lastPhotos = [];
        renderThumbs();
        clearCanvases();
        qrcodeVisualizadorEl.innerHTML = '';
        genVisualizadorQrBtn.disabled = true;
        printBtn.disabled = true;
        testImgbbBtn.disabled = true;
      });
      socket.on('stream_frame', ({ session, frame }) => {
        // server relay (rare) - only log
        log('üîÅ stream_frame relay recebido (tamanho:' + (frame ? frame.length : 0) + ')');
      });
    }

    // QR Code (celular)
    function generateQrCode(){
      qrcodeEl.innerHTML = '';
      const url = `${location.origin}/celular.html?session=${encodeURIComponent(FIXED_SESSION)}`;
      const canvas = document.createElement('canvas');
      QRCode.toCanvas(canvas, url, { width: 220 }, (err) => { if (err) log('‚ùå Erro ao gerar QR Code: ' + err); });
      qrcodeEl.appendChild(canvas);
      log('üì± QR Code Celular gerado: ' + url);
    }

    // WEBCAM control
    async function startWebcam(){
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: { width: 1920, height: 1080 }, audio:false });
        webcamPreview.srcObject = localStream;
        webcamPreview.play().catch(()=>{});
        startWebcamBtn.disabled = true;
        stopWebcamBtn.disabled = false;
        startStreamBtn.disabled = false;
        log('üé• Webcam iniciada');
      } catch(e){
        log('‚ùå Erro ao iniciar webcam: ' + (e.message || e));
        alert('N√£o foi poss√≠vel acessar a webcam. Verifique permiss√µes.');
      }
    }
    function stopWebcam(){
      if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
      webcamPreview.srcObject = null;
      startWebcamBtn.disabled = false;
      stopWebcamBtn.disabled = true;
      startStreamBtn.disabled = true;
      stopStream();
      log('üõë Webcam parada');
    }

    // Capture hi-res on operator and send to specific viewer
    async function captureHighResAndSend(index, viewerId){
      if (!localStream) { log('‚ö†Ô∏è Webcam n√£o ativa para captura high-res'); return; }
      try {
        const v = document.createElement('video'); v.srcObject = localStream; v.muted = true;
        await v.play().catch(()=>{});
        const c = document.createElement('canvas');
        c.width = v.videoWidth || 1920;
        c.height = v.videoHeight || 1080;
        const ctx = c.getContext('2d');
        // mirror so viewer sees same orientation as preview
        ctx.save(); ctx.translate(c.width,0); ctx.scale(-1,1);
        ctx.drawImage(v, 0, 0, c.width, c.height);
        ctx.restore();
        const photo = c.toDataURL('image/jpeg', 0.95);
        socket.emit('photo_ready', { session: FIXED_SESSION, index, viewerId, photo });
        log('‚úÖ photo_ready enviado para ' + viewerId + ' (index ' + index + ')');
      } catch(e){
        log('‚ùå Erro ao capturar foto high-res: ' + (e.message || e));
      }
    }

    // START / STOP streaming (low-res frames)
    function startStreamingToSession(session){
      if (!localStream) { log('‚ö†Ô∏è Webcam n√£o iniciada'); return; }
      const fps = 20; // configurable
      const intervalMs = Math.max(16, Math.round(1000 / fps));
      const v = document.createElement('video'); v.srcObject = localStream; v.muted = true; v.playsInline = true;
      v.play().catch(()=>{});
      const canvas = document.createElement('canvas');
      canvas.width = 1200; canvas.height = 800;
      const ctx = canvas.getContext('2d');

      // clear previous if exists
      if (streamingInterval) { clearInterval(streamingInterval); streamingInterval = null; }

      streamingInterval = setInterval(() => {
        try {
          ctx.save(); ctx.translate(canvas.width,0); ctx.scale(-1,1);
          ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
          ctx.restore();
          const frame = canvas.toDataURL('image/jpeg', 0.6);
          socket.emit('stream_frame', { session: session || FIXED_SESSION, frame });
        } catch(e){}
      }, intervalMs);

      startStreamBtn.disabled = true;
      stopStreamBtn.disabled = false;
      streamingTargetSession = session || FIXED_SESSION;
      log(`‚ñ∂Ô∏è Iniciando stream para sess√£o ${streamingTargetSession} @ ~${fps}fps`);
    }
    function stopStream(){
      if (streamingInterval) { clearInterval(streamingInterval); streamingInterval = null; log('‚è∏ Stream parado'); }
      streamingTargetSession = null;
      stopStreamBtn.disabled = true;
      startStreamBtn.disabled = false;
    }

    // THUMBS and CANVAS (stories/print)
    function renderThumbs(){
      thumbsEl.innerHTML = '';
      lastPhotos.forEach((p, idx) => {
        const img = document.createElement('img'); img.src = p; img.alt = 'foto-' + (idx+1);
        thumbsEl.appendChild(img);
      });
      if (lastPhotos.length) {
        drawStories(lastPhotos);
        drawPrint(lastPhotos);
      }
    }

    function drawImageCover(ctx, img, x, y, w, h){
      const imgRatio = img.width / img.height;
      const boxRatio = w / h;
      let sx = 0, sy = 0, sw = img.width, sh = img.height;
      if (imgRatio > boxRatio) {
        sw = img.height * boxRatio;
        sx = (img.width - sw) / 2;
      } else {
        sh = img.width / boxRatio;
        sy = (img.height - sh) / 2;
      }
      ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
    }

    // coords from user provided maps
    const STORIES_COORDS = [
      { x: 289, y: 242,  w: 2776 - 289, h: 1809 - 242 },
      { x: 292, y: 2026, w: 2776 - 292, h: 3593 - 2026 },
      { x: 289, y: 3754, w: 2776 - 289, h: 5324 - 3754 }
    ];
    const PRINT_COORDS = [
      { x: 267, y: 212,  w: 3010 - 267, h: 1718 - 212 },
      { x: 267, y: 1887, w: 3017 - 267, h: 3393 - 1887 },
      { x: 274, y: 3556, w: 3023 - 274, h: 5061 - 3556 }
    ];
    const STORIES_TEMPLATE = 'storiesdavi.png';
    const PRINT_TEMPLATE = 'imprimirdavi.png';

    function drawStories(photos){
      const ctx = storiesCanvas.getContext('2d');
      ctx.clearRect(0, 0, storiesCanvas.width, storiesCanvas.height);
      const bg = new Image();
      bg.src = STORIES_TEMPLATE;
      bg.onload = () => {
        ctx.drawImage(bg, 0, 0, storiesCanvas.width, storiesCanvas.height);
        photos.forEach((p, i) => {
          const img = new Image(); img.src = p;
          img.onload = () => {
            const c = STORIES_COORDS[i] || STORIES_COORDS[0];
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
          };
        });
      };
      bg.onerror = () => log('‚ùå Erro ao carregar background stories');
    }

    function drawPrint(photos){
      const ctx = printCanvas.getContext('2d');
      ctx.clearRect(0, 0, printCanvas.width, printCanvas.height);
      const bg = new Image();
      bg.src = PRINT_TEMPLATE;
      bg.onload = () => {
        ctx.drawImage(bg, 0, 0, printCanvas.width, printCanvas.height);
        photos.forEach((p, i) => {
          const img = new Image(); img.src = p;
          img.onload = () => {
            const c = PRINT_COORDS[i] || PRINT_COORDS[0];
            drawImageCover(ctx, img, c.x, c.y, c.w, c.h);
          };
        });
      };
      bg.onerror = () => log('‚ùå Erro ao carregar background print');
    }

    function clearCanvases(){
      try { storiesCanvas.getContext('2d').clearRect(0,0,storiesCanvas.width,storiesCanvas.height); } catch(e){}
      try { printCanvas.getContext('2d').clearRect(0,0,printCanvas.width,printCanvas.height); } catch(e){}
    }

    // IMGBB upload (client-side)
    async function uploadToImgbb(dataUrl, name = 'cabine_photo') {
      try {
        // IMPORTANT: set your IMGBB key here or via prompt; the user previously gave key: fc52605669365cdf28ea379d10f2a341
        const IMGBB_KEY = 'fc52605669365cdf28ea379d10f2a341';
        if (!IMGBB_KEY) throw new Error('IMGBB key n√£o configurada');
        const base64 = dataUrl.replace(/^data:image\/\w+;base64,/, '');
        const form = new FormData();
        form.append('key', IMGBB_KEY);
        form.append('image', base64);
        form.append('name', name);
        const res = await fetch('https://api.imgbb.com/1/upload', { method: 'POST', body: form });
        const json = await res.json();
        if (json && json.success && json.data && json.data.url) return json.data.url;
        throw new Error('IMGBB upload failed: ' + JSON.stringify(json));
      } catch(e) {
        throw e;
      }
    }

    // process photos -> upload -> create visualizador
    async function processPhotosAndUpload(photosArray, viewerId){
      try {
        if(!Array.isArray(photosArray) || photosArray.length === 0) {
          log('Nenhuma foto para processar');
          return;
        }
        const photos = photosArray.slice(0,3);
        while (photos.length < 3) photos.push(photos[photos.length-1] || photosArray[0]);

        log('üîÑ Gerando montagem stories...');
        drawStories(photos);
        const storiesMontage = storiesCanvas.toDataURL('image/jpeg', 0.95);

        log('üîÑ Gerando montagem print...');
        drawPrint(photos);
        const printMontage = printCanvas.toDataURL('image/jpeg', 0.95);

        genVisualizadorQrBtn.disabled = true;
        testImgbbBtn.disabled = true;

        const uploadedPhotos = [];
        for (let i=0;i<3;i++){
          log(`‚è´ Upload foto ${i+1}...`);
          const url = await uploadToImgbb(photos[i], `cabine_photo_${Date.now()}_${i+1}`);
          uploadedPhotos.push(url);
          log(`‚úÖ foto ${i+1} uploadada: ${url}`);
        }
        log('‚è´ Upload montagem stories...');
        const storiesUrl = await uploadToImgbb(storiesMontage, `cabine_stories_${Date.now()}`);
        let printUrl = null;
        try { printUrl = await uploadToImgbb(printMontage, `cabine_print_${Date.now()}`); } catch(e){ log('‚ö†Ô∏è Falha upload print: ' + (e.message||e)); }

        const viewerPayload = { photos: uploadedPhotos, storiesMontage: storiesUrl, print: printUrl, createdAt: new Date().toISOString() };
        // create simple visualizador URL using base64 payload (visualizador.html can parse)
        const payloadStr = JSON.stringify(viewerPayload);
        const b64 = btoa(unescape(encodeURIComponent(payloadStr)));
        const visualizadorUrl = `${location.origin}/visualizador.html?data=${encodeURIComponent(b64)}`;

        // show QR in the operator UI
        qrcodeVisualizadorEl.innerHTML = '';
        const qrCanvas = document.createElement('canvas');
        QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 220 }, (err) => { if (err) log('‚ùå Erro gerar QR: ' + err); });
        qrcodeVisualizadorEl.appendChild(qrCanvas);
        viewerSessionIdEl.textContent = visualizadorUrl;
        viewerInfoEl.style.display = 'block';

        // notify particular viewer (if viewerId known), else broadcast to session
        if (viewerId) {
          socket.emit('show_qr_on_viewer', { viewerId, visualizadorUrl });
          log('üì≤ show_qr_on_viewer emitido para ' + viewerId);
        } else {
          socket.emit('show_qr_to_session', { session: FIXED_SESSION, visualizadorUrl });
          log('üì≤ show_qr_to_session emitido');
        }

        // also notify server to create viewer session (server will keep copy)
        socket.emit('create_viewer_session', { session: FIXED_SESSION, photos: uploadedPhotos, storiesMontage: storiesMontage, print: printMontage });

        genVisualizadorQrBtn.disabled = false;
        testImgbbBtn.disabled = false;
        printBtn.disabled = false;

        addToViewerHistory(visualizadorUrl, uploadedPhotos.length);
        log('üéâ Visualizador criado: ' + visualizadorUrl);
      } catch(e){
        log('‚ùå ERRO no processo IMGBB: ' + (e.message || e));
        genVisualizadorQrBtn.disabled = false;
        testImgbbBtn.disabled = false;
      }
    }

    // Test IMGBB single
    testImgbbBtn.addEventListener('click', async () => {
      if (!lastPhotos.length) return alert('Nenhuma foto');
      try { testImgbbBtn.disabled = true; const url = await uploadToImgbb(lastPhotos[0], 'test_' + Date.now()); log('Teste IMGBB OK: ' + url); } catch(e) { log('Teste IMGBB falhou: ' + (e.message || e)); } finally { testImgbbBtn.disabled = false; }
    });

    // PRINT - open clean window with @page size
    printBtn.addEventListener('click', () => {
      try {
        const data = printCanvas.toDataURL('image/png');
        const w = window.open('', '_blank', 'toolbar=0,location=0,menubar=0');
        w.document.write(`
          <!DOCTYPE html><html><head><meta charset="utf-8"><title>Impress√£o 10x15cm</title>
          <style>
            html,body{margin:0;padding:0;height:100%;width:100%;background:#fff}
            .page{width:10cm;height:15cm;margin:0 auto;display:flex;align-items:center;justify-content:center}
            img{width:100%;height:100%;object-fit:cover;display:block}
            @page{size:10cm 15cm;margin:0}
            @media print { body,html{margin:0;padding:0} img{width:100%;height:100%} }
          </style>
          </head><body>
          <div class="page"><img src="${data}"></div>
          <script>
            window.onload = function(){ setTimeout(()=>{ window.focus(); window.print(); }, 300); };
          </script>
          </body></html>
        `);
        w.document.close();
      } catch(e){ log('Erro ao criar janela de impress√£o: ' + (e.message || e)); }
    });

    // FINALIZAR SESS√ÉO
    finalizarBtn.addEventListener('click', () => {
      if (!confirm('Finalizar sess√£o e limpar fotos?')) return;
      lastPhotos = [];
      renderThumbs();
      clearCanvases();
      qrcodeVisualizadorEl.innerHTML = '';
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      testImgbbBtn.disabled = true;
      // tell viewers (phones) to reset to "iniciar sess√£o"
      try { socket && socket.emit('reset_session', { session: FIXED_SESSION }); log('üîÅ reset_session emitido'); } catch(e){ log('Erro emitir reset_session: ' + e); }
    });

    // viewer history utilities
    function addToViewerHistory(id, photosCount){
      viewerHistory.unshift({ id, timestamp: new Date().toLocaleTimeString(), photosCount });
      updateViewerHistory();
    }
    function updateViewerHistory(){
      viewerHistoryEl.innerHTML = '';
      if (!viewerHistory.length) { viewerHistoryEl.innerHTML = '<div class="viewer-item">Nenhum visualizador gerado ainda</div>'; return; }
      viewerHistory.forEach(it => {
        const d = document.createElement('div'); d.className = 'viewer-item';
        d.innerHTML = `<strong>${it.timestamp}</strong> - ${it.photosCount} fotos - ${it.id.substring(0,80)}`;
        viewerHistoryEl.appendChild(d);
      });
    }

    // render thumbs & draw montages when operator receives final photos
    function renderThumbs(){
      thumbsEl.innerHTML = '';
      lastPhotos.forEach((p, idx) => {
        const img = document.createElement('img'); img.src = p; img.alt = 'foto-'+(idx+1);
        thumbsEl.appendChild(img);
      });
      if (lastPhotos.length) {
        drawStories(lastPhotos);
        drawPrint(lastPhotos);
      }
    }

    // helper: try to auto-start webcam/stream (best-effort; browsers may block without user gesture)
    async function tryAutoStart(){
      try {
        if (!localStream) {
          // we won't auto-start getUserMedia without a user gesture in many browsers ‚Äî so this is best-effort
          // you may call startWebcam() manually from UI
        }
      } catch(e){
        log('Autostart n√£o poss√≠vel: ' + (e.message || e));
      }
    }

    // UI wiring
    startWebcamBtn.addEventListener('click', startWebcam);
    stopWebcamBtn.addEventListener('click', stopWebcam);
    startStreamBtn.addEventListener('click', ()=> startStreamingToSession(FIXED_SESSION));
    stopStreamBtn.addEventListener('click', ()=> { socket && socket.emit('stop_stream', { session: FIXED_SESSION }); stopStream(); } );
    limparVisualizadorBtn.addEventListener('click', ()=> { if(confirm('Limpar visualizador da UI?')){ qrcodeVisualizadorEl.innerHTML=''; viewerInfoEl.style.display='none'; log('Visualizador limpo da interface'); } });

    debugBtn.addEventListener('click', () => {
      log('üêõ DEBUG - Estado atual:');
      log('- Sess√£o FIXA: ' + FIXED_SESSION);
      log('- Socket conectado: ' + (socket && socket.connected));
      log('- Socket ID: ' + (socket ? socket.id : '‚Äî'));
      log('- Fotos recebidas: ' + lastPhotos.length);
      log('- Visualizadores no hist√≥rico: ' + viewerHistory.length);
      fetch(SERVER_URL + '/health').then(r => r.json()).then(data => { log('ü©∫ Health: ' + JSON.stringify(data)); }).catch(e => { log('‚ùå Health check falhou: ' + (e.message || e)); });
    });

    // init on load
    window.addEventListener('DOMContentLoaded', () => {
      initSocket();
      genVisualizadorQrBtn.disabled = true;
      printBtn.disabled = true;
      testImgbbBtn.disabled = true;
      log('Operador pronto. Aguardando fotos do celular...');
    });

    // Prevent accidental redeclaration - sanity check (no-op)
    if (typeof streamingInterval === 'undefined') streamingInterval = null;

  </script>
</body>
</html>
