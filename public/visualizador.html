<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Visualizador — Cabine Fotográfica</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    :root{--bg:#0b0f14;--card:#0f1720;--accent:#0b84ff;--muted:#9aa7b2}
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#041022 0%, #071727 100%);color:#fff}
    header{padding:18px 20px;display:flex;align-items:center;gap:16px;border-bottom:1px solid rgba(255,255,255,0.03)}
    header h1{font-size:18px;margin:0}
    .container{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:18px}
    .panel{background:rgba(255,255,255,0.03);padding:14px;border-radius:12px;min-height:120px}
    .left .section{margin-bottom:12px}
    .small{font-size:13px;color:var(--muted)}
    #debug{font-size:12px;color:#cbd5e1;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;max-height:120px;overflow:auto}
    #itemsList{display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto;margin-top:10px}
    .itemCard{display:flex;gap:10px;align-items:center;padding:8px;border-radius:8px;background:rgba(0,0,0,0.25);cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
    .thumb{width:84px;height:84px;background:#000;display:flex;align-items:center;justify-content:center;border-radius:6px;overflow:hidden}
    .thumb img, .thumb video{width:100%;height:100%;object-fit:cover;display:block}
    .meta{flex:1;display:flex;flex-direction:column;gap:4px}
    .meta .title{font-weight:700}
    .meta .sub{font-size:12px;color:var(--muted)}
    .actions{display:flex;gap:8px}
    button{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff}
    main{padding:14px}
    #viewerArea{background:rgba(0,0,0,0.3);height:70vh;border-radius:12px;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:10px;position:relative}
    #viewerMedia{max-width:100%;max-height:100%;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    #qrModal{position:fixed;right:20px;bottom:20px;background:rgba(0,0,0,0.9);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:none;z-index:999}
    #qrCanvas{width:220px;height:220px;display:block}
    .badge{font-size:12px;padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:999px}
    footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
    .controls{display:flex;gap:8px;align-items:center}
    .u-small{font-size:12px}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-weight:700;border:1px solid rgba(255,255,255,0.02)}
    /* responsive */
    @media (max-width:900px){
      .container{grid-template-columns:1fr;padding:12px}
      #viewerArea{height:55vh}
    }
  </style>
</head>
<body>
  <header>
    <h1>Visualizador — Cabine Fotográfica</h1>
    <div class="small">Backend: <span class="pill">https://festadodavi.onrender.com</span></div>
    <div style="flex:1"></div>
    <div id="status" class="badge">Socket: desconectado</div>
  </header>

  <div class="container">
    <aside class="left">
      <div class="panel section">
        <div class="small">Controles rápidos</div>
        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnRefreshList" class="btn-ghost">Atualizar lista</button>
          <button id="btnClearLocal" class="btn-ghost">Limpar locais</button>
          <button id="btnGenQR" class="btn-ghost">Gerar QR do selecionado</button>
          <button id="btnUploadImgbb" class="btn-ghost">Enviar selecionado ao IMGBB</button>
        </div>
        <div style="margin-top:12px" class="small">Recebidos</div>
        <div id="itemsList"></div>
      </div>

      <div class="panel section">
        <div class="small">Logs / debug</div>
        <div id="debug"></div>
      </div>
    </aside>

    <main>
      <div class="panel" style="margin-bottom:12px">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div><strong id="selectedTitle">Nenhum selecionado</strong><div class="small" id="selectedSub"></div></div>
          <div class="controls">
            <div class="small">Sessão:</div><div class="pill" id="sessionId"></div>
          </div>
        </div>
      </div>

      <div id="viewerArea" class="panel">
        <div id="viewerPlaceholder" class="small">Aguardando conteúdo (fotos / boomerang)...</div>
        <!-- media will be appended here -->
      </div>
    </main>
  </div>

  <div id="qrModal">
    <div style="text-align:center;margin-bottom:8px;color:#ddd">QR do visualizador</div>
    <canvas id="qrCanvas"></canvas>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="btnCloseQR" class="btn-ghost">Fechar</button>
      <button id="btnDownloadQR" class="btn-ghost">Baixar QR</button>
    </div>
  </div>

  <footer>Visualizador — receba fotos e boomerangs do celular e gere QR para visualização</footer>

<script>
/* visualizador.html
   Recebe eventos do servidor e mostra galerias / previews.
   - Lida com:
     * 'photo_ready'  -> { session, index, photo (dataURL) }
     * 'photos_from_cell' -> { session, photos: [dataURL,...] }
     * 'boomerang_ready' -> could be:
         - { session, filename, url }  (server already stored and gives url)
         - { session, filename, data } where data is binary (ArrayBuffer) (we will convert)
     * 'boomerang_stored' -> { session, url, filename } optional server ack
     * 'show_qr' -> { visualizadorUrl } optional server-initiated show
   It also offers UI to generate a QR for the currently selected item (client-side).
*/

const BACKEND = "https://festadodavi.onrender.com"; // conforme memória do usuário
const socket = io(BACKEND, { transports: ['websocket','polling'], path:'/socket.io' });

const debugEl = document.getElementById('debug');
const statusEl = document.getElementById('status');
const itemsList = document.getElementById('itemsList');
const viewerArea = document.getElementById('viewerArea');
const viewerPlaceholder = document.getElementById('viewerPlaceholder');
const sessionIdEl = document.getElementById('sessionId');
const selectedTitle = document.getElementById('selectedTitle');
const selectedSub = document.getElementById('selectedSub');

const qrModal = document.getElementById('qrModal');
const qrCanvas = document.getElementById('qrCanvas');
const btnCloseQR = document.getElementById('btnCloseQR');
const btnDownloadQR = document.getElementById('btnDownloadQR');
const btnGenQR = document.getElementById('btnGenQR');
const btnUploadImgbb = document.getElementById('btnUploadImgbb');

let state = {
  session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa',
  items: [], // { id, type: 'photo'|'boomerang'|'photoset', title, sub, thumbUrl, mediaUrl, rawBlob }
  selectedId: null
};

// set session display
sessionIdEl.textContent = state.session;

// debug helper
function log(msg){
  const t = new Date().toLocaleTimeString();
  debugEl.textContent = `[${t}] ${msg}\n` + debugEl.textContent;
  console.log(msg);
}

// utility to create unique id
function uid(prefix='id'){ return prefix + '_' + Math.random().toString(36).slice(2,9); }

// add item to list & UI
function addItem(item){
  state.items.unshift(item);
  renderItemsList();
  selectItem(item.id);
}

// render left list
function renderItemsList(){
  itemsList.innerHTML = '';
  for(const item of state.items){
    const el = document.createElement('div');
    el.className = 'itemCard';
    el.dataset.id = item.id;
    el.innerHTML = `
      <div class="thumb">${item.thumbHtml || ''}</div>
      <div class="meta">
        <div class="title">${item.title}</div>
        <div class="sub">${item.sub || ''}</div>
      </div>
      <div class="actions">
        <button class="btn-ghost btn-show">Abrir</button>
      </div>
    `;
    // set thumb content (image or video)
    const thumbWrap = el.querySelector('.thumb');
    if(item.thumbUrl){
      if(item.type === 'boomerang') {
        const v = document.createElement('video'); v.src = item.thumbUrl; v.muted = true; v.playsInline = true; v.autoplay = true; v.loop = true;
        thumbWrap.innerHTML = ''; thumbWrap.appendChild(v);
      } else {
        const img = document.createElement('img'); img.src = item.thumbUrl; thumbWrap.innerHTML = ''; thumbWrap.appendChild(img);
      }
    } else {
      thumbWrap.innerHTML = '<div style="padding:8px;color:#999">sem preview</div>';
    }

    // click handlers
    el.querySelector('.btn-show').addEventListener('click', ()=> selectItem(item.id));
    el.addEventListener('click', (ev)=>{
      if(ev.target.closest('button')) return;
      selectItem(item.id);
    });

    itemsList.appendChild(el);
  }
}

// select item to preview
function selectItem(id){
  const item = state.items.find(i=>i.id === id);
  if(!item) return;
  state.selectedId = id;
  selectedTitle.textContent = item.title;
  selectedSub.textContent = item.sub || '';
  // clear viewer
  viewerArea.innerHTML = '';
  // show media according to type
  if(item.type === 'photo'){
    const img = document.createElement('img'); img.id='viewerMedia'; img.src = item.mediaUrl || item.thumbUrl; img.alt = item.title;
    viewerArea.appendChild(img);
  } else if(item.type === 'boomerang'){
    const v = document.createElement('video'); v.id='viewerMedia'; v.src = item.mediaUrl; v.controls = true; v.loop = true; v.autoplay = true; v.playsInline = true;
    viewerArea.appendChild(v);
  } else if(item.type === 'photoset'){
    // show grid of 3
    const box = document.createElement('div'); box.style.display='flex'; box.style.gap='8px';
    for(const m of item.mediaUrls || []){
      const img = document.createElement('img'); img.src = m; img.style.width='33%'; img.style.height='auto'; img.style.objectFit='cover'; box.appendChild(img);
    }
    viewerArea.appendChild(box);
  } else {
    viewerArea.textContent = 'Tipo desconhecido';
  }
}

// handle socket events
socket.on('connect', ()=> {
  statusEl.textContent = 'Socket: conectado';
  statusEl.style.background = 'transparent';
  log('Conectado ao backend (socket id: ' + socket.id + ')');
  // inform server which session this visualizador cares about
  socket.emit('viewer_join', { session: state.session });
});

// binary boomerang could be sent as binary blob via socket.
// We'll listen for both object and binary events.
socket.on('disconnect', ()=> {
  statusEl.textContent = 'Socket: desconectado';
  log('Socket desconectado');
});

// photo ready: photo is a dataURL (jpeg)
socket.on('photo_ready', (payload) => {
  try {
    const { session, index, photo } = payload;
    if(session && session !== state.session) return;
    const id = uid('photo');
    const item = { id, type:'photo', title: `Foto ${index!=null?index+1:'?'}`, sub:`Recebido`, thumbUrl: photo, mediaUrl: photo };
    addItem(item);
    log('photo_ready recebido (index ' + index + ')');
  } catch(e){ log('Erro handler photo_ready: ' + e); }
});

// photos_from_cell: array of dataURLs (3 photos) — create a photoset item
socket.on('photos_from_cell', (payload) => {
  try {
    const { session, photos } = payload;
    if(session && session !== state.session) return;
    const id = uid('photoset');
    const item = { id, type:'photoset', title: 'Conjunto: 3 Fotos', sub: 'Recebido do celular', mediaUrls: photos, thumbUrl: photos[0] };
    addItem(item);
    log('photos_from_cell recebido (len=' + (photos && photos.length) + ')');
  } catch(e){ log('Erro handler photos_from_cell: ' + e); }
});

// boomerang_ready: server might send object with url OR binary chunk
// We support two situations:
// 1) server emits { session, filename, url } -> file is already stored by server and accessible
// 2) server emits event with binary (ArrayBuffer) under same event -> socket.io will provide binary as second arg
socket.on('boomerang_ready', async (payload, bin) => {
  try {
    // payload may be object or ArrayBuffer depending on server implementation
    if(payload && payload.session && payload.session !== state.session) return;

    // case A: payload has url
    if(payload && payload.url){
      const id = uid('boom');
      const item = { id, type:'boomerang', title: payload.filename || 'Boomerang', sub:'Disponível no servidor', thumbUrl: payload.thumb || payload.url, mediaUrl: payload.url };
      addItem(item);
      log('boomerang_ready recebido (url): ' + payload.url);
      return;
    }

    // case B: binary arg provided (socket.io sends binary as second parameter)
    if(bin && bin instanceof ArrayBuffer){
      const filename = (payload && payload.filename) ? payload.filename : `boomerang_${Date.now()}.webm`;
      const blob = new Blob([bin], { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const id = uid('boom');
      const item = { id, type:'boomerang', title: filename, sub:'Recebido (socket binary)', thumbUrl: url, mediaUrl: url, rawBlob: blob };
      addItem(item);
      log('boomerang_ready recebido (ArrayBuffer) size=' + bin.byteLength);
      // ask server to store the blob permanently (server must implement 'store_blob' handler)
      try {
        socket.emit('store_blob_request', { session: state.session, filename }, (ack) => {
          // ack can be { ok:true, url } if server stored successfully
          if(ack && ack.ok && ack.url){
            // update item mediaUrl to server url
            item.mediaUrl = ack.url;
            item.thumbUrl = ack.url;
            // re-render
            renderItemsList();
            if(state.selectedId === id) selectItem(id);
            log('Servidor armazenou boomerang e retornou url: ' + ack.url);
          } else {
            log('Servidor não retornou url ao armazenar blob (ack): ' + JSON.stringify(ack));
          }
        });
        // emit binary to server (socket.io binary) so server can write it to disk
        socket.emit('upload_blob', { session: state.session, filename }, bin);
      } catch(e){ log('Tentativa de salvar blob no servidor falhou: ' + e); }
      return;
    }

    // case C: sometimes payload may contain base64 or arraybuffer inside property
    if(payload && payload.data){
      // try to handle base64 string
      try {
        let b64 = payload.data;
        if(b64.startsWith('data:')) {
          const id = uid('boom');
          const item = { id, type:'boomerang', title: payload.filename || 'Boomerang', sub:'Recebido base64', thumbUrl: b64, mediaUrl: b64 };
          addItem(item);
          log('boomerang_ready recebido (data URL)');
          return;
        } else {
          // treat as base64 raw
          const byteChars = atob(b64);
          const len = byteChars.length;
          const arr = new Uint8Array(len);
          for (let i=0;i<len;i++) arr[i] = byteChars.charCodeAt(i);
          const blob = new Blob([arr], { type:'video/webm' });
          const url = URL.createObjectURL(blob);
          const id = uid('boom');
          const item = { id, type:'boomerang', title: payload.filename || 'Boomerang', sub:'Recebido base64', thumbUrl: url, mediaUrl: url, rawBlob: blob };
          addItem(item);
          log('boomerang_ready recebido (base64 convertido)');
          return;
        }
      } catch(e){}
    }

    log('boomerang_ready payload inesperado: ' + JSON.stringify(payload).slice(0,200));
  } catch(e){ log('Erro handler boomerang_ready: ' + e); }
});

// server may explicitly send a 'boomerang_stored' event with public URL
socket.on('boomerang_stored', (payload) => {
  try {
    if(payload.session && payload.session !== state.session) return;
    if(payload.url){
      const id = uid('boomstored');
      const item = { id, type:'boomerang', title: payload.filename || 'Boomerang', sub:'Armazenado no servidor', thumbUrl: payload.url, mediaUrl: payload.url };
      addItem(item);
      log('boomerang_stored: ' + payload.url);
    }
  } catch(e){ log('Erro boomerang_stored: ' + e); }
});

// server may ask to show QR directly
socket.on('show_qr', ({ visualizadorUrl }) => {
  if(!visualizadorUrl) return;
  generateAndShowQRCode(visualizadorUrl);
  log('show_qr recebido: ' + visualizadorUrl);
});

// UI controls
document.getElementById('btnRefreshList').addEventListener('click', ()=> renderItemsList());
document.getElementById('btnClearLocal').addEventListener('click', ()=> {
  state.items = []; state.selectedId = null; renderItemsList(); viewerArea.innerHTML = '<div id="viewerPlaceholder" class="small">Aguardando conteúdo (fotos / boomerang)...</div>';
  log('Lista limpa localmente');
});

// Gen QR for selected
btnGenQR.addEventListener('click', async ()=>{
  const item = state.items.find(i=>i.id === state.selectedId);
  if(!item){ alert('Selecione um item para gerar QR'); return; }
  // if item.mediaUrl looks like a server url use it; if only blob url, ask server to store and return public url first
  let urlToEncode = item.mediaUrl || item.thumbUrl;
  if(!urlToEncode){
    alert('Item não possui URL pública. Tente salvar no servidor primeiro.');
    return;
  }
  // If it's an object URL (blob:), we should request server to store and return a public URL.
  if(urlToEncode.startsWith('blob:') || urlToEncode.startsWith('data:')){
    // ask server to store raw blob if we have rawBlob
    if(item.rawBlob){
      const filename = (item.title||'media') + '.webm';
      log('Solicitando servidor para armazenar blob (' + filename + ')');
      // send store request and rely on server to respond with url via callback event
      socket.emit('store_blob_request', { session: state.session, filename }, (ack) => {
        if(ack && ack.ok && ack.url){
          log('Servidor armazenou e retornou url: ' + ack.url);
          generateAndShowQRCode(ack.url);
        } else {
          alert('Servidor não conseguiu armazenar blob. Verifique logs.');
        }
      });
      // send the blob binary via upload_blob event
      const reader = new FileReader();
      reader.onload = function(){ 
        const ab = reader.result;
        socket.emit('upload_blob', { session: state.session, filename }, ab);
      };
      reader.readAsArrayBuffer(item.rawBlob);
      return;
    } else {
      alert('Item tem URL local (blob) mas não temos o rawBlob para enviar ao servidor.');
      return;
    }
  } else {
    generateAndShowQRCode(urlToEncode);
  }
});

// Upload to IMGBB (client-side) for selected item (optional)
btnUploadImgbb.addEventListener('click', async ()=>{
  const it = state.items.find(i=>i.id === state.selectedId);
  if(!it){ alert('Selecione um item para enviar'); return; }
  // we will try to produce a base64 from mediaUrl if it's dataURL already, or fetch blob then convert.
  try {
    let dataUrl = null;
    if(it.mediaUrl && it.mediaUrl.startsWith('data:')){
      dataUrl = it.mediaUrl;
    } else if(it.rawBlob) {
      dataUrl = await blobToDataURL(it.rawBlob);
    } else if(it.mediaUrl && it.mediaUrl.startsWith('http')) {
      // fetch it and convert
      const r = await fetch(it.mediaUrl);
      const b = await r.blob();
      dataUrl = await blobToDataURL(b);
    } else {
      alert('Não foi possível obter imagem/vid para upload.');
      return;
    }
    // Replace with your IMGBB key if serverless needed — better: have server do it.
    const IMGBB_KEY = 'COLOQUE_SUA_CHAVE_IMGBB_AQUI';
    if(!IMGBB_KEY || IMGBB_KEY.includes('COLOQUE')) {
      alert('Para enviar ao IMGBB, configure a chave IMGBB no código (btnUploadImgbb).');
      return;
    }
    // prepare base64 payload
    const base64 = dataUrl.split(',')[1];
    showPrompt('Enviando ao IMGBB...');
    const form = new FormData();
    form.append('key', IMGBB_KEY);
    form.append('image', base64);
    const resp = await fetch('https://api.imgbb.com/1/upload', { method:'POST', body: form });
    const j = await resp.json();
    hidePrompt();
    if(j && j.data && j.data.url){
      alert('Enviado ao IMGBB: ' + j.data.url);
      log('IMGBB upload ok: ' + j.data.url);
    } else {
      alert('Erro ao enviar ao IMGBB: ' + JSON.stringify(j));
    }
  } catch(e){ hidePrompt(); alert('Erro upload IMGBB: ' + e); log('Erro upload IMGBB: ' + e); }
});

// helper convert blob->dataURL
function blobToDataURL(blob){
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result);
    r.onerror = rej;
    r.readAsDataURL(blob);
  });
}

// generate and show QR canvas modal
function generateAndShowQRCode(url){
  qrModal.style.display = 'block';
  qrCanvas.getContext('2d').clearRect(0,0,qrCanvas.width, qrCanvas.height);
  QRCode.toCanvas(qrCanvas, url, { width: 520 }, function (error) {
    if (error) { log('Erro gerar QR: ' + error); alert('Erro ao gerar QR: ' + error); return; }
    log('QR gerado para: ' + url);
  });
}
btnCloseQR.addEventListener('click', ()=> qrModal.style.display = 'none');
btnDownloadQR.addEventListener('click', ()=>{
  const a = document.createElement('a');
  a.href = qrCanvas.toDataURL('image/png');
  a.download = 'qrcode.png';
  a.click();
});

// small prompt overlay (simple)
function showPrompt(txt){ const p = document.createElement('div'); p.id='__prompt'; p.style.position='fixed'; p.style.left='50%'; p.style.top='20px'; p.style.transform='translateX(-50%)'; p.style.background='rgba(0,0,0,0.8)'; p.style.padding='8px 12px'; p.style.borderRadius='8px'; p.style.zIndex=9999; p.style.color='#fff'; p.textContent = txt; document.body.appendChild(p); }
function hidePrompt(){ const p = document.getElementById('__prompt'); if(p) p.remove(); }

// initial demo: if desired, request server for current list
document.querySelector('#btnRefreshList').addEventListener('click', ()=> {
  socket.emit('request_items', { session: state.session }, (rsp) => {
    if(rsp && Array.isArray(rsp.items)){
      // rsp.items expected to be array of { type, url, thumb, filename, id }
      for(const it of rsp.items){
        const id = uid('srv');
        const item = { id, type: it.type || 'photo', title: it.filename || 'item', sub: 'listado', thumbUrl: it.thumb || it.url, mediaUrl: it.url };
        addItem(item);
      }
      log('Lista recebida do servidor (request_items)');
    } else {
      log('request_items retornou nada');
    }
  });
});

// utility uid re-declare here
function uid(prefix='id'){ return prefix + '_' + Math.random().toString(36).slice(2,9); }

// initial state
renderItemsList();
log('Visualizador init — esperando conteúdo (session: ' + state.session + ')');

// helpful: when page unloads revoke object URLs
window.addEventListener('beforeunload', () => {
  for(const it of state.items){
    try { if(it.mediaUrl && it.mediaUrl.startsWith('blob:')) URL.revokeObjectURL(it.mediaUrl); } catch(e){}
  }
});

</script>
</body>
</html>
