<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:18px}
    .card{width:100%;max-width:460px;background:rgba(255,255,255,0.03);border-radius:14px;padding:18px;text-align:center;backdrop-filter:blur(8px)}
    button{cursor:pointer;border:none;border-radius:12px;padding:12px 16px;font-weight:700}
    #enterFsBtn{background:#ffd600;color:#000;width:100%;font-size:16px}
    #startBtn{background:#0b84ff;color:#fff;width:100%;font-size:16px}
    .mode-btn{width:92px;height:92px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;font-size:28px;margin:8px}
    .mode-btn.boom{background:linear-gradient(135deg,#2a9df4,#0b6fb3);color:white}
    .mode-btn.three{background:linear-gradient(135deg,#ffd34d,#d18a00);color:#111}
    .logo{max-width:160px;margin:10px auto;display:block}
    /* video / canvas */
    #videoEl{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:1;display:none;transform:scaleX(-1)}
    #canvasEl{position:fixed;inset:0;z-index:2;display:none}
    #cropOverlay{position:fixed;z-index:3;pointer-events:none;border:2px dashed rgba(255,255,255,0.95);box-shadow:0 0 0 20000px rgba(0,0,0,0.25);display:none}
    #countdown{position:fixed;top:18%;left:0;right:0;text-align:center;font-size:96px;font-weight:900;z-index:40;color:#fff;text-shadow:0 0 40px rgba(0,0,0,0.7);display:none}
    #msg{position:fixed;bottom:14%;left:0;right:0;text-align:center;font-size:16px;z-index:40}
    /* preview modal */
    #previewScreen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:80;background:rgba(0,0,0,0.95)}
    #previewImage{max-width:92%;max-height:78%;object-fit:contain;border-radius:8px}
    .preview-buttons{display:flex;gap:12px;margin-top:14px}
    .preview-btn{padding:10px 14px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:1px solid rgba(255,255,255,0.06)}
    /* QR overlay */
    .qr-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:200;background:rgba(0,0,0,0.5)}
    .qr-modal{background:#fff;padding:16px;border-radius:10px;color:#111;text-align:center}
    #debugInfo{position:fixed;left:10px;bottom:8px;font-size:11px;color:#ddd;z-index:300;white-space:pre-line;max-width:46%}
    @media(max-width:480px){ #countdown{font-size:72px} .mode-btn{width:72px;height:72px;font-size:22px} }
  </style>
</head>
<body>
  <!-- Screen 1: Enter Fullscreen only -->
  <div id="enterFs" class="screen" style="background:linear-gradient(135deg,#fff,#f5f5f5)">
    <div class="card">
      <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
      <h2 style="color:#222;margin:6px 0">üì∏ Cabine Fotogr√°fica</h2>
      <p style="color:#444;margin-bottom:12px">Entre em tela cheia para come√ßar</p>
      <button id="enterFsBtn">üé¨ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- Screen 2: Welcome -->
  <div id="welcomeScreen" class="screen" style="display:none;background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div class="card">
      <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
      <h3 style="color:#222;margin:6px 0">üì∏ Preparado?</h3>
      <p style="color:#444;margin-bottom:12px">Toque em Iniciar Sess√£o</p>
      <button id="startBtn">‚ñ∂Ô∏è Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- Screen 3: Mode Selection -->
  <div id="modeScreen" class="screen" style="display:none;background:linear-gradient(135deg,#000,#111)">
    <div class="card" style="background:transparent">
      <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
      <h4 style="margin:6px 0">Escolha o modo</h4>
      <div>
        <button id="chooseBoom" class="mode-btn boom" title="Boomerang">&infin;</button>
        <button id="chooseThree" class="mode-btn three" title="3 Fotos">‚ò∞</button>
      </div>
      <p style="color:#ddd;margin-top:12px">Boomerang = v√≠deo vertical. 3 Fotos = impress√£o (envia 3 fotos ao operador).</p>
    </div>
  </div>

  <!-- Video / Canvas + overlays -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>
  <div id="cropOverlay"></div>
  <div id="countdown"></div>
  <div id="msg"></div>

  <!-- Preview modal -->
  <div id="previewScreen">
    <div style="text-align:center">
      <img id="previewImage" src="">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">üîÑ Refazer</button>
        <button id="continuarBtn" class="preview-btn">‚úÖ Continuar</button>
      </div>
    </div>
  </div>

  <!-- Thank you -->
  <div id="thankScreen" class="screen" style="display:none;background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div class="card">
      <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
      <h3 style="color:#222">‚ú® Obrigado!</h3>
      <p style="color:#444">Aguarde at√© o operador finalizar a sess√£o.</p>
    </div>
  </div>

  <!-- QR overlay -->
  <div id="qrOverlay" class="qr-overlay">
    <div class="qr-modal">
      <div style="font-weight:700;margin-bottom:8px">Escaneie o QR para ver suas fotos</div>
      <canvas id="qrCanvas" width="260" height="260" style="background:#fff;border-radius:6px"></canvas>
      <div style="font-size:13px;color:#444;margin-top:8px">As fotos ficar√£o dispon√≠veis por 7 dias</div>
    </div>
  </div>

  <div id="debugInfo"></div>

  <audio id="beep" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/* CELULAR ‚Äî vers√£o corrigida:
   - Usa canvas draw loop para preview (remove tela preta / congelada)
   - Espera metadata antes de gravar boomerang
   - Clamps crop coords e fallback caso necess√°rio
   - Emite photos_submit e boomerang_ready com ack para confirmar envio
*/

(function(){
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const socket = io(SERVER_URL, { transports:['polling','websocket'], reconnection:true, path:'/socket.io' });

  // template coords (provided)
  const TEMPLATE_W = 3375, TEMPLATE_H = 6000;
  const BOOM_AREA = { x:295, y:272, w:2785, h:4159 };
  const BOOM_TARGET_W = 1080;
  const BOOM_TARGET_H = Math.round(BOOM_TARGET_W * (BOOM_AREA.h / BOOM_AREA.w));

  // DOM
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const modeScreen = document.getElementById('modeScreen');
  const chooseBoom = document.getElementById('chooseBoom');
  const chooseThree = document.getElementById('chooseThree');

  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const cropOverlay = document.getElementById('cropOverlay');
  const countdownEl = document.getElementById('countdown');
  const msgEl = document.getElementById('msg');

  const previewScreen = document.getElementById('previewScreen');
  const previewImage = document.getElementById('previewImage');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');

  const qrOverlay = document.getElementById('qrOverlay');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugEl = document.getElementById('debugInfo');

  const thankScreen = document.getElementById('thankScreen');

  // state
  const session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
  let mode = null; // 'three' | 'boom'
  let stream = null;
  let rafId = null;
  let videoLoopRunning = false;
  let photos = [];

  // debug updater
  setInterval(()=> {
    debugEl.textContent = `Sess√£o: ${session}\nModo: ${mode || '-'}\nFotos capturadas: ${photos.length}\nSocket: ${socket.connected ? 'üü¢ conectado' : 'üî¥ desconectado'}`;
  }, 900);

  // show/hide screens
  function showOnly(el){
    [enterFs, welcomeScreen, modeScreen, previewScreen, thankScreen].forEach(s => { if(!s) return; s.style.display = (s===el) ? 'flex' : 'none'; });
    // hide canvas/video overlays unless explicitly used
    if (el !== null && el !== undefined) {
      // when a main screen is shown, we typically hide the camera preview unless mode screen is next to start capture.
    }
  }

  showOnly(enterFs);

  // socket handlers
  socket.on('connect', ()=> {
    log('socket conectado: ' + socket.id);
    socket.emit('join_session', { session, role:'viewer' });
    socket.emit('request_stream', { session, viewerId: socket.id }); // ask operator for stream frame (optional)
  });

  socket.on('disconnect',(r)=> log('socket desconectado: '+r));

  socket.on('show_qr', ({ visualizadorUrl }) => {
    if (!visualizadorUrl) return;
    try {
      QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 260 }, (err) => {
        if (err) log('Erro gerar QR: '+err);
        qrOverlay.style.display = 'flex';
      });
    } catch(e){ qrOverlay.style.display = 'flex'; }
  });

  socket.on('reset_session', ({ session: s }) => {
    if (s && s !== session) return;
    photos = [];
    stopPreviewLoop();
    stopAndReleaseCamera();
    showOnly(welcomeScreen);
    qrOverlay.style.display = 'none';
  });

  // UI wiring
  enterFsBtn.addEventListener('click', async ()=> {
    try { await document.documentElement.requestFullscreen().catch(()=>{}); } catch(e){}
    showOnly(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', ()=> {
    showOnly(modeScreen);
  });

  chooseThree.addEventListener('click', async ()=> {
    mode = 'three';
    photos = [];
    await startCameraAndPreview();
    hideAllCardsKeepPreview();
    await startThreePhotosSequence();
  });

  chooseBoom.addEventListener('click', async ()=> {
    mode = 'boom';
    await startCameraAndPreview();
    drawBoomOverlay(); cropOverlay.style.display = 'block';
    hideAllCardsKeepPreview();
    await startBoomerangSequence();
  });

  function hideAllCardsKeepPreview(){
    // hide UI cards but keep preview canvas visible
    enterFs.style.display = 'none';
    welcomeScreen.style.display = 'none';
    modeScreen.style.display = 'none';
    // show canvas
    canvasEl.style.display = 'block';
    videoEl.style.display = 'none';
    countdownEl.style.display = 'none';
  }

  // start camera and preview loop (draw video into canvas to avoid black frames)
  async function startCameraAndPreview(){
    await ensureFrontCameraStream();
    // prepare canvas to match viewport and DPR
    resizeCanvasToWindow();
    if (!videoLoopRunning) startPreviewLoop();
    canvasEl.style.display = 'block';
    videoEl.style.display = 'none';
  }

  function resizeCanvasToWindow(){
    const dpr = window.devicePixelRatio || 1;
    canvasEl.width = Math.floor(window.innerWidth * dpr);
    canvasEl.height = Math.floor(window.innerHeight * dpr);
    canvasEl.style.width = window.innerWidth + 'px';
    canvasEl.style.height = window.innerHeight + 'px';
    const ctx = canvasEl.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', ()=> { resizeCanvasToWindow(); if (mode === 'boom') drawBoomOverlay(); });

  function startPreviewLoop(){
    if (videoLoopRunning) return;
    videoLoopRunning = true;
    const ctx = canvasEl.getContext('2d');
    function loop(){
      if (!stream || videoEl.readyState < 2) {
        // draw black background until frame available
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvasEl.width,canvasEl.height);
      } else {
        // draw video to canvas cover (mirrored)
        const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
        if (vw && vh) {
          const cw = canvasEl.clientWidth, ch = canvasEl.clientHeight;
          // compute cover scale
          const scale = Math.max(cw / vw, ch / vh);
          const drawW = vw * scale, drawH = vh * scale;
          const dx = (cw - drawW) / 2, dy = (ch - drawH) / 2;
          // scale transform (we already set DPR transform)
          // Clear then draw mirrored
          ctx.save();
          ctx.clearRect(0,0,cw,ch);
          ctx.translate(cw, 0); ctx.scale(-1,1); // mirror horizontally
          // We need to draw with mirrored coordinates; to do that use negative destination x.
          // Draw image normal but with translate+scale done.
          // Because of translate(cw,0) and scale(-1,1), destination x 0 corresponds to right edge,
          // so drawImage's destX should be dx (but mirrored), easiest: drawImage with destX = cw - (dx + drawW)
          const destX = cw - (dx + drawW);
          ctx.drawImage(videoEl, 0, 0, vw, vh, destX, dy, drawW, drawH);
          ctx.restore();
        } else {
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvasEl.clientWidth,canvasEl.clientHeight);
        }
      }
      rafId = requestAnimationFrame(loop);
    }
    loop();
  }

  function stopPreviewLoop(){
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    videoLoopRunning = false;
    canvasEl.style.display = 'none';
    cropOverlay.style.display = 'none';
  }

  // ensure camera stream and wait loadedmetadata/play
  async function ensureFrontCameraStream(){
    if (stream) return stream;
    try {
      const constraints = { video: { facingMode: { ideal: "user" }, width: { ideal: 1080 }, height:{ ideal:1920 } }, audio:false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream;
      videoEl.muted = true;
      await new Promise((res, rej) => {
        // wait for metadata / first frame
        const onMeta = () => { videoEl.removeEventListener('loadedmetadata', onMeta); res(); };
        videoEl.addEventListener('loadedmetadata', onMeta);
        // also set a timeout fallback
        setTimeout(()=>res(), 1200);
      });
      try { await videoEl.play().catch(()=>{}); } catch(e){}
      return stream;
    } catch(e){
      log('Erro ao acessar c√¢mera frontal: ' + (e.message||e));
      alert('N√£o foi poss√≠vel acessar a c√¢mera frontal. Verifique permiss√µes.');
      throw e;
    }
  }

  // stop camera
  function stopAndReleaseCamera(){
    if (!stream) return;
    stream.getTracks().forEach(t=>t.stop());
    stream = null;
    videoEl.srcObject = null;
    canvasEl.style.display = 'none';
    cropOverlay.style.display = 'none';
  }

  // draw boom overlay (map BOOM_AREA to visible canvas)
  function drawBoomOverlay(){
    // map BOOM_AREA from template -> screen coordinates (using same cover logic as preview loop)
    const vw = videoEl.videoWidth || 1080;
    const vh = videoEl.videoHeight || 1920;
    const cw = canvasEl.clientWidth;
    const ch = canvasEl.clientHeight;
    const scale = Math.max(cw / vw, ch / vh);
    const drawW = vw * scale, drawH = vh * scale;
    const dx = (cw - drawW) / 2, dy = (ch - drawH) / 2;
    // template->draw scale: drawW / TEMPLATE_W
    const s = drawW / TEMPLATE_W;
    const cx = dx + BOOM_AREA.x * s;
    const cy = dy + BOOM_AREA.y * s;
    const cwRect = BOOM_AREA.w * s;
    const chRect = BOOM_AREA.h * s;
    cropOverlay.style.left = cx + 'px';
    cropOverlay.style.top = cy + 'px';
    cropOverlay.style.width = cwRect + 'px';
    cropOverlay.style.height = chRect + 'px';
  }

  // ---------------------------
  // THREE PHOTOS FLOW
  // ---------------------------
  async function startThreePhotosSequence(){
    photos = [];
    for (let i=0;i<3;i++){
      try {
        await runCountdown(5);
        // capture current frame from canvas (which is mirrored to match preview)
        const dataUrl = captureFromCanvasHighRes();
        const decision = await showPreviewAndWait(dataUrl);
        if (decision === 'refazer') { i = i - 1; continue; }
        photos.push(dataUrl);
        log('Foto capturada (index ' + i + ') size ~' + Math.round((dataUrl.length*3)/4/1024) + 'KB');
      } catch(e){
        log('Erro na captura 3x: ' + (e.message||e)); i = i - 1; await sleep(600);
      }
    }

    // Emit photos_submit with acknowledgement callback
    const payload = { session, viewerId: socket.id, photos };
    socket.emit('photos_submit', payload, (ack) => {
      // server ack handling
      log('photos_submit ACK: ' + JSON.stringify(ack || 'null'));
      if (ack && ack.ok) {
        msg('Fotos enviadas com sucesso');
      } else {
        msg('Erro ao enviar fotos ao servidor (verifique).');
      }
    });
    // show thank
    stopPreviewLoop();
    stopAndReleaseCamera();
    showOnly(thankScreen);
    try { playAudio('fim'); } catch(e){}
  }

  function captureFromCanvasHighRes(){
    // create a capture canvas at video resolution (use videoWidth/videoHeight) to preserve quality
    const vw = videoEl.videoWidth || 1080;
    const vh = videoEl.videoHeight || 1920;
    const cap = document.createElement('canvas');
    cap.width = vw; cap.height = vh;
    const ctx = cap.getContext('2d');
    // We used mirrored preview drawing: so to capture the same orientation, draw mirrored.
    ctx.save();
    ctx.translate(vw,0); ctx.scale(-1,1);
    try { ctx.drawImage(videoEl, 0,0,vw,vh); } catch(e){
      // fallback: draw from canvasEl scaled
      const tmpCtx = canvasEl.getContext('2d');
      ctx.drawImage(canvasEl, 0,0, cap.width, cap.height);
    }
    ctx.restore();
    return cap.toDataURL('image/jpeg', 0.95);
  }

  // Preview modal show + wait for refazer/continuar
  function showPreviewAndWait(dataUrl){
    return new Promise(resolve=>{
      previewImage.src = dataUrl;
      previewScreen.style.display = 'flex';
      function onRef(){ cleanup(); resolve('refazer'); }
      function onCont(){ cleanup(); resolve('continuar'); }
      function cleanup(){ previewScreen.style.display = 'none'; refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    });
  }

  // ---------------------------
  // BOOMERANG FLOW
  // ---------------------------
  async function startBoomerangSequence(){
    await runCountdown(3);
    // record short cropped clip (2s) from canvas (we'll draw crop from canvas into offscreen)
    const shortBlob = await recordCroppedShortClipFromCanvas(2000);
    if (!shortBlob) { log('falha gravar short clip'); msg('Erro ao gravar boomerang.'); return; }
    const thumb = await blobToDataURL(shortBlob, true).catch(()=>null);

    // process boomerang to ~15s by repeating forward+reverse
    msg('Processando boomerang...');
    const finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs:15000, targetW:BOOM_TARGET_W, targetH:BOOM_TARGET_H });
    if (!finalBlob) { log('falha gerar boomerang final'); msg('Erro processando boomerang'); return; }

    // send via socket (ArrayBuffer) with ack if server supports
    try {
      const ab = await finalBlob.arrayBuffer();
      socket.emit('boomerang_ready', { session, viewerId: socket.id, filename:`boomerang_${Date.now()}.webm`, data: ab }, (ack) => {
        log('boomerang_ready ACK: ' + JSON.stringify(ack||'null'));
      });
      if (thumb) socket.emit('photo_ready', { session, index:0, viewerId: socket.id, photo: thumb });
      // also keep photos_submit consistency
      socket.emit('photos_submit', { session, viewerId: socket.id, photos: [thumb] }, (ack) => {
        log('photos_submit (boom) ACK: ' + JSON.stringify(ack||'null'));
      });
      msg('Boomerang enviado!');
    } catch(e){
      log('Erro enviando boomerang: ' + e);
      const url = URL.createObjectURL(finalBlob);
      window.open(url,'_blank');
      msg('Erro ao enviar boomerang. Abra nova aba para download.');
    }

    stopPreviewLoop();
    stopAndReleaseCamera();
    showOnly(thankScreen);
    try { playAudio('fim'); } catch(e){}
  }

  // record cropped short clip by drawing the crop area from the live canvas (not directly from video)
  async function recordCroppedShortClipFromCanvas(msDuration = 2000){
    const cw = canvasEl.clientWidth, ch = canvasEl.clientHeight;
    if (!cw || !ch) {
      log('canvas dims invalid');
      return null;
    }

    // Calculate crop in canvas coordinate (we used drawBoomOverlay mapping)
    // We'll compute scale factors used in preview loop (we used video -> canvas cover scaling)
    const vw = videoEl.videoWidth || 1080, vh = videoEl.videoHeight || 1920;
    const scale = Math.max(cw / vw, ch / vh);
    const drawW = vw * scale, drawH = vh * scale;
    const dx = (cw - drawW) / 2, dy = (ch - drawH) / 2;
    const s = drawW / TEMPLATE_W;

    // Compute crop on canvas
    let cropX = Math.round(dx + BOOM_AREA.x * s);
    let cropY = Math.round(dy + BOOM_AREA.y * s);
    let cropW = Math.round(BOOM_AREA.w * s);
    let cropH = Math.round(BOOM_AREA.h * s);

    // Clamp to canvas bounds (fallback if values out of range)
    cropX = Math.max(0, Math.min(cropX, cw-1));
    cropY = Math.max(0, Math.min(cropY, ch-1));
    if (cropW <= 0 || cropH <= 0 || cropX+cropW > cw || cropY+cropH > ch) {
      // fallback to a centered vertical crop
      const fallbackW = Math.floor(cw * 0.6);
      const fallbackH = Math.floor(fallbackW * (BOOM_AREA.h / BOOM_AREA.w));
      cropW = fallbackW; cropH = fallbackH;
      cropX = Math.round((cw - cropW)/2);
      cropY = Math.round((ch - cropH)/2);
      log('Crop fallback used for boomerang.');
    }

    // Prepare offscreen canvas that will be recorded (target size)
    const outW = BOOM_TARGET_W, outH = BOOM_TARGET_H;
    const off = document.createElement('canvas'); off.width = outW; off.height = outH;
    const offCtx = off.getContext('2d');

    const streamRec = off.captureStream(30);
    const recorded = [];
    let mime = 'video/webm;codecs=vp8';
    let recorder;
    try { recorder = new MediaRecorder(streamRec, { mimeType: mime }); }
    catch(e){ recorder = new MediaRecorder(streamRec); }
    recorder.ondataavailable = e => { if (e.data && e.data.size) recorded.push(e.data); };
    recorder.start();

    const start = performance.now();
    await new Promise(resolve => {
      function frame(){
        // draw cropped region from main canvas into off canvas scaled to outW/outH
        try {
          const mainCtx = canvasEl.getContext('2d');
          // main canvas currently contains mirrored video frame
          offCtx.clearRect(0,0,outW,outH);
          offCtx.drawImage(canvasEl, cropX, cropY, cropW, cropH, 0, 0, outW, outH);
        } catch(e){}
        if (performance.now() - start < msDuration) {
          requestAnimationFrame(frame);
        } else {
          setTimeout(()=>{ recorder.stop(); resolve(); }, 60);
        }
      }
      frame();
    });
    await new Promise(res => recorder.onstop = res);
    const blob = new Blob(recorded, { type: 'video/webm' });
    return blob;
  }

  // generate boomerang final (forward+reverse looping) from a short clip
  async function generateBoomerangFromShortClip(shortBlob, opts = { loopMs:15000, targetW:1080, targetH:1857 }){
    const loopMs = opts.loopMs || 15000;
    const targetW = opts.targetW || BOOM_TARGET_W;
    const targetH = opts.targetH || BOOM_TARGET_H;

    const v = document.createElement('video'); v.src = URL.createObjectURL(shortBlob); v.muted = true; v.playsInline = true;
    await new Promise((res, rej) => { v.onloadedmetadata = res; v.onerror = rej; });

    const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    const template = new Image(); template.crossOrigin='anonymous'; template.src = 'bomerang.png';
    await new Promise(res => { template.onload = res; template.onerror = res; });

    const scaleFactor = targetW / TEMPLATE_W;
    const area = { x: Math.round(BOOM_AREA.x * scaleFactor), y: Math.round(BOOM_AREA.y * scaleFactor), w: Math.round(BOOM_AREA.w * scaleFactor), h: Math.round(BOOM_AREA.h * scaleFactor) };

    const stream = canvas.captureStream(30);
    const chunks = [];
    let rec;
    try { rec = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' }); }
    catch(e){ rec = new MediaRecorder(stream); }
    rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    rec.start();

    const t0 = performance.now();

    function drawFrame(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (template && template.complete && template.naturalWidth) {
        ctx.drawImage(template, 0,0, TEMPLATE_W, TEMPLATE_H, 0,0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      }
      try { ctx.drawImage(v, 0,0, v.videoWidth, v.videoHeight, area.x, area.y, area.w, area.h); } catch(e){}
    }

    async function playForward(){
      return new Promise(res => {
        v.currentTime = 0; v.play().catch(()=>{});
        const onTime = () => {
          drawFrame();
          if (v.ended || v.currentTime >= v.duration - 0.001) {
            v.pause(); v.removeEventListener('timeupdate', onTime); res();
          }
        };
        v.addEventListener('timeupdate', onTime);
        drawFrame();
      });
    }
    async function playReverse(){
      return new Promise(res => {
        v.pause(); v.currentTime = v.duration;
        function step(){
          const stepSec = 1/30;
          v.currentTime = Math.max(0, v.currentTime - stepSec);
          drawFrame();
          if (v.currentTime > 0.02) requestAnimationFrame(step); else res();
        }
        step();
      });
    }

    while (performance.now() - t0 < loopMs) {
      await playForward();
      if (performance.now() - t0 >= loopMs) break;
      await playReverse();
    }

    await sleep(120);
    await new Promise(res => { rec.onstop = res; rec.stop(); });

    return new Blob(chunks, { type: 'video/webm' });
  }

  // blob->dataURL (first frame optional)
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((resolve,reject)=>{
      if (!firstFrame) {
        const r = new FileReader();
        r.onload = ()=> resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(blob);
      } else {
        const v = document.createElement('video'); v.muted=true; v.playsInline=true; v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try { v.currentTime = 0.05; } catch(e){}
          await sleep(80);
          const c = document.createElement('canvas'); c.width = v.videoWidth || 640; c.height = v.videoHeight || 480;
          const ctx = c.getContext('2d');
          try { ctx.drawImage(v, 0,0,c.width,c.height); resolve(c.toDataURL('image/jpeg',0.85)); } catch(e){ reject(e); }
        };
        v.onerror = (e)=> reject(e);
      }
    });
  }

  // small utilities
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function log(msg){ const t=new Date().toLocaleTimeString(); debugEl.textContent = `[${t}] ${msg}\n` + debugEl.textContent; console.log(msg); }
  function msg(text){ msgEl.textContent = text; setTimeout(()=>{ if (msgEl.textContent===text) msgEl.textContent = ''; }, 3500); }
  function playAudio(id){ try{ const a=document.getElementById(id); if(a){ a.currentTime=0; a.play().catch(()=>{}); } }catch(e){ } }

  async function runCountdown(seconds=5){
    countdownEl.style.display = 'block';
    for(let t=seconds; t>0; t--){
      if (t <= 2) { countdownEl.textContent = 'SORRIA!'; countdownEl.style.color = '#ffd600'; if (t===2) { try{ document.getElementById('beep').play().catch(()=>{}); }catch(e){} } }
      else { countdownEl.textContent = String(t); countdownEl.style.color = '#fff'; }
      await sleep(1000);
    }
    countdownEl.style.display = 'none';
  }

  // handle incoming operator stream_frame if operator provides a sample (optional)
  socket.on('stream_frame', ({ session: s, frame }) => {
    // if we receive a frame from operator, draw it in preview so user can see operator background (not needed for captures)
    // frame expected to be dataURL ‚Äî but we don't depend on it for captures
    if (!frame) return;
    // For debug only: draw frame into canvas once
    try {
      const img = new Image();
      img.onload = ()=> {
        const ctx = canvasEl.getContext('2d');
        ctx.clearRect(0,0,canvasEl.clientWidth,canvasEl.clientHeight);
        ctx.drawImage(img, 0,0, canvasEl.clientWidth, canvasEl.clientHeight);
      };
      img.src = frame;
    } catch(e){}
  });

  // Expose for debug
  window._cabine = { socket, startPreviewLoop, stopPreviewLoop, ensureFrontCameraStream, stopAndReleaseCamera };

  log('Cliente celular pronto.');

})();
</script>
</body>
</html>
