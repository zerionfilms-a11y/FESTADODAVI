<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular (Fotos + Boomerang)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:20px}
    button{cursor:pointer;border:0;border-radius:12px;padding:14px 20px;font-weight:700}
    #enterFsBtn{background:#ffd600;color:#000;font-size:18px}
    #startBtn{background:#fff;color:#0b84ff;font-size:18px}
    .mode-btn{width:120px;height:120px;border-radius:14px;border:0;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:800;cursor:pointer}
    .mode-btn.boom{background:linear-gradient(135deg,#5bd,#07a);color:#fff}
    .mode-btn.three{background:linear-gradient(135deg,#f4b400,#d18a00);color:#fff}
    .mode-row{display:flex;gap:18px;align-items:center;justify-content:center;margin-top:18px}
    .logo{max-width:160px;margin-bottom:10px;border-radius:8px}
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:0;transform:scaleX(-1)}
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:5}
    #countdown{position:fixed;top:20%;left:0;right:0;text-align:center;font-size:120px;font-weight:800;z-index:80;color:#fff;text-shadow:0 0 30px #000;pointer-events:none}
    #progress{position:fixed;top:8px;left:8px;padding:8px 10px;background:rgba(0,0,0,0.5);border-radius:8px;z-index:200}
    #previewArea{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:120;pointer-events:auto;background:rgba(0,0,0,0.8)}
    #previewBox{width:90%;max-width:420px;background:rgba(255,255,255,0.06);padding:12px;border-radius:12px;text-align:center}
    #previewMedia{width:100%;height:auto;border-radius:8px;background:#111;display:block}
    .preview-buttons{display:flex;gap:12px;justify-content:center;margin-top:12px}
    .preview-btn{flex:1;padding:12px;border-radius:10px;border:0;font-weight:700}
    .preview-refazer{background:#dc3545}
    .preview-continuar{background:#28a745}
    #thankScreen .card{background:rgba(255,255,255,0.08);padding:20px;border-radius:12px}
    #debugInfo{position:fixed;bottom:8px;left:8px;font-size:12px;color:#ddd;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;z-index:300}
    .hidden{display:none!important}
    .small{font-size:14px}
    @media (max-width:480px){
      #countdown{font-size:64px}
      .mode-btn{width:86px;height:86px;font-size:18px}
    }
  </style>
</head>
<body>
  <!-- 1) Tela inicial: sÃ³ entrar em tela cheia -->
  <div id="enterFs" class="screen">
    <div style="text-align:center;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#fff;margin-bottom:8px">ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <p class="small" style="color:#ccc;margin-bottom:12px">Para iniciar, entre em tela cheia</p>
      <button id="enterFsBtn">ðŸŽ¬ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- 2) Bem-vindo (aparece depois de fullscreen) -->
  <div id="welcomeScreen" class="screen hidden">
    <div style="text-align:center;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#fff;margin-bottom:8px">ðŸ“¸ Pronto?</h1>
      <p class="small" style="color:#ddd;margin-bottom:10px">Toque em Iniciar SessÃ£o</p>
      <button id="startBtn">ðŸŽ¬ Iniciar SessÃ£o</button>
    </div>
  </div>

  <!-- 3) Tela de escolha (aparece apenas apÃ³s Iniciar SessÃ£o) -->
  <div id="chooseScreen" class="screen hidden">
    <div style="text-align:center;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="margin-bottom:6px">Escolha o modo</h2>
      <div class="mode-row">
        <button id="btnBoom" class="mode-btn boom">Boomerang</button>
        <button id="btnThree" class="mode-btn three">Fotos 3x</button>
      </div>
    </div>
  </div>

  <!-- Video preview (always present but hidden) -->
  <video id="videoEl" autoplay playsinline muted></video>
  <!-- Canvas used for captures / boomerang processing (hidden) -->
  <canvas id="canvasEl" class="hidden"></canvas>

  <div id="progress" class="hidden">Preparando...</div>
  <div id="countdown" class="hidden"></div>

  <!-- Preview modal for both photos and boomerang -->
  <div id="previewArea" class="hidden" aria-hidden="true">
    <div id="previewBox">
      <!-- for photos use <img>, for boomerang use <video> -->
      <div id="previewMediaWrap">
        <img id="previewImg" class="hidden" src="" alt="preview" />
        <video id="previewVideo" class="hidden" controls loop playsinline></video>
      </div>
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn preview-refazer">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn preview-continuar">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <div id="thankScreen" class="screen hidden">
    <div class="card" id="thankCard" style="text-align:center;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2>âœ¨ Obrigado!</h2>
      <p class="small">Espere o operador. VocÃª pode fechar esta janela quando terminar.</p>
    </div>
  </div>

  <div id="debugInfo"></div>

<script>
/* === celular.html completo ===
   Fluxo:
   - enterFs -> welcome -> choose -> (boom | three) -> capture -> preview -> enviar -> thank
   ComunicaÃ§Ã£o via socket.io com https://festadodavi.onrender.com
*/

(function(){
  const SERVER_URL = "festadodavi-production-0591.up.railway.app"; // backend conforme preferÃªncia
  const socket = io(SERVER_URL, { transports:['websocket','polling'], reconnection:true, path:'/socket.io' });

  // DOM
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const chooseScreen = document.getElementById('chooseScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');

  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const progressEl = document.getElementById('progress');
  const countdownEl = document.getElementById('countdown');

  const previewArea = document.getElementById('previewArea');
  const previewImg = document.getElementById('previewImg');
  const previewVideo = document.getElementById('previewVideo');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');

  const thankScreen = document.getElementById('thankScreen');
  const debugInfo = document.getElementById('debugInfo');

  // state
  let session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
  let mode = null; // 'boom' or 'three'
  let stream = null; // MediaStream (front camera)
  let photos = []; // captured dataURLs for three-photo flow
  let currentPhotoData = null;
  let boomerangBlob = null;
  let isCapturing = false;
  const BOOM_SHORT_MS = 2000; // 2s short clip
  const BOOM_FINAL_MS = 15000; // ~15s final
  // BOOM_AREA defines cropping rectangle in relative terms (fractions) to force vertical area inside horizontal phone
  // We'll use normalized coords (x,y,w,h) relative to video resolution (0..1)
  // You can adjust these so captured area maps correctly to your template.
  const BOOM_AREA = { x: 0.15, y: 0.05, w: 0.7, h: 0.9 }; // center vertical crop (tweak if needed)
  // Target output size for boomerang (vertical)
  const BOOM_TARGET_W = 720;
  const BOOM_TARGET_H = Math.round(BOOM_TARGET_W * (BOOM_AREA.h / BOOM_AREA.w));

  // debug helper
  function log(s){
    const t = new Date().toLocaleTimeString();
    debugInfo.textContent = `[${t}] ${s}\n` + debugInfo.textContent;
    console.log(s);
  }

  // UI helpers
  function showScreen(elRef){
    [enterFs, welcomeScreen, chooseScreen, thankScreen].forEach(s => {
      if(!s) return;
      s.classList.add('hidden');
      s.style.display = 'none';
    });
    // hide video/canvas by default unless requested
    // preview area handled separately
    if(elRef){
      elRef.classList.remove('hidden');
      elRef.style.display = 'flex';
    }
  }
  function showProgress(txt){ progressEl.textContent = txt; progressEl.classList.remove('hidden'); }
  function hideProgress(){ progressEl.classList.add('hidden'); }
  function showCountdown(txt){ countdownEl.textContent = txt; countdownEl.classList.remove('hidden'); }
  function hideCountdown(){ countdownEl.textContent = ''; countdownEl.classList.add('hidden'); }

  // show preview modal
  function showPreviewPhoto(dataUrl){
    previewVideo.classList.add('hidden'); previewVideo.pause(); previewVideo.src = '';
    previewImg.src = dataUrl; previewImg.classList.remove('hidden');
    previewArea.classList.remove('hidden'); previewArea.setAttribute('aria-hidden','false');
  }
  function showPreviewBoom(blob){
    const url = URL.createObjectURL(blob);
    previewImg.classList.add('hidden');
    previewVideo.src = url;
    previewVideo.classList.remove('hidden');
    previewVideo.loop = true;
    previewVideo.play().catch(()=>{});
    previewArea.classList.remove('hidden'); previewArea.setAttribute('aria-hidden','false');
  }
  function hidePreview(){
    previewArea.classList.add('hidden'); previewArea.setAttribute('aria-hidden','true');
    previewImg.src = ''; previewImg.classList.add('hidden');
    previewVideo.pause(); previewVideo.src = ''; previewVideo.classList.add('hidden');
  }

  // camera helpers (front camera only)
  async function ensureFrontCamera(){
    if(stream) return stream;
    try {
      // Use facingMode:'user' to prefer front camera on mobiles
      const constraints = { video: { facingMode: { ideal: "user" }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream;
      videoEl.style.display = 'block';
      videoEl.play().catch(()=>{});
      log('CÃ¢mera frontal ativada');
      return stream;
    } catch(e) {
      log('Erro acessando cÃ¢mera frontal: ' + (e.message || e));
      alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera. Verifique permissÃµes.');
      throw e;
    }
  }
  function stopFrontCamera(){
    if(stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
      videoEl.srcObject = null;
      videoEl.style.display = 'none';
      log('CÃ¢mera parada');
    }
  }

  // capture a single photo from the live video and return dataURL (mirrored corrected)
  function capturePhotoFromVideo(){
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    canvasEl.width = vw;
    canvasEl.height = vh;
    const ctx = canvasEl.getContext('2d');
    // unmirror the final image so operator sees non-mirrored
    ctx.save();
    ctx.translate(canvasEl.width, 0);
    ctx.scale(-1, 1); // flip horizontally (video is mirrored)
    ctx.drawImage(videoEl, 0, 0, canvasEl.width, canvasEl.height);
    ctx.restore();
    return canvasEl.toDataURL('image/jpeg', 0.92);
  }

  // === THREE-PHOTO FLOW ===
  async function startThreePhotoFlow(){
    mode = 'three';
    photos = [];
    currentPhotoData = null;
    await ensureFrontCamera();
    showProgress('Preparando para 3 fotos...');
    await sleep(250);
    hideProgress();
    // start first capture
    await captureNextPhoto();
  }

  // capture next photo with countdown and preview
  async function captureNextPhoto(){
    if(isCapturing) return;
    isCapturing = true;
    try {
      const index = photos.length;
      showProgress(`${index+1}/3`);
      videoEl.style.display = 'block';
      // countdown 5..1
      for(let t=5; t>0; t--){
        if(t <= 2){
          showCountdown('SORRIA!');
        } else {
          showCountdown(String(t));
        }
        // play sound if available? skip in this version
        await sleep(1000);
      }
      hideCountdown();
      // capture
      const data = capturePhotoFromVideo();
      currentPhotoData = data;
      // show preview
      showPreviewPhoto(data);
      hideProgress();
    } finally {
      isCapturing = false;
    }
  }

  // continue or refazer handlers for photo flow
  refazerBtn.addEventListener('click', async () => {
    hidePreview();
    await sleep(160); // short gap
    await captureNextPhoto();
  });

  continuarBtn.addEventListener('click', async () => {
    // push current photo and continue / finish
    if(!currentPhotoData) { log('Nenhuma foto no preview para continuar'); return; }
    photos.push(currentPhotoData);
    currentPhotoData = null;
    hidePreview();
    // if not yet 3, continue; else finalize
    if(photos.length < 3){
      await sleep(160);
      await captureNextPhoto();
    } else {
      // finished 3 photos â€” send to server
      showProgress('Enviando fotos ao servidor...');
      await ensureSocketConnected();
      // emit event expected by index: 'photos_from_cell' with array of dataURLs
      emitWithRetry('photos_from_cell', { session, photos }, 3);
      hideProgress();
      // thank you
      stopFrontCamera();
      showScreen(thankScreen);
    }
  });

  // === BOOMERANG FLOW ===
  // record short clip (2s) and return Blob of recorded crop (WebM)
  async function recordShortCroppedClip(ms = BOOM_SHORT_MS){
    await ensureFrontCamera();
    // ensure video metadata available
    if(!videoEl.videoWidth || !videoEl.videoHeight){
      await new Promise(r => setTimeout(r,200));
    }
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    // compute crop in pixels using BOOM_AREA (normalized)
    const cropX = Math.round(BOOM_AREA.x * vw);
    const cropY = Math.round(BOOM_AREA.y * vh);
    const cropW = Math.round(BOOM_AREA.w * vw);
    const cropH = Math.round(BOOM_AREA.h * vh);

    // offscreen canvas to draw crop frames scaled to target
    const outW = BOOM_TARGET_W;
    const outH = BOOM_TARGET_H;
    const off = document.createElement('canvas');
    off.width = outW; off.height = outH;
    const ctx = off.getContext('2d');

    // capture stream from canvas and MediaRecorder to record short clip
    const captureStream = off.captureStream(30);
    let chunks = [];
    let recorder;
    try {
      recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });
    } catch(e){
      // fallback with default
      recorder = new MediaRecorder(captureStream);
    }
    recorder.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };

    recorder.start();

    const start = performance.now();
    // draw frames for duration ms
    await new Promise((resolve) => {
      function drawFrame(){
        try {
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,outW,outH);
          // draw video current frame cropped -> scaled
          ctx.save();
          // note: videoEl is mirrored (scaleX(-1)), drawing it normally will give mirrored; to keep consistent, draw mirrored
          ctx.translate(outW, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(videoEl, cropX, cropY, cropW, cropH, 0, 0, outW, outH);
          ctx.restore();
        } catch(e){}
        if(performance.now() - start < ms){
          requestAnimationFrame(drawFrame);
        } else {
          // stop a bit later to flush frames
          setTimeout(()=>{ recorder.stop(); resolve(); }, 80);
        }
      }
      drawFrame();
    });
    // wait for stop
    await new Promise(res => { recorder.onstop = res; });
    const blob = new Blob(chunks, { type: 'video/webm' });
    log('Short clip gravado: ' + blob.size + ' bytes');
    return blob;
  }

  // generate final boomerang: play forward+reverse repeatedly drawing onto canvas and record it
  async function generateBoomerang(shortBlob, options = { loopMs: BOOM_FINAL_MS, targetW: BOOM_TARGET_W, targetH: BOOM_TARGET_H }){
    const loopMs = options.loopMs || BOOM_FINAL_MS;
    const targetW = options.targetW || BOOM_TARGET_W;
    const targetH = options.targetH || BOOM_TARGET_H;

    // load short clip into video element
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(shortBlob);
    await new Promise((res, rej) => {
      v.onloadedmetadata = () => res();
      v.onerror = () => rej(new Error('Erro ao carregar short clip'));
    });

    // prepare canvas to draw (targetW x targetH)
    const canvas = document.createElement('canvas');
    canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // optional overlay template if available
    const template = new Image();
    template.src = 'bomerang.png';
    template.crossOrigin = 'anonymous';
    // don't block if template missing
    template.onerror = () => {};
    // try to load but not strictly required
    try { await new Promise(r => { template.onload = r; template.onerror = r; }); } catch(e){}

    const stream = canvas.captureStream(30);
    let recChunks = [];
    let recorder;
    try {
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
    } catch(e){
      recorder = new MediaRecorder(stream);
    }
    recorder.ondataavailable = (ev) => { if(ev.data && ev.data.size) recChunks.push(ev.data); };
    recorder.start();

    const startTime = performance.now();

    function drawFrameFromVideo(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // draw template if present scaled to canvas
      if(template && template.complete && template.naturalWidth){
        ctx.drawImage(template, 0, 0, template.width, template.height, 0, 0, canvas.width, canvas.height);
      } else {
        // fallback
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      }
      try {
        ctx.drawImage(v, 0, 0, v.videoWidth, v.videoHeight, 0, 0, canvas.width, canvas.height);
      } catch(e){}
    }

    // helper to play forward once
    async function playForward(){
      return new Promise(res => {
        v.currentTime = 0;
        v.play().catch(()=>{});
        const onTime = () => {
          drawFrameFromVideo();
          if(v.ended || v.currentTime >= v.duration - 0.001){
            v.pause();
            v.removeEventListener('timeupdate', onTime);
            res();
          }
        };
        v.addEventListener('timeupdate', onTime);
        // draw initial
        drawFrameFromVideo();
      });
    }

    // helper to play reverse by stepping back frames
    async function playReverse(){
      return new Promise(res => {
        v.pause();
        v.currentTime = v.duration;
        function step(){
          const stepMs = 1000/30;
          v.currentTime = Math.max(0, v.currentTime - (stepMs/1000));
          drawFrameFromVideo();
          if(v.currentTime > 0.02){
            requestAnimationFrame(step);
          } else {
            res();
          }
        }
        step();
      });
    }

    // loop forward+reverse until loopMs elapsed
    while(performance.now() - startTime < loopMs){
      await playForward();
      if(performance.now() - startTime >= loopMs) break;
      await playReverse();
    }

    // stop recorder and return final blob
    await sleep(120);
    await new Promise(res => { recorder.onstop = res; recorder.stop(); });
    const final = new Blob(recChunks, { type: 'video/webm' });
    log('Boomerang final gerado: ' + final.size + ' bytes');
    return final;
  }

  // public start for boomerang flow
  async function startBoomerangFlow(){
    mode = 'boom';
    photos = []; currentPhotoData = null; boomerangBlob = null;
    await ensureFrontCamera();
    showProgress('Preparando Boomerang...');
    await sleep(250);
    hideProgress();
    // countdown then record short 2s clip
    showCountdown('3');
    await sleep(400);
    showCountdown('2');
    await sleep(400);
    showCountdown('1');
    await sleep(400);
    hideCountdown();
    showProgress('Gravando (2s)...');
    // visual indicator: overlay red dot / recording text could be added - we'll use progress text
    const short = await recordShortCroppedClip(BOOM_SHORT_MS);
    hideProgress();
    // generate boomerang final
    showProgress('Processando Boomerang...');
    const finalBlob = await generateBoomerang(short, { loopMs: BOOM_FINAL_MS });
    boomerangBlob = finalBlob;
    hideProgress();
    // show preview (looping)
    showPreviewBoom(finalBlob);
  }

  // preview controls for boomerang
  refazerBtn.addEventListener('click', async () => {
    hidePreview();
    // free previous blob URL
    if(boomerangBlob){ try{ URL.revokeObjectURL(previewVideo.src); } catch(e){} }
    boomerangBlob = null;
    await sleep(160);
    await startBoomerangFlow();
  });

  continuarBtn.addEventListener('click', async () => {
    hidePreview();
    if(mode === 'boom'){
      if(!boomerangBlob){ log('Nenhum boomerang para enviar'); return; }
      showProgress('Enviando boomerang...');
      await ensureSocketConnected();
      // send blob via socket as ArrayBuffer to avoid base64 blowup
      try {
        const ab = await boomerangBlob.arrayBuffer();
        socket.emit('boomerang_ready', { session, filename: `boomerang_${Date.now()}.webm`, data: ab });
        // also send thumbnail to help visualizador show quick preview
        const thumb = await extractFirstFrameAsDataUrl(boomerangBlob);
        if(thumb) socket.emit('photo_ready', { session, index: 0, photo: thumb });
        log('boomerang_ready emitido');
      } catch(e){
        log('Erro ao enviar boomerang via socket: ' + e);
        try {
          // fallback: open blob in new tab for manual download
          const url = URL.createObjectURL(boomerangBlob);
          window.open(url, '_blank');
        } catch(e2){}
      }
      hideProgress();
      stopFrontCamera();
      showScreen(thankScreen);
    } else if(mode === 'three') {
      // handled above in continuar flow for photos
    }
  });

  // utility: extract first frame from video blob to dataURL
  async function extractFirstFrameAsDataUrl(blob){
    return new Promise((res, rej) => {
      try {
        const v = document.createElement('video');
        v.muted = true; v.playsInline = true;
        v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try{
            v.currentTime = 0.05;
            await sleep(80);
            const c = document.createElement('canvas');
            c.width = v.videoWidth || 640; c.height = v.videoHeight || 480;
            const ctx = c.getContext('2d');
            ctx.drawImage(v, 0, 0, c.width, c.height);
            const data = c.toDataURL('image/jpeg', 0.8);
            res(data);
          } catch(e){ rej(e); }
        };
        v.onerror = (e) => rej(e);
      } catch(e){ rej(e); }
    });
  }

  // === SOCKET / SERVER CONNECTIVITY ===
  let socketConnected = false;
  socket.on('connect', () => {
    socketConnected = true;
    log('Socket conectado: ' + socket.id + ' (session: ' + session + ')');
    // notify server this cell joined
    socket.emit('cell_connected', { session });
    // optional: request operator stream? not for our mobile flow
  });
  socket.on('disconnect', () => { socketConnected = false; log('Socket desconectado'); });
  socket.on('connect_error', (err) => { log('Socket connect_error: ' + (err && err.message)); });

  // listen for server requests to capture from cellphone if ever needed
  socket.on('request_capture', async ({ index }) => {
    log('request_capture recebido: index=' + index);
    try {
      await ensureFrontCamera();
      const photo = capturePhotoFromVideo();
      socket.emit('photo_ready', { session, index, photo });
      log('photo_ready emitido (respondendo request_capture)');
    } catch(e){ log('Erro responder request_capture: ' + e); }
  });

  // helper: ensure socket connected before emitting
  async function ensureSocketConnected(timeoutMs = 5000){
    if(socketConnected) return;
    // try to connect and wait a little
    socket.connect();
    const start = performance.now();
    while(!socketConnected && performance.now() - start < timeoutMs){
      await sleep(150);
    }
    if(!socketConnected) throw new Error('Socket nÃ£o conectado');
  }

  // emit with retry small helper
  function emitWithRetry(event, payload, attempts = 3, delay = 1200){
    let at = 0;
    (function tryEmit(){
      at++;
      try {
        socket.emit(event, payload);
        log(`emit '${event}' tent ${at} OK`);
      } catch(e){
        log(`emit '${event}' falhou: ${e}. tentativa ${at}`);
        if(at < attempts) setTimeout(tryEmit, delay);
      }
    })();
  }

  // === FLOW UI wiring ===
  // 1) Enter fullscreen button must enter fullscreen and immediately go to welcome screen
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen(); } catch(e) { /* ignore */ }
    // show welcome & inform server that cell entered fullscreen (server may show QR scanned)
    showScreen(welcomeScreen);
    try {
      socket.emit('cell_entered_fullscreen', { session });
    } catch(e){}
  });

  // 2) Iniciar sessÃ£o: goes directly to choose screen (logo + start), the choice buttons appear there
  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    startBtn.textContent = 'ðŸŽµ Preparando...';
    try { await sleep(350); } catch(e){}
    startBtn.disabled = false;
    startBtn.textContent = 'ðŸŽ¬ Iniciar SessÃ£o';
    // navigate to choose screen
    showScreen(null); // hide fullscreens
    await sleep(120);
    chooseScreen.classList.remove('hidden'); chooseScreen.style.display = 'flex';
    // ensure camera ready in background for faster capture
    ensureFrontCamera().catch(e=>{});
  });

  // 3) Choice buttons
  btnThree.addEventListener('click', async () => {
    // Only show camera + start three-photo flow
    chooseScreen.classList.add('hidden');
    chooseScreen.style.display = 'none';
    showProgress('Abrindo cÃ¢mera para fotos...');
    try {
      await startThreePhotoFlow();
    } catch(e){ log('Erro three flow: ' + e); }
    hideProgress();
  });

  btnBoom.addEventListener('click', async () => {
    chooseScreen.classList.add('hidden');
    chooseScreen.style.display = 'none';
    showProgress('Abrindo cÃ¢mera para Boomerang...');
    await sleep(120);
    try {
      await startBoomerangFlow();
    } catch(e){ log('Erro boomerang: ' + e); alert('Erro ao gravar boomerang: ' + (e.message || e)); }
    hideProgress();
  });

  // helper sleep
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // ===== Extra: allow manual back-to-choose if operator resets session or user wants =====
  // If operator sends 'reset_session' server instructs to go back to welcome
  socket.on('reset_session', ({ session: s }) => {
    if(s && s !== session) return;
    // stop anything, clear state, show welcome
    hidePreview();
    stopFrontCamera();
    photos = []; currentPhotoData = null; boomerangBlob = null;
    showScreen(welcomeScreen);
    log('reset_session recebido â€” retornando ao welcome');
  });

  // also handle server ask to show QR code (the visualizador) â€” server will emit 'show_qr' with url
  socket.on('show_qr', ({ visualizadorUrl }) => {
    if(!visualizadorUrl) return;
    // open visualizador in new tab or show native prompt
    log('show_qr recebido: ' + visualizadorUrl);
    try {
      // try to open new window (most devices will allow)
      window.open(visualizadorUrl, '_blank');
    } catch(e){}
    // Optionally create overlay QR on this page (left as improvement)
  });

  // ===== utility: when user completes 3 photos, ensure server receives them (emitted; index will handle montage) =====
  // Already handled in continuarBtn click handling for "three" flow (it emits 'photos_from_cell')

  // ===== Ensures UX consistency: if preview not closed user may press back etc =====
  // close preview on outside click? not needed; explicit buttons provided.

  // Final: show initial screen (enter fullscreen)
  showScreen(enterFs);

  // Expose debug helpers on window for console
  window._celular = {
    startThreePhotoFlow, startBoomerangFlow, capturePhotoFromVideo,
    stopFrontCamera, getState: () => ({ session, mode, photos, boomerangBlob })
  };

})();
</script>
</body>
</html>
