<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    button{cursor:pointer}
    .hidden{display:none!important}
    .visible{display:flex!important}

    /* ENTER FULLSCREEN */
    #enterFs{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#001e3c,#0b84ff);padding:18px;z-index:1000}
    #enterPanel{width:95%;max-width:420px;background:rgba(0,0,0,0.32);padding:20px;border-radius:12px;text-align:center;backdrop-filter:blur(8px)}
    #enterPanel .logo{max-width:140px;margin:0 auto 12px;display:block}
    #enterPanel h1{color:#fff;margin-bottom:8px}
    #enterPanel p{color:#dfefff;margin-bottom:14px}
    #enterFsBtn{padding:12px 16px;border-radius:10px;border:none;background:#ffd600;color:#000;font-weight:700;font-size:18px;width:100%}

    /* WELCOME SCREEN (with a real IMG as background) */
    #welcomeScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#111;padding:0;overflow:hidden}
    #welcomeBg{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;display:block;z-index:1}
    /* Start button absolute on top of image using your coords mapping (4000x2250) */
    #startBtn {
      position:absolute;
      left:43.15%;
      top:76.49%;
      width:49.9875%;
      height:18.4%;
      border-radius:12px; border:2px solid rgba(255,255,255,0.06);
      background: rgba(0,0,0,0.18);
      display:flex;align-items:center;justify-content:center;
      color:#fff;font-weight:800;font-size:22px;letter-spacing:0.6px;
      text-transform:uppercase;
      z-index:50;
    }
    #startBtn .label{ pointer-events:none }

    /* Video & canvas */
    #videoWrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:5;overflow:hidden}
    /* NOTE: no mirror transform here (scaleX(1)) ‚Äî c√¢mera N√ÉO est√° espelhada */
    #videoEl{width:100%;height:100%;object-fit:cover;display:block;transform:scaleX(1)}
    #canvasEl{display:none;position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:6}

    #progress{position:fixed;left:50%;transform:translateX(-50%);top:18px;padding:8px 12px;border-radius:10px;background:rgba(0,0,0,0.55);font-weight:700;z-index:200}
    #countdown{position:fixed;left:50%;transform:translateX(-50%);top:28%;font-size:120px;font-weight:900;text-shadow:0 0 20px #000;color:#fff;z-index:201}
    #msg{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;padding:8px 12px;border-radius:10px;background:rgba(0,0,0,0.55);z-index:200}

    /* Preview overlay */
    #previewScreen{position:fixed;inset:0;z-index:300;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.9)}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    #previewImage{max-width:100%;max-height:100%;object-fit:contain}
    .preview-buttons{position:absolute;bottom:36px;left:0;right:0;display:flex;gap:12px;justify-content:center;padding:0 20px}
    .preview-btn{padding:12px 18px;border-radius:10px;border:none;font-weight:700;cursor:pointer;font-size:16px;background:rgba(255,255,255,0.06);color:#fff}
    .btn-danger{background:rgba(220,53,69,0.9)}
    .btn-ok{background:rgba(40,167,69,0.9)}

    /* VISUALIZER overlay (QR centered) */
    #visualizerOverlay{position:fixed;inset:0;z-index:10000;background:rgba(0,0,0,0.96);display:none;flex-direction:column;align-items:center;justify-content:center;padding:18px}
    /* center contents; optionally show iframe or QR */
    #vizContainer{width:100%;max-width:920px;height:70vh;background:#111;border-radius:12px;display:flex;align-items:center;justify-content:center;position:relative;padding:18px;flex-direction:column}
    #vizIframe{width:100%;height:100%;border:0;border-radius:8px;background:#000;display:none}
    /* QR centered and larger */
    #vizQR{width:320px;height:320px;background:#fff;padding:8px;border-radius:12px;display:flex;align-items:center;justify-content:center;cursor:pointer}
    #vizQrCanvas{width:100%;height:100%;display:block}
    #vizNotice{margin-top:14px;color:#ddd;font-size:16px;text-align:center;display:none}
    #vizLockNote{display:none}

    /* thank screen */
    #thankScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#001e3c,#0b84ff);z-index:100}
    #thankBox{background:rgba(255,255,255,0.08);padding:18px;border-radius:12px;text-align:center;color:#fff}

    /* debug */
    #debugInfo{position:fixed;left:12px;bottom:12px;font-size:11px;color:#ccc;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:6px;z-index:999}

    /* SAFE AREA overlay (new) */
    #safeOverlay{position:fixed;inset:0;pointer-events:none;z-index:900;display:flex;align-items:center;justify-content:center}
    /* dim outside area */
    #safeOverlay .mask{
      position:absolute;inset:0;background:rgba(0,0,0,0.45);
      -webkit-backdrop-filter: blur(2px);backdrop-filter: blur(2px);
    }
    /* safe rect centered */
    #safeRect{
      position:relative;width:62%; /* relative to viewport width */
      aspect-ratio: 3/4; /* portrait crop (w:h = 3:4) - adjust if you want different */
      border: 3px dashed rgba(255,255,255,0.9);
      border-radius:10px;
      box-shadow:0 0 0 9999px rgba(0,0,0,0.45);
      background:transparent;
      pointer-events:none;
    }
    /* label */
    #safeLabel{position:absolute;top:-34px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);padding:6px 10px;border-radius:8px;font-weight:700}

    /* toggle button */
    #safeToggle{position:fixed;right:12px;top:12px;z-index:1001;padding:8px 10px;border-radius:8px;border:0;background:rgba(255,255,255,0.06);color:#fff;font-weight:700}

    @media (max-width:480px){
      #startBtn{font-size:18px}
      #countdown{font-size:72px; top:24%}
      #vizContainer{height:58vh}
      #vizQR{width:220px;height:220px}
      #safeRect{width:78%}
    }
  </style>
</head>
<body>
  <!-- ENTER FULLSCREEN -->
  <div id="enterFs" role="dialog" aria-label="Entrar em tela cheia">
    <div id="enterPanel">
      <img src="logo.png" class="logo" alt="Logo" onerror="this.style.display='none'">
      <h1>üì∏ Cabine Fotogr√°fica</h1>
      <p>Para melhor experi√™ncia, entre em tela cheia</p>
      <button id="enterFsBtn" type="button">üé¨ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- WELCOME SCREEN - com IMG real como fundo -->
  <div id="welcomeScreen" class="hidden" aria-hidden="true">
    <img id="welcomeBg" src="iniciar.png" alt="Fundo iniciar" onerror="onWelcomeBgError()" />
    <button id="startBtn" aria-label="Iniciar Sess√£o"><span class="label">INICIAR SESS√ÉO</span></button>
  </div>

  <!-- camera and canvas -->
  <div id="videoWrap" class="hidden" aria-hidden="true">
    <video id="videoEl" autoplay playsinline muted></video>
    <canvas id="canvasEl"></canvas>
  </div>

  <div id="progress" class="hidden" aria-hidden="true"></div>
  <div id="countdown" class="hidden" aria-hidden="true"></div>
  <div id="msg" class="hidden" aria-hidden="true"></div>

  <!-- SAFE AREA overlay -->
  <div id="safeOverlay" class="hidden" aria-hidden="true">
    <div class="mask"></div>
    <div id="safeRect">
      <div id="safeLabel">√Årea segura ‚Äî n√£o corte cabe√ßas</div>
    </div>
  </div>
  <button id="safeToggle" title="Mostrar/ocultar guia de enquadramento" style="display:none">Guia: ON</button>

  <!-- preview -->
  <div id="previewScreen" class="hidden" aria-hidden="true">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview da foto">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn btn-danger">üîÑ Refazer</button>
        <button id="continuarBtn" class="preview-btn btn-ok">‚úÖ Continuar</button>
      </div>
    </div>
  </div>

  <!-- visualizer overlay (shows iframe or QR) -->
  <div id="visualizerOverlay" aria-hidden="true">
    <div id="vizContainer">
      <iframe id="vizIframe" src="about:blank" title="Visualizador"></iframe>
      <div id="vizQR" title="Abrir visualizador">
        <canvas id="vizQrCanvas" width="300" height="300"></canvas>
      </div>
    </div>
  </div>

  <!-- thank -->
  <div id="thankScreen" class="hidden" aria-hidden="true">
    <div id="thankBox">
      <h2>‚ú® Obrigado por utilizar a cabine!</h2>
      <p>Espere o operador encerrar a sess√£o.</p>
    </div>
  </div>

  <div id="debugInfo" aria-hidden="true"></div>

  <!-- optional sounds -->
  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

  <script>
    /* ---------- Config ---------- */
    const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
    const MAX_PHOTOS = 3;
    const COUNTDOWN_SECONDS = 5;
    const MAX_SEND_WIDTH = 1280; // resize before sending to reduce upload time
    const SEND_QUALITY = 0.78; // jpeg quality for faster transfers
    const SAFE_ASPECT = 3/4; // aspect ratio of safe area (w/h)

    /* ---------- Socket ---------- */
    const socket = io(SERVER_URL, {
      transports: ["websocket","polling"],
      reconnection: true,
      path: "/socket.io"
    });

    /* ---------- DOM ---------- */
    const enterFs = document.getElementById('enterFs');
    const enterFsBtn = document.getElementById('enterFsBtn');
    const welcomeScreen = document.getElementById('welcomeScreen');
    const startBtn = document.getElementById('startBtn');
    const welcomeBg = document.getElementById('welcomeBg');

    const videoWrap = document.getElementById('videoWrap');
    const videoEl = document.getElementById('videoEl');
    const canvasEl = document.getElementById('canvasEl');
    const progressEl = document.getElementById('progress');
    const countdownEl = document.getElementById('countdown');
    const msgEl = document.getElementById('msg');

    const previewScreen = document.getElementById('previewScreen');
    const previewImage = document.getElementById('previewImage');
    const refazerBtn = document.getElementById('refazerBtn');
    const continuarBtn = document.getElementById('continuarBtn');

    const visualizerOverlay = document.getElementById('visualizerOverlay');
    const vizContainer = document.getElementById('vizContainer');
    const vizIframe = document.getElementById('vizIframe');
    const vizQrCanvas = document.getElementById('vizQrCanvas');
    const vizQR = document.getElementById('vizQR');

    const thankScreen = document.getElementById('thankScreen');
    const debugInfo = document.getElementById('debugInfo');

    const safeOverlay = document.getElementById('safeOverlay');
    const safeRect = document.getElementById('safeRect');
    const safeToggle = document.getElementById('safeToggle');

    /* ---------- State ---------- */
    const params = new URLSearchParams(location.search);
    const session = params.get('session') || 'cabine-fixa';
    let stream = null;
    let photos = [];
    let currentPhotoIndex = 0;
    let currentPhotoData = null;
    let isCapturing = false;
    let visualizerLocked = false;
    let currentVisualizerUrl = null; // stored so clicking canvas opens the link
    let safeGuideOn = true;

    /* debug */
    setInterval(() => {
      debugInfo.textContent = `Sess√£o: ${session} | Socket: ${socket.connected ? 'üü¢' : 'üî¥'} | Fotos: ${photos.length}/${MAX_PHOTOS} | Capturando: ${isCapturing ? 'SIM' : 'N√ÉO'} | VizLocked: ${visualizerLocked ? 'SIM' : 'N√ÉO'}`;
    }, 700);

    /* ---------- Helpers ---------- */
    function onWelcomeBgError(){
      console.warn('Falha ao carregar iniciar.png ‚Äî verifique o caminho/nome (case-sensitive).');
      debugInfo.textContent = 'Erro: iniciar.png n√£o encontrado. Coloque iniciar.png na mesma pasta do celular.html (verifique mai√∫sculas/min√∫sculas).';
      welcomeBg.style.display = 'none';
    }

    function showScreen(screenEl){
      [enterFs, welcomeScreen, previewScreen, thankScreen].forEach(s => s && s.classList.add('hidden'));
      progressEl.classList.add('hidden'); countdownEl.classList.add('hidden'); msgEl.classList.add('hidden');
      safeOverlay.classList.add('hidden');
      if(screenEl === welcomeScreen || screenEl === enterFs) stopCamera();
      if(screenEl === null) {
        // show camera area
        videoWrap.classList.remove('hidden');
        if (safeGuideOn) safeOverlay.classList.remove('hidden');
        safeToggle.style.display = 'block';
      } else {
        videoWrap.classList.add('hidden');
        safeToggle.style.display = 'none';
      }
      if(screenEl) screenEl.classList.remove('hidden');
    }
    function showProgress(text){ progressEl.textContent = text; progressEl.classList.remove('hidden'); }
    function hideProgress(){ progressEl.classList.add('hidden'); }
    function showCountdown(text){ countdownEl.textContent = text; countdownEl.classList.remove('hidden'); }
    function hideCountdown(){ countdownEl.classList.add('hidden'); }
    function showMsg(text){ msgEl.textContent = text; msgEl.classList.remove('hidden'); }
    function hideMsg(){ msgEl.classList.add('hidden'); }

    /* ---------- Camera ---------- */
    async function startCamera(){
      try{
        const constraints = { video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoEl.srcObject = stream;
        videoEl.style.display = 'block';
        await videoEl.play().catch(()=>{});
        await new Promise(r=>setTimeout(r,100));
        // adjust safeRect size to viewport (responsive)
        adjustSafeRect();
      }catch(err){
        console.error('startCamera', err);
        alert('N√£o foi poss√≠vel acessar a c√¢mera frontal. Verifique permiss√µes.');
        throw err;
      }
    }

    function stopCamera(){
      try{
        if(stream) { stream.getTracks().forEach(t=>t.stop()); stream = null; }
      }catch(e){}
      try{ videoEl.pause(); videoEl.srcObject = null; }catch(e){}
      videoEl.style.display = 'none';
    }

    // adjust safeRect to viewport and maintain aspect ratio
    function adjustSafeRect(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // desired width as percentage of viewport width (kept in CSS); compute real pixel size:
      const style = getComputedStyle(safeRect);
      const rectWidthPct = parseFloat(style.width) || 62; // fallback
      const rectWidthPx = Math.round((rectWidthPct/100) * vw);
      const rectHeightPx = Math.round(rectWidthPx / SAFE_ASPECT);
      // if height > viewport, scale down to fit
      let finalW = rectWidthPx, finalH = rectHeightPx;
      if (finalH > (vh * 0.92)) {
        finalH = Math.round(vh * 0.92);
        finalW = Math.round(finalH * SAFE_ASPECT);
      }
      safeRect.style.width = finalW + 'px';
      safeRect.style.height = finalH + 'px';
    }

    window.addEventListener('resize', () => {
      adjustSafeRect();
    });

    // grab and compress/rescale frame for faster transfer
    // NOTE: now crops to the safeRect region (if visible). No mirroring is applied ‚Äî sending "non-mirrored" image.
    function grabFrameDataURL(quality=SEND_QUALITY, maxWidth=MAX_SEND_WIDTH){
      const vw = videoEl.videoWidth || videoEl.clientWidth || 1280;
      const vh = videoEl.videoHeight || videoEl.clientHeight || 720;

      // compute source crop rect in video coordinate space
      let sx = 0, sy = 0, sw = vw, sh = vh;

      if (!safeOverlay.classList.contains('hidden')) {
        const safeBox = safeRect.getBoundingClientRect();
        const videoBox = videoEl.getBoundingClientRect();

        const relLeft = Math.max(0, safeBox.left - videoBox.left);
        const relTop = Math.max(0, safeBox.top - videoBox.top);
        const relW = Math.min(safeBox.width, videoBox.width);
        const relH = Math.min(safeBox.height, videoBox.height);

        const pxPerCssX = (videoEl.videoWidth || vw) / videoBox.width;
        const pxPerCssY = (videoEl.videoHeight || vh) / videoBox.height;

        sx = Math.round(relLeft * pxPerCssX);
        sy = Math.round(relTop * pxPerCssY);
        sw = Math.round(relW * pxPerCssX);
        sh = Math.round(relH * pxPerCssY);

        sx = Math.max(0, Math.min(sx, vw-1));
        sy = Math.max(0, Math.min(sy, vh-1));
        sw = Math.max(1, Math.min(sw, vw - sx));
        sh = Math.max(1, Math.min(sh, vh - sy));
      } else {
        sx = 0; sy = 0; sw = vw; sh = vh;
      }

      canvasEl.width = sw;
      canvasEl.height = sh;
      const ctx = canvasEl.getContext('2d');
      ctx.clearRect(0,0,sw,sh);
      // draw without mirroring
      ctx.drawImage(videoEl, sx, sy, sw, sh, 0, 0, sw, sh);

      if (sw > maxWidth) {
        const scale = maxWidth / sw;
        const tw = Math.round(sw * scale);
        const th = Math.round(sh * scale);
        const tmp = document.createElement('canvas');
        tmp.width = tw; tmp.height = th;
        const tctx = tmp.getContext('2d');
        tctx.drawImage(canvasEl, 0, 0, sw, sh, 0, 0, tw, th);
        return tmp.toDataURL('image/jpeg', quality);
      } else {
        return canvasEl.toDataURL('image/jpeg', quality);
      }
    }

    /* ---------- Capture flow (collect 3 photos, then send once) ---------- */
    async function captureSinglePhotoFlow(){
      isCapturing = true;
      showProgress(`${currentPhotoIndex+1}/${MAX_PHOTOS}`);
      if(!stream) await startCamera();
      videoEl.style.display = 'block';

      for(let t = COUNTDOWN_SECONDS; t > 0; t--){
        if(t <= 2){ showCountdown('üì∏'); }
        else { showCountdown(String(t)); }
        if(t === 2){
          try { document.getElementById('clack').currentTime = 0; document.getElementById('clack').play().catch(()=>{}); } catch(e){}
        }
        await new Promise(r=>setTimeout(r,1000));
      }
      hideCountdown();
      const data = grabFrameDataURL(SEND_QUALITY, MAX_SEND_WIDTH);
      isCapturing = false;
      return data;
    }

    async function runCaptureSequence(){
      try{
        await startCamera();
        photos = []; currentPhotoIndex = 0;
        while(currentPhotoIndex < MAX_PHOTOS && !visualizerLocked){
          currentPhotoData = await captureSinglePhotoFlow();
          const decision = await showPreviewAndAwaitDecision(currentPhotoData);
          if (decision === 'continuar') {
            photos.push(currentPhotoData);
            currentPhotoIndex++;
            showMsg(`Foto ${currentPhotoIndex} salva. ${currentPhotoIndex < MAX_PHOTOS ? 'Posicione-se para a pr√≥xima.' : 'Preparando para enviar...'} `);
            await new Promise(r=>setTimeout(r,600));
            hideMsg();
          } else {
            showMsg('Refa√ßa a foto...');
            await new Promise(r=>setTimeout(r,500));
            hideMsg();
          }
        }

        if (photos.length > 0) {
          showProgress('Enviando fotos ao operador...');
          showMsg('Aguardando processamento no operador ‚Äî espere o QR.');
          stopCamera();
          try {
            if (socket && socket.connected) {
              socket.timeout(15000).emit('photos_from_cell', { session, photos }, (err, ack) => {
                hideProgress();
                if (ack && ack.viewerId) {
                  showMsg('Fotos recebidas pelo servidor. Aguardando montagem do visualizador...');
                }
              });
            } else {
              const url = new URL('/upload_photos', SERVER_URL);
              fetch(url.toString(), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session, photos }),
              }).then(res => res.json()).then(json => {
                hideProgress();
                showMsg('Fotos enviadas via HTTP. Aguardando processamento...');
              }).catch(err => {
                hideProgress();
                console.warn('HTTP upload failed', err);
                alert('Falha ao enviar fotos. Verifique conex√£o.');
                showScreen(welcomeScreen);
              });
            }
          } catch(e){
            hideProgress();
            console.warn('send photos error', e);
            alert('Erro ao enviar fotos. Reinicie a sess√£o.');
            showScreen(welcomeScreen);
            return;
          }
        }

        showScreen(thankScreen);
      }catch(err){
        console.error('runCaptureSequence error', err);
        stopCamera();
        alert('Erro durante captura. Reinicie a sess√£o.');
        showScreen(welcomeScreen);
      }
    }

    function showPreviewAndAwaitDecision(photoData){
      return new Promise((resolve) => {
        previewImage.src = photoData;
        previewScreen.classList.remove('hidden');

        const onRef = () => { cleanup(); resolve('refazer'); };
        const onCont = () => { cleanup(); resolve('continuar'); };
        function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); previewScreen.classList.add('hidden'); }
        refazerBtn.addEventListener('click', onRef);
        continuarBtn.addEventListener('click', onCont);
      });
    }

    /* ---------- Visualizer lock flow (server-driven) ----------
       IMPORTANT: this client will NOT generate QR locally. It only displays what the server sends.
       If server sends a QR image URL or a visualizer URL, we display it. Otherwise we show a waiting message.
    */
    function drawQrOnCanvas(canvas, url){
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(!url){
        // do NOT generate QR here ‚Äî just show waiting message
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff'; ctx.font = '14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('Aguardando QR do operador', canvas.width/2, canvas.height/2);
        return;
      }
      // if server provided an image URL we try to load it
      const isImage = /\.(png|jpe?g|gif|svg)(\?|$)/i.test(url);
      if (!isImage) {
        // If server sent a non-image URL, show the URL text (but do not generate QR here)
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('Aguardando QR do operador', canvas.width/2, canvas.height/2);
        return;
      }
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const w = img.width * scale, h = img.height * scale;
        ctx.drawImage(img, (canvas.width - w)/2, (canvas.height - h)/2, w, h);
      };
      img.onerror = () => {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff'; ctx.font = '14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('N√£o foi poss√≠vel carregar QR', canvas.width/2, canvas.height/2);
      };
      img.src = url;
    }

    function showVisualizerOverlay({ visualizerUrl, qrUrl, showIframe }){
      visualizerLocked = true;
      stopCamera();
      visualizerOverlay.style.display = 'flex';
      visualizerOverlay.setAttribute('aria-hidden','false');
      currentVisualizerUrl = visualizerUrl || qrUrl || null;
      if(showIframe && visualizerUrl){
        vizIframe.style.display = 'block';
        vizIframe.src = visualizerUrl;
        vizQR.style.display = 'none';
      } else {
        vizIframe.style.display = 'none';
        vizIframe.src = 'about:blank';
        vizQR.style.display = 'flex';
        // ONLY display server-provided URL/image; do NOT attempt to generate a QR locally.
        const source = qrUrl || visualizerUrl || null;
        drawQrOnCanvas(vizQrCanvas, source);
      }
      enterFsBtn.disabled = true;
      startBtn.disabled = true;
      hideMsg();
      hideProgress();
    }

    function hideVisualizerOverlay(){
      visualizerLocked = false;
      visualizerOverlay.style.display = 'none';
      visualizerOverlay.setAttribute('aria-hidden','true');
      vizIframe.src = 'about:blank';
      enterFsBtn.disabled = false;
      startBtn.disabled = false;
      currentVisualizerUrl = null;
      showScreen(welcomeScreen);
    }

    /* ---------- Events wiring ---------- */
    enterFsBtn.addEventListener('click', async () => {
      try { await document.documentElement.requestFullscreen(); } catch(e){ console.warn('fullscreen failed', e); }
      if(!visualizerLocked) showScreen(welcomeScreen);
      if(socket && socket.connected) socket.emit('cell_entered_fullscreen', { session });
    });

    startBtn.addEventListener('click', async () => {
      if(visualizerLocked) return;
      try { document.getElementById('inicio').currentTime = 0; document.getElementById('inicio').play().catch(()=>{}); } catch(e){}
      showScreen(null); // hide overlays -> camera
      currentPhotoIndex = 0; photos = []; currentPhotoData = null;
      await runCaptureSequence();
    });

    // toggle safe guide
    safeToggle.addEventListener('click', () => {
      safeGuideOn = !safeGuideOn;
      if (safeGuideOn) {
        safeOverlay.classList.remove('hidden');
        safeToggle.textContent = 'Guia: ON';
      } else {
        safeOverlay.classList.add('hidden');
        safeToggle.textContent = 'Guia: OFF';
      }
    });

    // clicking QR opens visualizer in new tab (if currentVisualizerUrl set)
    vizQR.addEventListener('click', (ev) => {
      if(!currentVisualizerUrl) return;
      try {
        window.open(currentVisualizerUrl, '_blank', 'noopener');
      } catch(e){}
    });

    // socket basic events
    socket.on('connect', () => {
      console.log('socket connected', socket.id);
      if(session) socket.emit('cell_connected', { session, id: socket.id });
      hideMsg();
    });
    socket.on('disconnect', () => { console.log('socket disconnected'); });

    // server instructs show visualizer and lock the cell UI
    socket.on('visualizer_ready', (data) => {
      if(!data) return;
      if(data.session && data.session !== session) return;
      showVisualizerOverlay({ visualizerUrl: data.visualizerUrl || data.visualizadorUrl || data.url, qrUrl: data.qrUrl || data.qrcode || data.qr, showIframe: data.showIframe });
    });

    // server may instruct show_qr_on_viewer (index uses this)
    socket.on('show_qr_on_viewer', (data) => {
      if(!data) return;
      if(data.session && data.session !== session) return;
      const url = data.visualizadorUrl || data.visualizerUrl || data.url || data.visualizador;
      const qr = data.qrUrl || data.qrcode || data.qr || url;
      showVisualizerOverlay({ visualizerUrl: url, qrUrl: qr || url, showIframe: data.showIframe });
    });

    socket.on('show_qr', (data) => {
      if(!data) return;
      const visualizadorUrl = data.visualizadorUrl || data.url || data.visualizerUrl;
      if(!visualizadorUrl) return;
      showVisualizerOverlay({ visualizerUrl: visualizadorUrl, qrUrl: visualizadorUrl });
    });

    // finalize/reset session ‚Äî unlock cell
    socket.on('finalize_session', (data) => {
      if(data && data.session && data.session !== session) return;
      console.log('finalize_session received, unlocking celular');
      hideVisualizerOverlay();
      photos = []; currentPhotoIndex = 0; currentPhotoData = null;
    });
    socket.on('reset_session', (data) => {
      if(data && data.session && data.session !== session) return;
      console.log('reset_session received, unlocking celular');
      hideVisualizerOverlay();
      photos = []; currentPhotoIndex = 0; currentPhotoData = null;
    });

    // keyboard escape hides preview if shown (but not visualizer when locked)
    document.addEventListener('keydown', ev => {
      if(ev.key === 'Escape'){
        if(!previewScreen.classList.contains('hidden')) previewScreen.classList.add('hidden');
      }
    });

    // initial state
    showScreen(enterFs);

    // stop camera on page hide
    document.addEventListener('visibilitychange', () => {
      if(document.hidden) stopCamera();
    });

    // expose helpers for debug
    window._cabine = {
      startCamera: async ()=> await startCamera(),
      stopCamera: ()=> stopCamera(),
      grabFrame: ()=> grabFrameDataURL(),
      photos: ()=> photos.slice(),
      unlockVisualizer: ()=> hideVisualizerOverlay()
    };
  </script>
</body>
</html>
