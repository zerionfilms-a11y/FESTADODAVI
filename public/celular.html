<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular (Fotos + Boomerang)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    .hidden{display:none!important}
    .visible{display:flex!important}
    /* Buttons & cards */
    #enterFsBtn{padding:18px 25px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:320px}
    #startBtn{padding:14px 20px;border-radius:12px;border:none;background:#0b84ff;color:#fff;font-weight:800;cursor:pointer;font-size:18px;margin-top:12px}
    .logo{max-width:140px;margin-bottom:12px;border-radius:8px}
    .mode-buttons{display:flex;gap:18px;justify-content:center;margin-top:14px}
    .mode-btn{width:92px;height:92px;border-radius:50%;border:none;display:flex;align-items:center;justify-content:center;font-size:30px;cursor:pointer}
    .mode-btn.boom{background:linear-gradient(135deg,#4f92ff,#0077cc);color:#fff}
    .mode-btn.three{background:linear-gradient(135deg,#ffd54a,#d18a00);color:#111}
    /* Camera and preview */
    #videoEl{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:1;transform:scaleX(-1)}
    #canvasEl{position:fixed;inset:0;z-index:2;display:none;pointer-events:none}
    #cropFrame{position:absolute;border:3px dashed rgba(255,255,255,0.95);z-index:30;border-radius:8px;box-shadow:0 0 0 20000px rgba(0,0,0,0.25);pointer-events:none}
    #countdown{position:fixed;top:24%;left:0;right:0;text-align:center;font-size:120px;font-weight:900;z-index:60;color:#fff;text-shadow:0 0 40px #000}
    #recDot{position:fixed;top:14px;left:14px;padding:8px 12px;border-radius:999px;background:rgba(0,0,0,0.5);z-index:60;color:#fff;display:flex;gap:8px;align-items:center}
    .blink{animation: blink 800ms infinite}
    @keyframes blink { 0%{opacity:1}50%{opacity:0.15}100%{opacity:1} }
    /* preview modal */
    #previewScreen{position:fixed;inset:0;z-index:80;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95)}
    #previewHolder{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    #previewHolder img, #previewHolder video{max-width:100%;max-height:100%;object-fit:contain}
    .previewButtons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:12px;justify-content:center;z-index:90;padding:0 20px}
    .btn{padding:12px 16px;border-radius:10px;border:none;background:rgba(255,255,255,0.06);color:#fff;font-weight:700;cursor:pointer}
    /* small UI */
    #progress{position:fixed;top:12px;right:12px;background:rgba(0,0,0,0.65);padding:8px 12px;border-radius:10px;z-index:60}
    #qrOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:120;opacity:0;pointer-events:none;transition:opacity 220ms}
    #qrOverlay.visible{opacity:1;pointer-events:auto}
    #qrModal{background:#fff;padding:18px;border-radius:12px;color:#000;box-shadow:0 10px 30px rgba(0,0,0,0.35)}
    #debugInfo{position:fixed;bottom:8px;left:8px;font-size:12px;color:#ddd;z-index:130;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px}
    #fullscreenFail{position:fixed;top:8px;left:50%;transform:translateX(-50%);background:#ffcccb;color:#000;padding:8px 12px;border-radius:8px;z-index:200;display:none}
    @media(max-width:480px){ #countdown{font-size:72px} .mode-btn{width:72px;height:72px;font-size:22px} }
  </style>
</head>
<body>
  <!-- Fullscreen page (only enter button) -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#fff,#f5f5f5);">
    <div style="text-align:center;width:95%;max-width:420px">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#222;margin-bottom:10px">üì∏ Cabine Fotogr√°fica</h1>
      <p style="color:#444;margin-bottom:16px">Clique para entrar em tela cheia</p>
      <button id="enterFsBtn">üé¨ Entrar em Tela Cheia</button>
      <div id="fullscreenFail">N√£o foi poss√≠vel entrar em tela cheia ‚Äî abrindo normalmente.</div>
    </div>
  </div>

  <!-- Welcome (after fullscreen or fallback) -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div style="text-align:center;padding:18px;border-radius:12px;background:rgba(0,0,0,0.02)">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222;margin-bottom:8px">Preparado?</h2>
      <p style="color:#444;margin-bottom:12px">Toque em Iniciar Sess√£o</p>
      <button id="startBtn">‚ñ∂Ô∏è Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- Mode selection -->
  <div id="selectionScreen" class="screen hidden" style="background:linear-gradient(135deg,#000,#111)">
    <div style="text-align:center">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h2 style="margin-bottom:6px">Escolha o modo</h2>
      <div class="mode-buttons">
        <div style="text-align:center">
          <button id="btnBoom" class="mode-btn boom" title="Boomerang">&infin;</button>
          <div style="color:#ddd;margin-top:6px">Boomerang</div>
        </div>
        <div style="text-align:center">
          <button id="btnThree" class="mode-btn three" title="3 Fotos">‚ò∞</button>
          <div style="color:#ddd;margin-top:6px">3 Fotos</div>
        </div>
      </div>
      <p style="color:#ccc;margin-top:14px">Ser√° usada a c√¢mera frontal do celular. Posicione-se dentro do quadro.</p>
    </div>
  </div>

  <!-- Live camera preview -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>
  <div id="cropFrame" style="display:none"></div>

  <!-- Countdown / REC / progress -->
  <div id="countdown"></div>
  <div id="recDot" style="display:none"><span id="recIndicator"></span>&nbsp;<strong id="recLabel">REC</strong></div>
  <div id="progress" style="display:none"></div>

  <!-- Preview modal -->
  <div id="previewScreen" class="hidden">
    <div id="previewHolder"></div>
    <div class="previewButtons">
      <button id="refazerBtn" class="btn">üîÑ Refazer</button>
      <button id="continuarBtn" class="btn">‚úÖ Continuar</button>
    </div>
  </div>

  <!-- Thank you -->
  <div id="thankScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div style="text-align:center">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222">‚ú® Obrigado!</h2>
      <p style="color:#444">Aguarde o operador, suas fotos ser√£o processadas.</p>
    </div>
  </div>

  <!-- QR overlay -->
  <div id="qrOverlay">
    <div id="qrModal" style="display:none">
      <canvas id="qrCanvas" width="260" height="260"></canvas>
      <div style="margin-top:8px;font-size:14px;color:#222">Escaneie o QR para ver suas fotos</div>
    </div>
  </div>

  <div id="debugInfo" style="display:none"></div>

<script>
/*
  Vers√£o atualizada ‚Äî fullscreen resilient, n√£o remove funcionalidades.
  Backend: https://festadodavi-production-0591.up.railway.app
  Funcionalidades:
   - Entrar em tela cheia (tenta v√°rios m√©todos). Se falha, ainda assim avan√ßa.
   - Tela de boas-vindas -> sele√ß√£o -> captura (boomerang & 3 fotos).
   - Usa sempre c√¢mera frontal do celular (getUserMedia facingMode:'user').
   - Boomerang grava direto da stream (MediaRecorder) 2s, cria loop forward+reverse -> ~15s.
   - Preview ao vivo n√£o congela. Preview final com Refazer/Continuar.
   - Envia 'photos_submit' (array dataURL) para o server; envia 'boomerang_ready' (binary ArrayBuffer) com metadata.
*/

(function(){
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const socket = io(SERVER_URL, { transports:['polling','websocket'], reconnection:true, path:'/socket.io' });

  // TEMPLATE & BOOM area (coords relative to 3375x6000)
  const TEMPLATE_W = 3375, TEMPLATE_H = 6000;
  const BOOM_AREA = { x:295, y:272, w:2785, h:4159 };
  const BOOM_RECORD_MS = 2000;
  const BOOM_LOOP_MS = 15000;
  const BOOM_TARGET_W = 720; // ajuste se quiser 1080

  // DOM refs
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const fullscreenFail = document.getElementById('fullscreenFail');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const selectionScreen = document.getElementById('selectionScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');
  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const cropFrame = document.getElementById('cropFrame');
  const countdownEl = document.getElementById('countdown');
  const recDot = document.getElementById('recDot');
  const recIndicator = document.getElementById('recIndicator');
  const recLabel = document.getElementById('recLabel');
  const progressEl = document.getElementById('progress');
  const previewScreen = document.getElementById('previewScreen');
  const previewHolder = document.getElementById('previewHolder');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrModal = document.getElementById('qrModal');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugInfo = document.getElementById('debugInfo');

  let session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
  let stream = null;
  let previewRaf = null;
  let photos = [];

  function debug(msg){ debugInfo.style.display='block'; debugInfo.textContent = '['+new Date().toLocaleTimeString()+'] '+msg+"\n"+debugInfo.textContent; console.log(msg); }

  // Socket events
  socket.on('connect', ()=> { debug('socket conectado: ' + socket.id); socket.emit('join_session', { session, role: 'viewer' }); });
  socket.on('show_qr', ({ visualizadorUrl }) => {
    if(!visualizadorUrl) return;
    qrModal.style.display = 'block';
    try { QRCode.toCanvas(qrCanvas, visualizadorUrl, { width:260 }, (err)=>{ if(err) debug('QR error: '+err); qrOverlay.classList.add('visible'); }); } catch(e){ qrOverlay.classList.add('visible'); }
  });
  socket.on('reset_session', ()=> { photos = []; showScreen(welcomeScreen); });

  // Fullscreen attempt with fallbacks; always advance to welcome screen even if fullscreen fails.
  enterFsBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    let ok = false;
    try {
      // standard
      if (document.fullscreenEnabled && document.documentElement.requestFullscreen) {
        await document.documentElement.requestFullscreen();
        ok = true;
      } else if (document.documentElement.webkitRequestFullscreen) {
        // Safari / older
        await document.documentElement.webkitRequestFullscreen();
        ok = true;
      } else if (document.documentElement.msRequestFullscreen) {
        await document.documentElement.msRequestFullscreen();
        ok = true;
      }
    } catch(err){
      debug('requestFullscreen failed: ' + (err && err.message ? err.message : err));
      ok = false;
    }
    if(!ok){
      // maybe blocked due to iframe / policies. Show small banner and continue anyway.
      fullscreenFail.style.display = 'block';
      setTimeout(()=> fullscreenFail.style.display = 'none', 3500);
      debug('Fullscreen n√£o dispon√≠vel. Avan√ßando mesmo assim.');
    } else {
      debug('Entrou em fullscreen com sucesso.');
    }
    showScreen(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', ()=> {
    showScreen(selectionScreen);
  });

  btnThree.addEventListener('click', ()=> beginThreePhotosFlow());
  btnBoom.addEventListener('click', ()=> beginBoomerangFlow());

  function showScreen(el){
    [enterFs, welcomeScreen, selectionScreen, previewScreen, thankScreen].forEach(s => { if(s){ s.classList.add('hidden'); s.classList.remove('visible'); } });
    canvasEl.style.display = 'none';
    videoEl.style.display = 'none';
    cropFrame.style.display = 'none';
    countdownEl.textContent = '';
    if(el){ el.classList.remove('hidden'); el.classList.add('visible'); }
  }

  // ensure front camera
  async function ensureFrontCamera(){
    if(stream) return stream;
    try {
      const constraints = { video: { facingMode: { ideal: "user" }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream;
      videoEl.style.display = 'block';
      videoEl.style.transform = 'scaleX(-1)';
      await videoEl.play().catch(()=>{});
      return stream;
    } catch(e){
      debug('getUserMedia error: ' + (e && e.message ? e.message : e));
      throw e;
    }
  }

  function startPreviewLoop(){
    canvasEl.style.display = 'block';
    videoEl.style.display = 'block';
    function step(){
      drawPreview();
      previewRaf = requestAnimationFrame(step);
    }
    if(!previewRaf) step();
  }
  function stopPreviewLoop(){ if(previewRaf){ cancelAnimationFrame(previewRaf); previewRaf = null; } }

  function drawPreview(){
    if(!videoEl.videoWidth) return;
    const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
    const cw = window.innerWidth, ch = window.innerHeight;
    canvasEl.width = cw; canvasEl.height = ch;
    const ctx = canvasEl.getContext('2d');
    const scale = Math.max(cw / vw, ch / vh);
    const w = vw * scale, h = vh * scale;
    const dx = (cw - w)/2, dy = (ch - h)/2;
    ctx.save(); ctx.translate(cw,0); ctx.scale(-1,1);
    try { ctx.drawImage(videoEl, 0,0, vw, vh, 0, dy, w, h); } catch(e){}
    ctx.restore();
    // compute crop rectangle on canvas
    const sx = w / TEMPLATE_W;
    const sy = h / TEMPLATE_H;
    const cx = dx + BOOM_AREA.x * sx, cy = dy + BOOM_AREA.y * sy;
    const cwCrop = BOOM_AREA.w * sx, chCrop = BOOM_AREA.h * sy;
    cropFrame.style.left = cx + 'px';
    cropFrame.style.top = cy + 'px';
    cropFrame.style.width = cwCrop + 'px';
    cropFrame.style.height = chCrop + 'px';
    cropFrame.style.display = 'block';
  }

  /* 3-FOTOS flow */
  async function beginThreePhotosFlow(){
    try { await ensureFrontCamera(); } catch(e){ alert('Erro ao acessar c√¢mera: ' + (e.message||e)); showScreen(selectionScreen); return; }
    photos = [];
    startPreviewLoop();
    await sleep(200);
    for(let i=0;i<3;i++){
      try {
        await showCountdown(4);
        const dataUrl = await capturePhoto();
        const keep = await showImagePreviewForDecision(dataUrl);
        if(!keep){ i--; continue; }
        photos.push(dataUrl);
      } catch(e){
        debug('Erro captura: ' + (e && e.message ? e.message : e));
        i--; await sleep(300);
      }
    }
    // send photos_submit to server
    showProgress('Enviando fotos...');
    try {
      socket.emit('photos_submit', { session, viewerId: socket.id, photos });
      debug('photos_submit emitido ('+photos.length+' fotos)');
      showScreen(thankScreen);
    } catch(e){
      debug('Erro envio photos_submit: '+e);
      alert('Erro enviando fotos ao servidor.');
      showScreen(selectionScreen);
    } finally { hideProgress(); stopPreviewLoop(); }
  }

  async function capturePhoto(){
    const vw = videoEl.videoWidth || 1280, vh = videoEl.videoHeight || 720;
    const c = document.createElement('canvas'); c.width = vw; c.height = vh;
    const ctx = c.getContext('2d');
    ctx.save(); ctx.translate(c.width,0); ctx.scale(-1,1);
    ctx.drawImage(videoEl, 0,0, vw, vh);
    ctx.restore();
    return c.toDataURL('image/jpeg', 0.95);
  }

  function showImagePreviewForDecision(dataUrl){
    return new Promise((resolve) => {
      previewHolder.innerHTML = '';
      const img = document.createElement('img'); img.src = dataUrl;
      previewHolder.appendChild(img);
      previewScreen.classList.remove('hidden'); previewScreen.classList.add('visible');
      const onRef = () => { cleanup(); resolve(false); };
      const onCont = () => { cleanup(); resolve(true); };
      function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); previewScreen.classList.add('hidden'); previewScreen.classList.remove('visible'); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    }).then(async (keep) => { await sleep(200); startPreviewLoop(); return keep; });
  }

  /* BOOMERANG flow */
  async function beginBoomerangFlow(){
    try { await ensureFrontCamera(); } catch(e){ alert('Erro ao acessar c√¢mera: ' + (e.message||e)); showScreen(selectionScreen); return; }
    startPreviewLoop();
    await sleep(200);
    await showCountdown(3);
    showRec(true); showProgress('Gravando boomerang...');
    const shortBlob = await recordRawClipFromStream(BOOM_RECORD_MS);
    showRec(false); hideProgress();
    if(!shortBlob){ alert('Falha ao gravar. Tente novamente.'); showScreen(selectionScreen); return; }
    debug('Short clip gravado, bytes: ' + (shortBlob.size || 0));
    // generate boomerang final
    showProgress('Processando boomerang...');
    stopPreviewLoop();
    const finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs: BOOM_LOOP_MS, targetW: BOOM_TARGET_W });
    hideProgress();
    if(!finalBlob){ alert('Erro ao processar boomerang'); showScreen(selectionScreen); startPreviewLoop(); return; }
    const videoUrl = URL.createObjectURL(finalBlob);
    const keep = await showVideoPreviewDecision(videoUrl);
    if(!keep){ startPreviewLoop(); return; }
    // send boomerang to server (binary)
    showProgress('Enviando boomerang...');
    try {
      const ab = await finalBlob.arrayBuffer();
      socket.emit('boomerang_ready', { session, viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, size: ab.byteLength }, ab);
      const thumb = await blobToDataURL(finalBlob, true).catch(()=>null);
      if(thumb) socket.emit('photo_ready', { session, index: 0, viewerId: socket.id, photo: thumb });
      if(thumb) socket.emit('photos_submit', { session, viewerId: socket.id, photos: [thumb] });
      debug('boomerang_ready enviado.');
      showScreen(thankScreen);
    } catch(e){
      debug('Erro envio boomerang: ' + e);
      window.open(videoUrl, '_blank');
      showScreen(selectionScreen);
    } finally { hideProgress(); }
  }

  // record raw clip directly from stream (fast)
  function recordRawClipFromStream(msDuration){
    return new Promise(async (resolve) => {
      if(!stream){ try { await ensureFrontCamera(); } catch(e){ resolve(null); return; } }
      let recorder; const chunks = [];
      try { recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' }); } catch(e) {
        try { recorder = new MediaRecorder(stream); } catch(err){ debug('MediaRecorder n√£o dispon√≠vel'); resolve(null); return; }
      }
      recorder.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
      recorder.start();
      setTimeout(()=>{ if(recorder && recorder.state === 'recording') recorder.stop(); }, msDuration);
      recorder.onstop = () => { resolve(new Blob(chunks, { type:'video/webm' })); };
      setTimeout(()=>{ if(recorder && recorder.state === 'recording') recorder.stop(); }, msDuration + 4000);
    });
  }

  // generate boomerang by replaying short clip forward+reverse onto canvas and recording
  async function generateBoomerangFromShortClip(shortBlob, opts = { loopMs:15000, targetW:720 }){
    const loopMs = opts.loopMs || 15000; const targetW = opts.targetW || 720;
    const v = document.createElement('video'); v.muted = true; v.playsInline = true; v.src = URL.createObjectURL(shortBlob);
    await new Promise((res,rej)=>{ v.onloadedmetadata = res; v.onerror = ()=> rej(new Error('Erro carregar clip')); });
    const aspect = (v.videoWidth && v.videoHeight) ? (v.videoWidth / v.videoHeight) : (9/16);
    const targetH = Math.round(targetW / aspect);
    const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');
    const template = new Image(); template.crossOrigin = 'anonymous'; template.src = 'bomerang.png';
    await new Promise(r => { template.onload = r; template.onerror = r; });
    const scaleFactor = targetW / TEMPLATE_W;
    const area = { x: Math.round(BOOM_AREA.x * scaleFactor), y: Math.round(BOOM_AREA.y * scaleFactor), w: Math.round(BOOM_AREA.w * scaleFactor), h: Math.round(BOOM_AREA.h * scaleFactor) };
    const streamCap = canvas.captureStream(30);
    const chunks = []; let rec;
    try { rec = new MediaRecorder(streamCap, { mimeType: 'video/webm;codecs=vp8' }); } catch(e) { try { rec = new MediaRecorder(streamCap); } catch(e){ debug('MediaRecorder canvas fail'); return null; } }
    rec.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
    rec.start();
    const startTime = performance.now();
    function drawFrame(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(template && template.complete && template.naturalWidth) ctx.drawImage(template, 0,0, TEMPLATE_W, TEMPLATE_H, 0,0, canvas.width, canvas.height);
      else { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); }
      try { ctx.drawImage(v, 0,0, v.videoWidth, v.videoHeight, area.x, area.y, area.w, area.h); } catch(e){}
    }
    async function playForward(){ return new Promise(res => { v.currentTime = 0; v.play().catch(()=>{}); const onTick = () => { drawFrame(); if(v.ended || v.currentTime >= v.duration - 0.001){ v.pause(); v.removeEventListener('timeupdate', onTick); res(); } }; v.addEventListener('timeupdate', onTick); drawFrame(); }); }
    async function playReverse(){ return new Promise(res => { v.pause(); v.currentTime = v.duration; function step(){ const stepSec = 1/30; v.currentTime = Math.max(0, v.currentTime - stepSec); drawFrame(); if(v.currentTime > 0.02) requestAnimationFrame(step); else res(); } step(); }); }
    while(performance.now() - startTime < loopMs){ await playForward(); if(performance.now() - startTime >= loopMs) break; await playReverse(); }
    await sleep(120); await new Promise(res => { rec.onstop = res; rec.stop(); });
    return new Blob(chunks, { type:'video/webm' });
  }

  // video preview decision
  function showVideoPreviewDecision(videoUrl){
    return new Promise((resolve) => {
      previewHolder.innerHTML = '';
      const v = document.createElement('video'); v.src = videoUrl; v.loop = true; v.autoplay = true; v.controls = true;
      previewHolder.appendChild(v);
      previewScreen.classList.remove('hidden'); previewScreen.classList.add('visible');
      const onRef = () => { cleanup(); resolve(false); };
      const onCont = () => { cleanup(); resolve(true); };
      function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); previewScreen.classList.add('hidden'); previewScreen.classList.remove('visible'); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    }).then(async (keep)=>{ await sleep(200); return keep; });
  }

  // image preview decision (three photos) implemented earlier; reused
  // blob -> dataURL (optionally first frame)
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((res,rej) => {
      if(!firstFrame){
        const reader = new FileReader(); reader.onload = ()=> res(reader.result); reader.onerror = rej; reader.readAsDataURL(blob);
      } else {
        const v = document.createElement('video'); v.muted = true; v.playsInline = true; v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try { v.currentTime = Math.min(0.05, v.duration/2 || 0.05); await sleep(80); const c = document.createElement('canvas'); c.width = v.videoWidth || 640; c.height = v.videoHeight || 480; const ctx = c.getContext('2d'); ctx.drawImage(v,0,0,c.width,c.height); res(c.toDataURL('image/jpeg', 0.85)); } catch(e){ rej(e); }
        };
        v.onerror = rej;
      }
    });
  }

  // Countdown UI
  async function showCountdown(seconds = 3){
    for(let t=seconds; t>0; t--){
      countdownEl.textContent = (t <= 1) ? 'SORRIA!' : String(t);
      await sleep(1000);
    }
    countdownEl.textContent = '';
  }

  function showRec(on){
    if(on){ recDot.style.display = 'flex'; recIndicator.classList.add('blink'); recLabel.textContent = 'REC'; }
    else { recDot.style.display = 'none'; recIndicator.classList.remove('blink'); }
  }

  function showProgress(txt){ progressEl.style.display = 'block'; progressEl.textContent = txt || ''; }
  function hideProgress(){ progressEl.style.display = 'none'; progressEl.textContent = ''; }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // expose for debug
  window._cabine_mobile = { socket, ensureFrontCamera, startPreviewLoop: () => startPreviewLoop(), stopPreviewLoop: () => stopPreviewLoop() };

  // initial screen already visible (enter fullscreen). nothing else to do.
})();
</script>
</body>
</html>
