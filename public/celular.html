<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    #enterFsBtn{
      padding:18px 25px;border-radius:12px;border:none;
      background:#ffd600;color:#000;font-weight:800;
      cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:360px;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      box-shadow:0 6px 20px rgba(0,0,0,0.35);
    }
    #enterFsBtn:active{ transform: translateY(1px); }
    #welcome{background:rgba(255,255,255,0.12);padding:24px;text-align:center;border-radius:15px;width:95%;max-width:420px;backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.06)}
    .logo{max-width:160px;margin-bottom:10px;border-radius:8px}
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;transform:scaleX(-1);z-index:0}
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1}
    #progress{position:fixed;top:16px;left:50%;transform:translateX(-50%);text-align:center;font-size:20px;font-weight:700;z-index:250;color:#fff;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:8px;display:none}
    #countdown{position:fixed;top:28%;left:0;right:0;text-align:center;font-size:110px;font-weight:800;text-shadow:0 0 20px #000;z-index:260;color:#fff;pointer-events:none;display:none}
    .hidden { display: none !important; }
    .visible { display: flex !important; }
    #previewScreen{background:rgba(0,0,0,0.9);z-index:900;padding:0;display:none}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
    #previewImage{width:100%;height:100%;object-fit:contain;display:block}
    .preview-buttons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:12px;justify-content:center;padding:0 20px;z-index:910}
    .preview-btn{padding:12px 18px;border-radius:8px;border:none;font-weight:700;cursor:pointer;font-size:16px;flex:1;max-width:160px;background:rgba(255,255,255,0.08);color:white;backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.06)}
    #refazerBtn{background:#d9534f}
    #continuarBtn{background:#5cb85c}
    #thankScreen{background:linear-gradient(135deg,#001e3c,#0b84ff);z-index:900;display:none}
    #debugInfo{position:fixed;bottom:8px;left:8px;font-size:11px;color:#ddd;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;z-index:1000;max-width:48%}
    /* mode screen must be on top for clicks */
    #modeScreen{z-index:950}
    @media (max-width:480px){ #countdown { font-size:72px } }
  </style>
</head>
<body>
  <!-- ENTRAR EM TELA CHEIA: tela simples, APENAS o botÃ£o -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#001e3c,#0b84ff);z-index:1000">
    <div style="text-align:center;width:100%;max-width:460px">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#fff;margin:10px 0;font-size:20px">ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <p style="color:rgba(255,255,255,0.85);margin-bottom:14px">Toque em "Entrar em Tela Cheia" para comeÃ§ar</p>
      <button id="enterFsBtn" aria-label="Entrar em tela cheia">ðŸŽ¬ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- Welcome (fallback) -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7);z-index:1000">
    <div id="welcome">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#222;margin-bottom:8px">ðŸ“¸ Preparado?</h1>
      <p style="color:#444;margin-bottom:12px">Toque em Iniciar SessÃ£o para escolher o modo</p>
      <button id="startBtn" style="padding:16px 20px;border-radius:10px;border:none;background:#0b84ff;color:#fff;font-weight:700;cursor:pointer;font-size:18px">ðŸŽ¬ Iniciar SessÃ£o</button>
    </div>
  </div>

  <!-- Buttons mode screen (after start or after fullscreen) -->
  <div id="modeScreen" class="screen hidden" style="background:linear-gradient(135deg,#000,#222);z-index:950">
    <div style="text-align:center">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <p style="color:#fff;margin-bottom:12px">Escolha o modo</p>
      <div style="display:flex;gap:18px;justify-content:center">
        <button id="btnBoom" style="width:96px;height:96px;border-radius:50%;border:none;background:linear-gradient(135deg,#06f,#08a);font-size:28px;color:#fff;cursor:pointer">âˆž</button>
        <button id="btnThree" style="width:96px;height:96px;border-radius:50%;border:none;background:linear-gradient(135deg,#ffb400,#d18a00);font-size:28px;color:#fff;cursor:pointer">â˜°</button>
      </div>
    </div>
  </div>

  <!-- video + canvas used for live preview / capture -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>

  <div id="progress" role="status">Preparando...</div>
  <div id="countdown" aria-hidden="true"></div>

  <!-- preview after a photo / or boomerang preview -->
  <div id="previewScreen" class="screen" style="display:none;z-index:900">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview da captura">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <div id="thankScreen" class="screen" style="display:none;z-index:900">
    <div id="thank">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#fff">âœ¨ Obrigado por utilizar a cabine!</h1>
      <p style="color:#fff">Aguarde o operador finalizar a sessÃ£o.</p>
    </div>
  </div>

  <div id="debugInfo">debug</div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/*
  celular.html - correÃ§Ã£o: garante que apÃ³s tocar "Entrar em Tela Cheia" a tela de escolha aparece imediatamente.
  SERVER_URL apontado para sua preferÃªncia.
*/
const SERVER_URL = "https://festadodavi.onrender.com";
const socket = io(SERVER_URL, { transports:['websocket','polling'], reconnection:true, path:'/socket.io' });

const enterFs = document.getElementById('enterFs');
const enterFsBtn = document.getElementById('enterFsBtn');
const welcomeScreen = document.getElementById('welcomeScreen');
const startBtn = document.getElementById('startBtn');
const modeScreen = document.getElementById('modeScreen');
const btnBoom = document.getElementById('btnBoom');
const btnThree = document.getElementById('btnThree');

const videoEl = document.getElementById('videoEl');
const canvasEl = document.getElementById('canvasEl');
const progressEl = document.getElementById('progress');
const countdownEl = document.getElementById('countdown');
const previewScreen = document.getElementById('previewScreen');
const previewImage = document.getElementById('previewImage');
const refazerBtn = document.getElementById('refazerBtn');
const continuarBtn = document.getElementById('continuarBtn');
const thankScreen = document.getElementById('thankScreen');
const debugEl = document.getElementById('debugInfo');

let stream = null;
let mode = 'three';
let photos = [];
let currentCapture = null;
let drawFrameRaf = null;

function debug(msg){
  console.log(msg);
  debugEl.textContent = (new Date().toLocaleTimeString()) + ' â€” ' + msg + '\n' + debugEl.textContent;
}

/* FULLSCREEN helpers */
function isFullscreen() {
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}
function requestFullscreen(element){
  if(element.requestFullscreen) return element.requestFullscreen();
  if(element.webkitRequestFullscreen) return element.webkitRequestFullscreen();
  if(element.mozRequestFullScreen) return element.mozRequestFullScreen();
  if(element.msRequestFullscreen) return element.msRequestFullscreen();
  return Promise.reject(new Error('Fullscreen API nÃ£o suportada'));
}

/* show / hide screens */
function hideAllMain(){
  enterFs.style.display = 'none';
  welcomeScreen.style.display = 'none';
  modeScreen.style.display = 'none';
  previewScreen.style.display = 'none';
  videoEl.style.display = 'none';
  canvasEl.style.display = 'none';
  thankScreen.style.display = 'none';
  progressEl.style.display = 'none';
  countdownEl.style.display = 'none';
}
function showScreen(el){
  hideAllMain();
  if(!el) return;
  el.style.display = 'flex';
}

/* safe tap listener (click + touch) */
function safeAddTapListener(el, handler){
  el.addEventListener('click', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); handler(ev); });
  el.addEventListener('touchend', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); handler(ev); }, {passive:false});
  el.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); handler(ev); } });
}

/* Camera */
async function startFrontCamera(){
  if(stream) return stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    videoEl.srcObject = stream;
    videoEl.style.display = 'block';
    videoEl.style.transform = 'scaleX(-1)';
    await videoEl.play().catch(()=>{});
    debug('camera started: ' + (videoEl.videoWidth||'unknown') + 'x' + (videoEl.videoHeight||'unknown'));
    return stream;
  } catch(e){
    debug('erro ao acessar camera: ' + e.message);
    alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera. Verifique as permissÃµes do navegador.');
    throw e;
  }
}
function stopCamera(){
  if(stream){
    stream.getTracks().forEach(t=>t.stop());
    stream = null;
  }
  try { videoEl.pause(); } catch(e){}
  videoEl.srcObject = null;
  videoEl.style.display = 'none';
}

/* draw video continuously to canvas to avoid frozen frames */
function startDrawingPreviewToCanvas(){
  canvasEl.style.display = 'block';
  canvasEl.width = window.innerWidth;
  canvasEl.height = window.innerHeight;
  const ctx = canvasEl.getContext('2d');
  function loop(){
    try {
      if(videoEl.videoWidth && videoEl.videoHeight){
        const iw = videoEl.videoWidth, ih = videoEl.videoHeight;
        const cw = canvasEl.width, ch = canvasEl.height;
        const scale = Math.max(cw/iw, ch/ih);
        const w = iw*scale, h = ih*scale;
        ctx.clearRect(0,0,cw,ch);
        ctx.save();
        ctx.translate(cw,0); ctx.scale(-1,1);
        // draw mirrored
        ctx.drawImage(videoEl, (cw - w)/2 * -1, (ch - h)/2, w, h);
        ctx.restore();
      }
    } catch(e){}
    drawFrameRaf = requestAnimationFrame(loop);
  }
  if(!drawFrameRaf) loop();
}
function stopDrawingPreviewToCanvas(){
  if(drawFrameRaf){ cancelAnimationFrame(drawFrameRaf); drawFrameRaf = null; }
  canvasEl.style.display = 'none';
}

/* countdown and capture */
function showCountdownFor(seconds){
  countdownEl.style.display = 'block';
  return new Promise(async (resolve)=>{
    for(let t=seconds; t>0; t--){
      if(t<=2){
        countdownEl.textContent = 'SORRIA!';
        try { document.getElementById('clack').currentTime = 0; document.getElementById('clack').play().catch(()=>{}); } catch(e){}
      } else {
        countdownEl.textContent = String(t);
      }
      await new Promise(r=>setTimeout(r,1000));
    }
    countdownEl.textContent = '';
    countdownEl.style.display = 'none';
    resolve();
  });
}
async function capturePhotoDataUrl(){
  const w = videoEl.videoWidth || window.innerWidth;
  const h = videoEl.videoHeight || window.innerHeight;
  canvasEl.width = w;
  canvasEl.height = h;
  const ctx = canvasEl.getContext('2d');
  ctx.save(); ctx.translate(w,0); ctx.scale(-1,1);
  ctx.drawImage(videoEl, 0, 0, w, h);
  ctx.restore();
  const dataUrl = canvasEl.toDataURL('image/jpeg', 0.95);
  return dataUrl;
}

/* 3-photo flow */
async function startThreePhotoFlow(){
  try {
    await startFrontCamera();
    startDrawingPreviewToCanvas();
    showScreen(null);
    progressEl.style.display = 'block';
    progressEl.textContent = '1/3';
    photos = [];
    for(let i=0;i<3;i++){
      progressEl.textContent = `${i+1}/3`;
      await showCountdownFor(5);
      const dataUrl = await capturePhotoDataUrl();
      currentCapture = dataUrl;
      previewImage.src = dataUrl;
      previewScreen.style.display = 'flex';
      stopDrawingPreviewToCanvas();
      const decision = await new Promise((res)=> {
        function onRef(){ cleanup(); res('refazer'); }
        function onCont(){ cleanup(); res('continuar'); }
        function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); }
        refazerBtn.addEventListener('click', onRef);
        continuarBtn.addEventListener('click', onCont);
      });
      previewScreen.style.display = 'none';
      if(decision==='refazer'){ i = i - 1; startDrawingPreviewToCanvas(); continue; }
      photos.push(currentCapture);
      startDrawingPreviewToCanvas();
    }
    progressEl.style.display = 'none';
    stopDrawingPreviewToCanvas();
    stopCamera();
    showScreen(thankScreen);
    emitPhotosSubmit();
  } catch(e){
    debug('erro three flow: ' + e.message);
    progressEl.style.display = 'none';
    stopDrawingPreviewToCanvas();
    stopCamera();
    alert('Erro durante a captura de fotos: ' + (e.message||''));
    showScreen(welcomeScreen);
  }
}

/* Boomerang flow */
function recordShortClipFromVideo(durationMs = 2000){
  return new Promise(async (resolve, reject) => {
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    const off = document.createElement('canvas');
    off.width = vw; off.height = vh;
    const ctx = off.getContext('2d');
    const streamCap = off.captureStream(25);
    let chunks = [];
    let recorder;
    try {
      recorder = new MediaRecorder(streamCap, { mimeType: 'video/webm;codecs=vp8' });
    } catch(e) {
      try { recorder = new MediaRecorder(streamCap); } catch(err){ reject(err); return; }
    }
    recorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size) chunks.push(ev.data); };
    recorder.start(100);
    const start = performance.now();
    function frame(){
      try {
        ctx.save(); ctx.translate(off.width,0); ctx.scale(-1,1); ctx.drawImage(videoEl, 0,0,off.width,off.height); ctx.restore();
      } catch(e){}
      if(performance.now() - start < durationMs){
        requestAnimationFrame(frame);
      } else {
        setTimeout(()=>{ recorder.stop(); }, 80);
      }
    }
    recorder.onstop = () => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      resolve(blob);
    };
    frame();
  });
}
async function generateBoomerangFromShortBlob(shortBlob, totalMs = 15000){
  const v = document.createElement('video');
  v.muted = true; v.playsInline = true;
  v.src = URL.createObjectURL(shortBlob);
  await new Promise((res, rej) => { v.onloadedmetadata = () => res(); v.onerror = () => rej(new Error('Erro ao carregar short clip')); });
  const targetW = 720;
  const targetH = Math.round(targetW * (v.videoHeight / v.videoWidth || 16/9));
  const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = targetH;
  const ctx = canvas.getContext('2d');
  const captureStream = canvas.captureStream(25);
  let chunks = [];
  let recorder;
  try {
    recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });
  } catch(e) {
    recorder = new MediaRecorder(captureStream);
  }
  recorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size) chunks.push(ev.data); };
  recorder.start();
  const start = performance.now();
  function drawFrameFromVideo(video){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    try { ctx.drawImage(video, 0,0,video.videoWidth,video.videoHeight, 0,0,canvas.width,canvas.height); } catch(e){}
  }
  const playForwardOnce = () => new Promise((res) => {
    v.currentTime = 0;
    v.play().catch(()=>{});
    function tick(){
      drawFrameFromVideo(v);
      if(v.ended || v.currentTime >= v.duration - 0.001){ v.pause(); v.removeEventListener('timeupdate', tick); res(); }
    }
    v.addEventListener('timeupdate', tick);
    drawFrameFromVideo(v);
  });
  const playReverseOnce = () => new Promise((res) => {
    v.pause();
    v.currentTime = v.duration;
    function step(){
      v.currentTime = Math.max(0, v.currentTime - (1/25));
      drawFrameFromVideo(v);
      if(v.currentTime > 0.02) requestAnimationFrame(step);
      else res();
    }
    step();
  });
  while(performance.now() - start < totalMs){
    await playForwardOnce();
    if(performance.now() - start >= totalMs) break;
    await playReverseOnce();
  }
  await new Promise(r => setTimeout(r,120));
  recorder.stop();
  await new Promise(r => { recorder.onstop = r; });
  const finalBlob = new Blob(chunks, { type: 'video/webm' });
  URL.revokeObjectURL(v.src);
  return finalBlob;
}
function blobFirstFrameDataUrl(blob){
  return new Promise((res,rej) => {
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(blob);
    v.onloadeddata = async () => {
      try {
        v.currentTime = Math.min(0.05, v.duration/10);
        await new Promise(r => setTimeout(r,100));
        const c = document.createElement('canvas');
        c.width = v.videoWidth || 320; c.height = v.videoHeight || 480;
        const ctx = c.getContext('2d');
        ctx.drawImage(v, 0,0,c.width,c.height);
        const d = c.toDataURL('image/jpeg', 0.8);
        URL.revokeObjectURL(v.src);
        res(d);
      } catch(e){ rej(e); }
    };
    v.onerror = (e) => rej(e);
  });
}

/* Send photos to server */
function emitPhotosSubmit(){
  if(!socket || !socket.connected){
    debug('socket nÃ£o conectado â€” tentando conectar antes de enviar photos_submit');
    socket.connect();
    setTimeout(()=>emitPhotosSubmit(), 1500);
    return;
  }
  debug('emit photos_submit (qty=' + photos.length + ')');
  socket.emit('photos_submit', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, photos });
}

/* Send boomerang blob to server with socket fallback */
async function sendBoomerangBlobToServer(blob, thumbDataUrl){
  if(socket && socket.connected){
    try {
      const arrayBuffer = await blob.arrayBuffer();
      socket.emit('boomerang_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, data: arrayBuffer });
      debug('boomerang_ready emitido via socket');
      if(thumbDataUrl) socket.emit('photo_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, index: 0, photo: thumbDataUrl });
      return;
    } catch(e){
      debug('erro emit socket (will fallback): ' + e.message);
    }
  }
  try {
    const fd = new FormData();
    fd.append('file', blob, `boomerang_${Date.now()}.webm`);
    fd.append('session', (new URLSearchParams(location.search)).get('session') || 'cabine-fixa');
    const res = await fetch((new URL('/upload_boomerang', SERVER_URL)).toString(), { method: 'POST', body: fd });
    const json = await res.json();
    debug('fallback upload response: ' + JSON.stringify(json).slice(0,200));
    if(json && json.url){
      socket.emit('boomerang_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, videoUrl: json.url });
    }
  } catch(e){
    debug('fallback upload falhou: ' + e.message);
  }
}

/* socket handlers */
socket.on('connect', ()=> debug('socket conectado: ' + socket.id));
socket.on('disconnect', ()=> debug('socket desconectado'));
socket.on('reset_session', ()=> {
  stopDrawingPreviewToCanvas();
  stopCamera();
  photos = [];
  currentCapture = null;
  showScreen(welcomeScreen);
});

/* EVENTS wiring */
/* EnterFS: request fullscreen AND immediately show the mode selection.
   Also set a fallback timeout in case fullscreen is slow in this browser. */
safeAddTapListener(enterFsBtn, async (ev) => {
  try {
    // try request fullscreen
    await requestFullscreen(document.documentElement);
    debug('request fullscreen triggered (promise resolved)');
  } catch(e) {
    debug('requestFullscreen failed / rejected: ' + e.message);
  } finally {
    // always show mode screen immediately (this was your requested behavior)
    showScreen(modeScreen);
    // small fallback: if fullscreen not active in 700ms, still keep modeScreen visible
    setTimeout(()=>{
      if(!isFullscreen()){
        debug('fallback: fullscreen not detected, keeping modeScreen visible');
        showScreen(modeScreen);
      } else {
        debug('fullscreen active after request');
        showScreen(modeScreen);
      }
    }, 700);
    // notify server
    socket.emit('cell_entered_fullscreen', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id });
  }
});

/* ensure if fullscreenchange occurs later, we still show modeScreen */
document.addEventListener('fullscreenchange', () => {
  debug('fullscreenchange -> ' + isFullscreen());
  if(isFullscreen()){
    // ensure mode selection visible
    showScreen(modeScreen);
  }
});

/* startBtn fallback to show mode screen */
safeAddTapListener(startBtn, async ()=>{
  showScreen(modeScreen);
});

/* mode buttons */
safeAddTapListener(btnThree, async ()=>{
  mode = 'three';
  showScreen(null);
  await startThreePhotoFlow();
});

safeAddTapListener(btnBoom, async ()=>{
  mode = 'boom';
  showScreen(null);
  try {
    await startFrontCamera();
    await startBoomerangSequence();
  } catch(e){
    debug('erro boomerang: ' + e.message);
    alert('Erro no boomerang: ' + (e.message||''));
    showScreen(welcomeScreen);
  }
});

/* boomerang sequence wrapper using the functions above */
async function startBoomerangSequence(){
  try {
    await startFrontCamera();
    startDrawingPreviewToCanvas();
    showScreen(null);
    progressEl.style.display = 'block'; progressEl.textContent = 'Preparando boomerang...';
    await showCountdownFor(3);
    progressEl.textContent = 'Gravando 2s...';
    const shortBlob = await recordShortClipFromVideo(2000);
    if(!shortBlob) throw new Error('Falha ao gravar clipe curto');
    progressEl.textContent = 'Processando boomerang...';
    const finalBlob = await generateBoomerangFromShortBlob(shortBlob, 15000);
    const thumb = await blobFirstFrameDataUrl(finalBlob).catch(()=>null);
    const url = URL.createObjectURL(finalBlob);
    previewImage.src = url;
    previewScreen.style.display = 'flex';
    stopDrawingPreviewToCanvas();
    const decision = await new Promise((res)=> {
      function onRef(){ cleanup(); res('refazer'); }
      function onCont(){ cleanup(); res('continuar'); }
      function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    });
    previewScreen.style.display = 'none';
    if(decision === 'refazer'){
      URL.revokeObjectURL(url);
      startDrawingPreviewToCanvas();
      stopCamera();
      return startBoomerangSequence();
    }
    progressEl.textContent = 'Enviando boomerang...';
    await sendBoomerangBlobToServer(finalBlob, thumb);
    progressEl.style.display = 'none';
    stopCamera();
    showScreen(thankScreen);
  } catch(e){
    debug('erro boomerang seq: ' + e.message);
    progressEl.style.display = 'none';
    stopDrawingPreviewToCanvas();
    stopCamera();
    alert('Erro durante boomerang: ' + (e.message||''));
    showScreen(welcomeScreen);
  }
}

/* initial state */
showScreen(enterFs);
debug('celular.html pronto - toque em Entrar em Tela Cheia');
</script>
</body>
</html>
