<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    /* bot√£o Entrar em Tela Cheia - F√ÅCIL de ver e clicar */
    #enterFsBtn{
      padding:18px 25px;border-radius:12px;border:none;
      background:#ffd600;color:#000;font-weight:800;
      cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:360px;
      -webkit-tap-highlight-color: rgba(0,0,0,0); /* mobile highlight off */
      box-shadow:0 6px 20px rgba(0,0,0,0.35);
    }
    #enterFsBtn:active{ transform: translateY(1px); }
    #welcome{background:rgba(255,255,255,0.12);padding:24px;text-align:center;border-radius:15px;width:95%;max-width:420px;backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.06)}
    .logo{max-width:160px;margin-bottom:10px;border-radius:8px}
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;transform:scaleX(-1);z-index:0}
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1}
    #progress{position:fixed;top:16px;left:50%;transform:translateX(-50%);text-align:center;font-size:20px;font-weight:700;z-index:250;color:#fff;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:8px;display:none}
    #countdown{position:fixed;top:28%;left:0;right:0;text-align:center;font-size:110px;font-weight:800;text-shadow:0 0 20px #000;z-index:260;color:#fff;pointer-events:none;display:none}
    .hidden { display: none !important; }
    .visible { display: flex !important; }
    #previewScreen{background:rgba(0,0,0,0.9);z-index:300;padding:0;display:none}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
    #previewImage{width:100%;height:100%;object-fit:contain;display:block}
    .preview-buttons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:12px;justify-content:center;padding:0 20px;z-index:310}
    .preview-btn{padding:12px 18px;border-radius:8px;border:none;font-weight:700;cursor:pointer;font-size:16px;flex:1;max-width:160px;background:rgba(255,255,255,0.08);color:white;backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.06)}
    #refazerBtn{background:#d9534f}
    #continuarBtn{background:#5cb85c}
    #thankScreen{background:linear-gradient(135deg,#001e3c,#0b84ff);z-index:300;display:none}
    #debugInfo{position:fixed;bottom:8px;left:8px;font-size:11px;color:#ddd;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;z-index:600;max-width:48%}
    /* ensure enter screen area is on top and clickable */
    #enterFs { z-index: 700; touch-action: manipulation; pointer-events: auto; }
    /* blocker element (if created) should not intercept pointer events */
    .maybe-blocker { pointer-events: none !important; }
    @media (max-width:480px){ #countdown { font-size:72px } }
  </style>
</head>
<body>
  <!-- ENTRAR EM TELA CHEIA: tela simples, APENAS o bot√£o -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#001e3c,#0b84ff);">
    <div style="text-align:center;width:100%;max-width:460px">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#fff;margin:10px 0;font-size:20px">üì∏ Cabine Fotogr√°fica</h1>
      <p style="color:rgba(255,255,255,0.85);margin-bottom:14px">Toque em "Entrar em Tela Cheia" para come√ßar</p>
      <button id="enterFsBtn" aria-label="Entrar em tela cheia">üé¨ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- Welcome (ap√≥s fullscreen) -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7);z-index:700">
    <div id="welcome">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#222;margin-bottom:8px">üì∏ Preparado?</h1>
      <p style="color:#444;margin-bottom:12px">Toque em Iniciar Sess√£o para escolher o modo</p>
      <button id="startBtn" style="padding:16px 20px;border-radius:10px;border:none;background:#0b84ff;color:#fff;font-weight:700;cursor:pointer;font-size:18px">üé¨ Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- Buttons mode screen (after start) -->
  <div id="modeScreen" class="screen hidden" style="background:linear-gradient(135deg,#000,#222);z-index:700">
    <div style="text-align:center">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <p style="color:#fff;margin-bottom:12px">Escolha o modo</p>
      <div style="display:flex;gap:18px;justify-content:center">
        <button id="btnBoom" style="width:96px;height:96px;border-radius:50%;border:none;background:linear-gradient(135deg,#06f,#08a);font-size:28px;color:#fff;cursor:pointer">‚àû</button>
        <button id="btnThree" style="width:96px;height:96px;border-radius:50%;border:none;background:linear-gradient(135deg,#ffb400,#d18a00);font-size:28px;color:#fff;cursor:pointer">‚ò∞</button>
      </div>
    </div>
  </div>

  <!-- video + canvas used for live preview / capture -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>

  <div id="progress" role="status">Preparando...</div>
  <div id="countdown" aria-hidden="true"></div>

  <!-- preview after a photo / or boomerang preview -->
  <div id="previewScreen" class="screen" style="display:none;z-index:800">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview da captura">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">üîÑ Refazer</button>
        <button id="continuarBtn" class="preview-btn">‚úÖ Continuar</button>
      </div>
    </div>
  </div>

  <div id="thankScreen" class="screen" style="display:none;z-index:800">
    <div id="thank">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#fff">‚ú® Obrigado por utilizar a cabine!</h1>
      <p style="color:#fff">Aguarde o operador finalizar a sess√£o.</p>
    </div>
  </div>

  <div id="debugInfo">debug</div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/*
  celular.html - corrigido bot√£o "Entrar em Tela Cheia"
  Ajuste a vari√°vel SERVER_URL para o seu backend se precisar.
*/
const SERVER_URL = "https://festadodavi-production-0591.up.railway.app"; // troque se precisar
const socket = io(SERVER_URL, { transports:['websocket','polling'], reconnection:true, path:'/socket.io' });

const enterFs = document.getElementById('enterFs');
const enterFsBtn = document.getElementById('enterFsBtn');
const welcomeScreen = document.getElementById('welcomeScreen');
const startBtn = document.getElementById('startBtn');
const modeScreen = document.getElementById('modeScreen');
const btnBoom = document.getElementById('btnBoom');
const btnThree = document.getElementById('btnThree');

const videoEl = document.getElementById('videoEl');
const canvasEl = document.getElementById('canvasEl');
const progressEl = document.getElementById('progress');
const countdownEl = document.getElementById('countdown');
const previewScreen = document.getElementById('previewScreen');
const previewImage = document.getElementById('previewImage');
const refazerBtn = document.getElementById('refazerBtn');
const continuarBtn = document.getElementById('continuarBtn');
const thankScreen = document.getElementById('thankScreen');
const debugEl = document.getElementById('debugInfo');

let stream = null;
let mode = 'three'; // 'three' or 'boom'
let photos = [];
let currentCapture = null; // dataURL or blob

function debug(msg){
  console.log(msg);
  debugEl.textContent = (new Date().toLocaleTimeString()) + ' ‚Äî ' + msg + '\n' + debugEl.textContent;
}

/* ============ FULLSCREEN HELPERS ============ */
function isFullscreen() {
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
}
function requestFullscreen(element){
  if(element.requestFullscreen) return element.requestFullscreen();
  if(element.webkitRequestFullscreen) return element.webkitRequestFullscreen();
  if(element.mozRequestFullScreen) return element.mozRequestFullScreen();
  if(element.msRequestFullscreen) return element.msRequestFullscreen();
  return Promise.reject(new Error('Fullscreen API n√£o suportada'));
}
document.addEventListener('fullscreenchange', () => {
  debug('fullscreenchange -> ' + isFullscreen());
  if(isFullscreen()){
    // show welcome after fullscreen
    showScreen(welcomeScreen);
  }
});

/* ============ UI SHOW/HIDE ============ */
function hideAllMain(){
  enterFs.style.display = 'none';
  welcomeScreen.style.display = 'none';
  modeScreen.style.display = 'none';
  previewScreen.style.display = 'none';
  videoEl.style.display = 'none';
  canvasEl.style.display = 'none';
  thankScreen.style.display = 'none';
  progressEl.style.display = 'none';
  countdownEl.style.display = 'none';
}
function showScreen(el){
  hideAllMain();
  if(!el) return;
  el.style.display = 'flex';
}

/* Ensure enter button is really clickable on mobile:
   - add touchend + click listeners
   - stop propagation and prevent default to avoid ghost clicks
*/
function safeAddTapListener(el, handler){
  el.addEventListener('click', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); handler(ev); });
  el.addEventListener('touchend', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); handler(ev); }, {passive:false});
  el.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); handler(ev); } });
}

/* ============ Camera helpers ============ */
async function startFrontCamera(){
  if(stream) return stream;
  try {
    // prefer facingMode user. Using simple constraint which works on most modern mobile browsers.
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    videoEl.srcObject = stream;
    videoEl.style.display = 'block';
    videoEl.style.transform = 'scaleX(-1)'; // mirror for user
    await videoEl.play().catch(()=>{});
    debug('camera started: ' + (videoEl.videoWidth||'unknown') + 'x' + (videoEl.videoHeight||'unknown'));
    return stream;
  } catch(e){
    debug('erro ao acessar camera: ' + e.message);
    alert('N√£o foi poss√≠vel acessar a c√¢mera. Verifique as permiss√µes do navegador.');
    throw e;
  }
}
function stopCamera(){
  if(stream){
    stream.getTracks().forEach(t=>t.stop());
    stream = null;
  }
  videoEl.pause();
  videoEl.srcObject = null;
  videoEl.style.display = 'none';
}

/* draw current video frame continuously onto canvas (to avoid frozen frames) */
let drawFrameRaf = null;
function startDrawingPreviewToCanvas(){
  canvasEl.style.display = 'block';
  canvasEl.width = window.innerWidth;
  canvasEl.height = window.innerHeight;
  const ctx = canvasEl.getContext('2d');
  function loop(){
    try {
      if(videoEl.videoWidth && videoEl.videoHeight){
        // cover strategy
        const iw = videoEl.videoWidth, ih = videoEl.videoHeight;
        const cw = canvasEl.width, ch = canvasEl.height;
        const scale = Math.max(cw/iw, ch/ih);
        const w = iw*scale, h = ih*scale;
        ctx.clearRect(0,0,cw,ch);
        // mirror draw
        ctx.save();
        ctx.translate(cw,0); ctx.scale(-1,1);
        ctx.drawImage(videoEl, (cw - w)/2 * -1, (ch - h)/2, w, h); // draw mirrored
        ctx.restore();
      }
    } catch(e){}
    drawFrameRaf = requestAnimationFrame(loop);
  }
  if(!drawFrameRaf) loop();
}
function stopDrawingPreviewToCanvas(){
  if(drawFrameRaf){ cancelAnimationFrame(drawFrameRaf); drawFrameRaf = null; }
  canvasEl.style.display = 'none';
}

/* ============ Capture logic ============ */
function showCountdownFor(seconds){
  countdownEl.style.display = 'block';
  return new Promise(async (resolve)=>{
    for(let t=seconds; t>0; t--){
      if(t<=2){
        countdownEl.textContent = 'SORRIA!';
        try { document.getElementById('clack').currentTime = 0; document.getElementById('clack').play().catch(()=>{}); } catch(e){}
      } else {
        countdownEl.textContent = String(t);
      }
      await new Promise(r=>setTimeout(r,1000));
    }
    countdownEl.textContent = '';
    countdownEl.style.display = 'none';
    resolve();
  });
}
async function capturePhotoDataUrl(){
  // ensure canvas sizes match video source high-res for better quality
  const w = videoEl.videoWidth || window.innerWidth;
  const h = videoEl.videoHeight || window.innerHeight;
  canvasEl.width = w;
  canvasEl.height = h;
  const ctx = canvasEl.getContext('2d');
  // mirror so final image appears as user expects
  ctx.save(); ctx.translate(w,0); ctx.scale(-1,1);
  ctx.drawImage(videoEl, 0, 0, w, h);
  ctx.restore();
  const dataUrl = canvasEl.toDataURL('image/jpeg', 0.95);
  return dataUrl;
}

/* 3-photo flow */
async function startThreePhotoFlow(){
  try {
    await startFrontCamera();
    startDrawingPreviewToCanvas();
    showScreen(null); // hide welcome & show live canvas
    progressEl.style.display = 'block';
    progressEl.textContent = '1/3';
    photos = [];
    for(let i=0;i<3;i++){
      progressEl.textContent = `${i+1}/3`;
      await showCountdownFor(5);
      const dataUrl = await capturePhotoDataUrl();
      currentCapture = dataUrl;
      // show preview
      previewImage.src = dataUrl;
      previewScreen.style.display = 'flex';
      stopDrawingPreviewToCanvas(); // freeze preview image (the preview shows captured image)
      // wait user decision
      const decision = await new Promise((res)=> {
        function onRef(){ cleanup(); res('refazer'); }
        function onCont(){ cleanup(); res('continuar'); }
        function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); }
        refazerBtn.addEventListener('click', onRef);
        continuarBtn.addEventListener('click', onCont);
      });
      previewScreen.style.display = 'none';
      if(decision==='refazer'){ i = i - 1; /* repeat */ startDrawingPreviewToCanvas(); continue; }
      photos.push(currentCapture);
      // resume preview for next capture
      startDrawingPreviewToCanvas();
    }
    // finished 3 photos
    progressEl.style.display = 'none';
    stopDrawingPreviewToCanvas();
    stopCamera();
    showScreen(thankScreen);
    // send photos to server
    emitPhotosSubmit();
  } catch(e){
    debug('erro three flow: ' + e.message);
    progressEl.style.display = 'none';
    stopDrawingPreviewToCanvas();
    stopCamera();
    alert('Erro durante a captura de fotos: ' + (e.message||''));
    showScreen(welcomeScreen);
  }
}

/* Boomerang flow: record short 2s clip, then generate forward+reverse loop preview on client,
   allow Refazer / Continuar, on continue upload/send to server as boomerang_ready (attempt).
*/
async function startBoomerangFlow(){
  try {
    await startFrontCamera();
    startDrawingPreviewToCanvas();
    showScreen(null);
    progressEl.style.display = 'block'; progressEl.textContent = 'Preparando boomerang...';
    await showCountdownFor(3);
    progressEl.textContent = 'Gravando 2s...';
    // record 2s from canvas (cropped area if needed) -> we will record full frame for simplicity
    const shortBlob = await recordShortClipFromVideo(2000);
    if(!shortBlob) throw new Error('Falha ao gravar clipe curto');
    progressEl.textContent = 'Processando boomerang...';
    // create boomerang final (client-side rendering forward+reverse into a canvas and record)
    const finalBlob = await generateBoomerangFromShortBlob(shortBlob, 15000);
    // produce thumbnail (first frame)
    const thumbnail = await blobFirstFrameDataUrl(finalBlob).catch(()=>null);
    // preview boomerang for user (create objectURL and show it in preview screen as <video>)
    const url = URL.createObjectURL(finalBlob);
    previewImage.src = url; // use img tag ‚Äî many mobiles can show video poster via img; we can open a small video instead if needed
    // show preview with continue/refazer
    previewScreen.style.display = 'flex';
    stopDrawingPreviewToCanvas();
    const decision = await new Promise((res)=> {
      function onRef(){ cleanup(); res('refazer'); }
      function onCont(){ cleanup(); res('continuar'); }
      function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    });
    previewScreen.style.display = 'none';
    if(decision === 'refazer'){
      // allow redo
      URL.revokeObjectURL(url);
      startDrawingPreviewToCanvas();
      stopCamera();
      await startBoomerangFlow();
      return;
    }
    // continue -> send to server
    progressEl.textContent = 'Enviando boomerang...';
    await sendBoomerangBlobToServer(finalBlob, thumbnail);
    progressEl.style.display = 'none';
    stopCamera();
    showScreen(thankScreen);
  } catch(e){
    debug('erro boomerang flow: ' + e.message);
    progressEl.style.display = 'none';
    stopDrawingPreviewToCanvas();
    stopCamera();
    alert('Erro durante boomerang: ' + (e.message||''));
    showScreen(welcomeScreen);
  }
}

/* Record short clip by drawing to offscreen canvas and MediaRecorder */
function recordShortClipFromVideo(durationMs = 2000){
  return new Promise(async (resolve, reject) => {
    // offscreen canvas same size as video for quality
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    const off = document.createElement('canvas');
    off.width = vw; off.height = vh;
    const ctx = off.getContext('2d');
    // capture stream
    const streamCap = off.captureStream(25);
    let chunks = [];
    let recorder;
    try {
      recorder = new MediaRecorder(streamCap, { mimeType: 'video/webm;codecs=vp8' });
    } catch(e) {
      try { recorder = new MediaRecorder(streamCap); } catch(err){ reject(err); return; }
    }
    recorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size) chunks.push(ev.data); };
    recorder.start(100);
    const start = performance.now();
    function frame(){
      try {
        // draw mirrored frame to off
        ctx.save(); ctx.translate(off.width,0); ctx.scale(-1,1); ctx.drawImage(videoEl, 0,0,off.width,off.height); ctx.restore();
      } catch(e){}
      if(performance.now() - start < durationMs){
        requestAnimationFrame(frame);
      } else {
        setTimeout(()=>{ recorder.stop(); }, 80);
      }
    }
    recorder.onstop = () => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      resolve(blob);
    };
    frame();
  });
}

/* Create boomerang by playing short clip forward+reverse on a canvas and recording final loop */
async function generateBoomerangFromShortBlob(shortBlob, totalMs = 15000){
  // load short clip into video element
  const v = document.createElement('video');
  v.muted = true; v.playsInline = true;
  v.src = URL.createObjectURL(shortBlob);
  await new Promise((res, rej) => { v.onloadedmetadata = () => res(); v.onerror = () => rej(new Error('Erro ao carregar short clip')); });
  // target canvas
  const targetW = 720; // reduce size to keep performance acceptable
  const targetH = Math.round(targetW * (v.videoHeight / v.videoWidth || 16/9));
  const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = targetH;
  const ctx = canvas.getContext('2d');
  // optional: draw template background here (e.g., template image 'bomerang.png') underneath frames
  const captureStream = canvas.captureStream(25);
  let chunks = [];
  let recorder;
  try {
    recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });
  } catch(e) {
    recorder = new MediaRecorder(captureStream);
  }
  recorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size) chunks.push(ev.data); };
  recorder.start();
  const start = performance.now();
  // helper to draw a frame from v to canvas (cover)
  function drawFrameFromVideo(video){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    try {
      ctx.drawImage(video, 0,0,video.videoWidth,video.videoHeight, 0,0,canvas.width,canvas.height);
    } catch(e){}
  }
  // play forward and reverse repeatedly until totalMs elapsed
  // For reverse, we'll step time backwards manually
  const playForwardOnce = () => new Promise((res) => {
    v.currentTime = 0;
    v.play().catch(()=>{});
    function tick(){
      drawFrameFromVideo(v);
      if(v.ended || v.currentTime >= v.duration - 0.001){ v.pause(); v.removeEventListener('timeupdate', tick); res(); }
    }
    v.addEventListener('timeupdate', tick);
    drawFrameFromVideo(v);
  });
  const playReverseOnce = () => new Promise((res) => {
    v.pause();
    v.currentTime = v.duration;
    function step(){
      v.currentTime = Math.max(0, v.currentTime - (1/25));
      drawFrameFromVideo(v);
      if(v.currentTime > 0.02) requestAnimationFrame(step);
      else res();
    }
    step();
  });
  while(performance.now() - start < totalMs){
    await playForwardOnce();
    if(performance.now() - start >= totalMs) break;
    await playReverseOnce();
  }
  await new Promise(r => setTimeout(r,120));
  recorder.stop();
  await new Promise(r => { recorder.onstop = r; });
  const finalBlob = new Blob(chunks, { type: 'video/webm' });
  URL.revokeObjectURL(v.src);
  return finalBlob;
}

/* produce first frame dataURL for thumbnail */
function blobFirstFrameDataUrl(blob){
  return new Promise((res,rej) => {
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(blob);
    v.onloadeddata = async () => {
      try {
        v.currentTime = Math.min(0.05, v.duration/10);
        await new Promise(r => setTimeout(r,100));
        const c = document.createElement('canvas');
        c.width = v.videoWidth || 320; c.height = v.videoHeight || 480;
        const ctx = c.getContext('2d');
        ctx.drawImage(v, 0,0,c.width,c.height);
        const d = c.toDataURL('image/jpeg', 0.8);
        URL.revokeObjectURL(v.src);
        res(d);
      } catch(e){ rej(e); }
    };
    v.onerror = (e) => rej(e);
  });
}

/* Send photos to server: emits photos_submit (adjust to your server expected event) */
function emitPhotosSubmit(){
  if(!socket || !socket.connected){
    debug('socket n√£o conectado ‚Äî tentando conectar antes de enviar photos_submit');
    socket.connect();
    // try later
    setTimeout(()=>emitPhotosSubmit(), 1500);
    return;
  }
  debug('emit photos_submit (qty=' + photos.length + ')');
  socket.emit('photos_submit', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, photos });
}

/* Send boomerang blob to server ‚Äî prefer socket binary, fallback to POST */
async function sendBoomerangBlobToServer(blob, thumbDataUrl){
  if(socket && socket.connected){
    try {
      const arrayBuffer = await blob.arrayBuffer();
      socket.emit('boomerang_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, data: arrayBuffer });
      debug('boomerang_ready emitido via socket');
      if(thumbDataUrl) socket.emit('photo_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, index: 0, photo: thumbDataUrl });
      return;
    } catch(e){
      debug('erro emit socket (will fallback): ' + e.message);
    }
  }
  // fallback POST (server must implement /upload_boomerang)
  try {
    const fd = new FormData();
    fd.append('file', blob, `boomerang_${Date.now()}.webm`);
    fd.append('session', (new URLSearchParams(location.search)).get('session') || 'cabine-fixa');
    const res = await fetch((new URL('/upload_boomerang', SERVER_URL)).toString(), { method: 'POST', body: fd });
    const json = await res.json();
    debug('fallback upload response: ' + JSON.stringify(json).slice(0,200));
    if(json && json.url){
      socket.emit('boomerang_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, videoUrl: json.url });
    }
  } catch(e){
    debug('fallback upload falhou: ' + e.message);
  }
}

/* ============ socket handlers ============ */
socket.on('connect', ()=> debug('socket conectado: ' + socket.id));
socket.on('disconnect', ()=> debug('socket desconectado'));
socket.on('show_qr_on_viewer', ({ visualizadorUrl }) => {
  debug('show_qr_on_viewer recebido');
  try {
    QRCode.toCanvas(document.createElement('canvas'), visualizadorUrl, { width: 200 }, (err, canvas) => {
      if(err) return debug('erro QR: ' + err);
      // show small modal-like QR (simple approach: use alert with link ‚Äî but here we inject into debug area)
      debug('QR: ' + visualizadorUrl);
      // Show user a quick overlay with QR canvas
      const win = window.open('', '_blank');
      win.document.write('<html><head><title>QR</title></head><body style="display:flex;align-items:center;justify-content:center;height:100vh;background:#111;color:#fff;"><div style="text-align:center"><p>Abra o link abaixo:</p><a href="'+visualizadorUrl+'" target="_blank">'+visualizadorUrl+'</a><p>Ou escaneie o QR</p><img src="'+visualizadorUrl+'" style="display:none"></div></body></html>');
    });
  } catch(e){ debug('erro mostrar qr: ' + e.message); }
});
socket.on('reset_session', ()=> {
  stopDrawingPreviewToCanvas();
  stopCamera();
  photos = [];
  currentCapture = null;
  showScreen(welcomeScreen);
});

/* ============ events wiring ============ */
/* Make sure button is clickable on mobile: add both click and touch listeners */
safeAddTapListener(enterFsBtn, async (ev) => {
  try {
    await requestFullscreen(document.documentElement);
    debug('request fullscreen triggered');
    // small delay to allow fullscreen to settle on some browsers
    setTimeout(()=> showScreen(welcomeScreen), 250);
    // emit to server that mobile entered fullscreen
    socket.emit('cell_entered_fullscreen', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id });
  } catch(e) {
    debug('erro requestFullscreen: ' + e.message);
    alert('N√£o foi poss√≠vel entrar em tela cheia neste navegador. Continue mesmo assim.');
    showScreen(welcomeScreen);
  }
});

safeAddTapListener(startBtn, async ()=>{
  // move to mode selection screen (user chooses boomerang or 3 photos)
  showScreen(modeScreen);
});

safeAddTapListener(btnThree, async ()=>{
  mode = 'three';
  showScreen(null);
  await startThreePhotoFlow();
});

safeAddTapListener(btnBoom, async ()=>{
  mode = 'boom';
  showScreen(null);
  await startBoomerangFlow();
});

/* expose quick debug actions (optional) */
window._cabine = { startThreePhotoFlow, startBoomerangFlow };

/* initial state */
showScreen(enterFs);
debug('celular.html pronto - toque em Entrar em Tela Cheia');
</script>
</body>
</html>
