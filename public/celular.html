<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular (Fotos + Boomerang)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    #enterFsBtn{padding:18px 25px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:360px}
    #startBtn{padding:14px 22px;border-radius:12px;border:none;background:#fff;color:#0b84ff;font-weight:700;cursor:pointer;font-size:18px;margin-top:12px;width:90%;max-width:320px}
    .logo{max-width:180px;margin-bottom:20px;border-radius:10px}
    .mode-wrap{display:flex;gap:18px}
    .mode-btn{padding:18px;border-radius:12px;border:none;cursor:pointer;font-weight:800;font-size:20px;width:140px;height:88px}
    .mode-btn.boom{background:linear-gradient(135deg,#5bd,#07a);color:#fff}
    .mode-btn.three{background:linear-gradient(135deg,#f4b400,#d18a00);color:#000}
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:0;transform:scaleX(-1)}
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1}
    #progress{position:fixed;top:18px;left:0;right:0;text-align:center;font-size:20px;font-weight:700;z-index:120;color:#fff;background:rgba(0,0,0,0.45);padding:8px;backdrop-filter:blur(6px)}
    #countdown{position:fixed;top:26%;left:0;right:0;text-align:center;font-size:110px;font-weight:800;text-shadow:0 0 20px #000;z-index:200;color:#fff;pointer-events:none}
    #previewScreen{background:rgba(0,0,0,0.9);z-index:220;padding:0;display:none;align-items:center;justify-content:center}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}
    #previewImage, #previewVideo{max-width:100%;max-height:70vh;border-radius:10px}
    .preview-buttons{position:absolute;bottom:40px;left:0;right:0;display:flex;gap:15px;justify-content:center;padding:0 20px;z-index:230}
    .preview-btn{padding:12px 18px;border-radius:8px;border:none;font-weight:700;cursor:pointer;font-size:16px;flex:0 0 140px;background:rgba(0,0,0,0.7);color:white;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2)}
    #thankScreen{background:linear-gradient(135deg,#001e3c,#0b84ff);z-index:50;display:none}
    .hidden{display:none!important}
    .visible{display:flex!important}
    #qrOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:300;pointer-events:none;opacity:0;transition:opacity .18s}
    #qrOverlay.visible{pointer-events:auto;opacity:1}
    .qr-modal{background:#fff;color:#111;padding:16px;border-radius:12px;text-align:center}
    #debug{position:fixed;left:8px;bottom:8px;background:rgba(0,0,0,0.6);color:#ddd;padding:6px;border-radius:6px;font-size:12px;z-index:1000;max-width:48%}
    @media (max-width:480px){ #countdown{font-size:72px} .mode-btn{width:120px;height:76px;font-size:18px} }
  </style>
</head>
<body>
  <!-- 1) First page: ONLY enter fullscreen -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div style="text-align:center;background:rgba(0,0,0,0.3);padding:20px;border-radius:15px;width:95%;max-width:420px">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="font-size:22px;margin-bottom:8px">ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <p style="font-size:15px;margin-bottom:12px;color:#dbeefd">Escaneie o QR no operador e abra esta pÃ¡gina â€” para continuar, entre em tela cheia.</p>
      <button id="enterFsBtn">ðŸŽ¬ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- 2) Welcome screen AFTER fullscreen: logo + Iniciar SessÃ£o -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div style="text-align:center">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="font-size:22px;margin-bottom:8px">ðŸ“¸ Bem-vindo</h1>
      <p style="font-size:15px;margin-bottom:12px;color:#dbeefd">Pronto para comeÃ§ar?</p>
      <button id="startBtn">ðŸŽ¬ Iniciar SessÃ£o</button>
    </div>
  </div>

  <!-- 3) Mode selection screen (appears AFTER clicking Iniciar SessÃ£o) -->
  <div id="modeScreen" class="screen hidden" style="background:linear-gradient(135deg,#0b1220,#07142b);">
    <div style="text-align:center;background:rgba(255,255,255,0.03);padding:22px;border-radius:14px;width:95%;max-width:420px">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="margin-bottom:10px">Escolha o modo</h2>
      <div class="mode-wrap" style="justify-content:center;margin-top:12px">
        <button id="btnBoom" class="mode-btn boom">Boomerang</button>
        <button id="btnThree" class="mode-btn three">3 Fotos</button>
      </div>
      <p style="margin-top:14px;font-size:13px;color:#cfe8ff">Os botÃµes sÃ³ aparecem aqui â€” antes disso nada aparece.</p>
    </div>
  </div>

  <!-- live camera and canvas -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>

  <!-- countdown / status -->
  <div id="progress" class="hidden"></div>
  <div id="countdown"></div>

  <!-- preview (both photo and boomerang preview) -->
  <div id="previewScreen" class="screen" style="display:none">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview da foto" style="display:none">
      <video id="previewVideo" playsinline loop style="display:none"></video>
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <!-- thank you -->
  <div id="thankScreen" class="screen hidden" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div style="text-align:center;background:rgba(0,0,0,0.25);padding:22px;border-radius:14px;width:95%;max-width:420px">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1>âœ¨ Obrigado!</h1>
      <p>Espere o operador finalizar a sessÃ£o â€” vocÃª verÃ¡ o QR quando o visualizador for criado.</p>
    </div>
  </div>

  <!-- qr overlay (when server asks to show qr locally) -->
  <div id="qrOverlay" class="qr-overlay" aria-hidden="true">
    <div class="qr-modal">
      <div style="font-weight:700;margin-bottom:8px;color:#111">Acesse suas fotos</div>
      <canvas id="qrCanvas" width="260" height="260"></canvas>
      <div style="font-size:14px;color:#333;margin-top:8px">QR gerado pelo operador â€” toque para abrir</div>
    </div>
  </div>

  <div id="debug" style="display:none"></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/* celular.html â€” implementaÃ§Ã£o completa e reformulada
   Backend: https://festadodavi.onrender.com (conforme sua preferÃªncia)
*/
(function(){
  const SERVER_URL = "https://festadodavi.onrender.com"; // sua preferÃªncia memorizada
  const socket = io(SERVER_URL, { transports:['websocket','polling'], path:'/socket.io' });

  // DOM
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const modeScreen = document.getElementById('modeScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');
  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const progressEl = document.getElementById('progress');
  const countdownEl = document.getElementById('countdown');
  const previewScreen = document.getElementById('previewScreen');
  const previewImage = document.getElementById('previewImage');
  const previewVideo = document.getElementById('previewVideo');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugEl = document.getElementById('debug');

  // state
  const params = new URLSearchParams(location.search);
  const session = params.get('session') || 'cabine-fixa';
  let mode = null; // 'boom' or 'three'
  let stream = null;
  let currentPhoto = null; // dataURL
  let photos = [];
  let currentBoomerangBlob = null;
  let currentBoomerangThumb = null;
  let isCapturing = false;
  let viewerIdForThisClient = null; // if server gives a viewer id for targeted QR

  // UI helpers
  function showOnly(el){
    [enterFs, welcomeScreen, modeScreen, previewScreen, thankScreen].forEach(s=>{
      if(!s) return;
      if(s === el){ s.classList.remove('hidden'); s.style.display='flex' } else { s.classList.add('hidden'); s.style.display='none' }
    });
    // video/canvas visibility handled by flows
  }
  function showScreenElement(el){
    // show arbitrary element (like preview) without hiding the others strictly
    [enterFs, welcomeScreen, modeScreen, previewScreen, thankScreen].forEach(s=>{
      if(!s) return;
      if(s === el){ s.classList.remove('hidden'); s.style.display='flex' } else { s.classList.add('hidden'); s.style.display='none' }
    });
  }
  function logDebug(msg){
    console.log(msg);
    debugEl.style.display = 'block';
    debugEl.textContent = msg + "\n" + (debugEl.textContent||'');
  }

  // Initial screen: only the Enter FS button
  showOnly(enterFs);

  // Socket behavior (mostly for receiving QR and server messages)
  socket.on('connect', () => {
    logDebug(`Socket conectado: ${socket.id}`);
    socket.emit('join_session', { session, role:'viewer' });
    // ask server if there is an existing visualizador / last thumb
    socket.emit('request_session_status', { session });
  });

  socket.on('disconnect', () => {
    logDebug('Socket desconectado');
  });

  // server may request us to enter fullscreen or show qr
  socket.on('show_qr_on_viewer', ({ visualizadorUrl }) => {
    if (!visualizadorUrl) return;
    try { QRCode.toCanvas(qrCanvas, visualizadorUrl, { width:260 }); } catch(e){}
    qrOverlay.classList.add('visible');
    qrOverlay.style.pointerEvents='auto';
  });

  socket.on('show_qr_to_session', ({ visualizadorUrl }) => {
    // may show QR globally on all devices in this session
    if (!visualizadorUrl) return;
    try { QRCode.toCanvas(qrCanvas, visualizadorUrl, { width:260 }); } catch(e){}
    qrOverlay.classList.add('visible');
    qrOverlay.style.pointerEvents='auto';
  });

  // server may ask to reset
  socket.on('reset_session', ({ session: s }) => {
    if (s && s !== session) return;
    cleanupAll();
    showOnly(welcomeScreen);
  });

  // If server relays a boomerang (binary ArrayBuffer)
  socket.on('boomerang_ready', async ({ viewerId, filename, data }) => {
    logDebug('Recebido boomerang_ready do servidor');
    try {
      if (data && data.byteLength) {
        const blob = new Blob([data], { type:'video/webm' });
        currentBoomerangBlob = blob;
        const url = URL.createObjectURL(blob);
        // Show as preview video (local)
        previewVideo.src = url;
        previewVideo.style.display = 'block';
        previewImage.style.display = 'none';
        showScreenElement(previewScreen);
        previewVideo.play().catch(()=>{});
      }
    } catch(e){ logDebug('Erro boomerang_ready: ' + e); }
  });

  // -------------------------
  // Fullscreen + navigation behavior
  // -------------------------
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen(); } catch(e){}
    // after fullscreen, show welcome screen automatically
    showOnly(welcomeScreen);
    // notify operator server we entered fullscreen
    if (socket && socket.connected) socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    startBtn.textContent = 'ðŸŽµ Preparando...';
    try { await document.getElementById('inicio').play().catch(()=>{}); } catch(e){}
    await sleep(350);
    startBtn.disabled = false;
    startBtn.textContent = 'ðŸŽ¬ Iniciar SessÃ£o';
    // show mode selection screen (only there the two mode buttons are visible)
    showOnly(modeScreen);
  });

  // Mode selection buttons only appear on modeScreen
  btnThree.addEventListener('click', async () => {
    mode = 'three';
    await beginThreeFlow();
  });
  btnBoom.addEventListener('click', async () => {
    mode = 'boom';
    await beginBoomFlow();
  });

  // -------------------------
  // Camera helpers
  // -------------------------
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async function startFrontCamera(){
    if (stream) return stream;
    // Try facingMode exact then fallback to user
    const tryConstraints = [
      { video: { facingMode: { exact: "user" }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      { video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      { video: true, audio: false }
    ];
    for (let c of tryConstraints){
      try {
        const s = await navigator.mediaDevices.getUserMedia(c);
        stream = s;
        videoEl.srcObject = stream;
        videoEl.style.display='block';
        try { await videoEl.play(); } catch(e){}
        videoEl.muted = true;
        videoEl.playsInline = true;
        videoEl.style.transform = 'scaleX(-1)'; // mirrored preview
        logDebug('Camera iniciada');
        return stream;
      } catch(e){
        logDebug('Falha getUserMedia com constraints: ' + JSON.stringify(c) + ' -> ' + (e.message||e));
        // try next
      }
    }
    throw new Error('NÃ£o foi possÃ­vel acessar a cÃ¢mera frontal');
  }

  function stopFrontCamera(){
    try {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      videoEl.pause();
      videoEl.srcObject = null;
      videoEl.style.display='none';
      logDebug('Camera parada');
    } catch(e){ logDebug('Erro stop camera: ' + e); }
  }

  // capture single photo from video (mirrored to unmirror later if needed)
  function capturePhotoDataURL(){
    const w = videoEl.videoWidth || 1280;
    const h = videoEl.videoHeight || 720;
    canvasEl.width = w; canvasEl.height = h;
    const ctx = canvasEl.getContext('2d');
    // unmirror final (draw mirrored from preview)
    ctx.save();
    ctx.translate(w, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(videoEl, 0, 0, w, h);
    ctx.restore();
    const data = canvasEl.toDataURL('image/jpeg', 0.95);
    return data;
  }

  // -------------------------
  // Flow: 3 Photos
  // -------------------------
  async function beginThreeFlow(){
    // show a small splash then start camera + capture sequence
    showOnly(null); // hide screens but keep camera visible
    try {
      await startFrontCamera();
    } catch(e){
      alert('Erro ao iniciar cÃ¢mera: ' + (e.message || e));
      showOnly(welcomeScreen);
      return;
    }
    photos = [];
    let i = 0;
    while (i < 3){
      try {
        progressEl.textContent = `${i+1}/3`;
        progressEl.classList.remove('hidden');
        // show live preview while counting down
        countdownEl.textContent = '';
        // countdown 5..1 (but show SORRIA on last two)
        for (let t = 5; t > 0; t--){
          if (t <= 2){
            countdownEl.textContent = 'SORRIA!';
            countdownEl.style.color = '#ffd600';
            if (t === 2){ try { clack.currentTime=0; clack.play().catch(()=>{}); } catch(e){} }
          } else {
            countdownEl.textContent = String(t);
            countdownEl.style.color = '#fff';
          }
          await sleep(1000);
        }
        // capture
        countdownEl.textContent = '';
        const data = capturePhotoDataURL();
        currentPhoto = data;
        // show preview (photo)
        previewImage.src = data;
        previewImage.style.display='block';
        previewVideo.style.display='none';
        showScreenElement(previewScreen);
        // wait for user decision: refazer or continuar
        const decision = await waitForPreviewDecision();
        if (decision === 'refazer'){
          // just loop again (do not increment i)
          previewImage.src = '';
          showOnly(null); // back to camera view
          continue;
        } else {
          photos.push(data);
          i++;
          previewImage.src = '';
          showOnly(null);
          continue;
        }
      } catch(e){
        logDebug('Erro no fluxo 3 fotos: ' + e);
        // try again
      } finally {
        progressEl.classList.add('hidden');
      }
    } // end while
    // Done 3 photos
    stopFrontCamera();
    showOnly(thankScreen);
    // Emit photos to server â€” these are the raw 3 photos (index will do montage)
    try {
      if (socket && socket.connected){
        socket.emit('photos_submit', { session, viewerId: socket.id, photos });
        logDebug('photos_submit enviado com ' + photos.length + ' fotos');
      } else {
        logDebug('Socket nÃ£o conectado â€” nÃ£o enviei photos_submit');
      }
    } catch(e){ logDebug('Erro enviando photos_submit: ' + e); }
  }

  // helper: wait for user preview decision
  function waitForPreviewDecision(timeoutMs = 60000){
    return new Promise((resolve) => {
      let done = false;
      function onRef(){
        if (done) return;
        done = true;
        cleanup();
        resolve('refazer');
      }
      function onCont(){
        if (done) return;
        done = true;
        cleanup();
        resolve('continuar');
      }
      function cleanup(){
        refazerBtn.removeEventListener('click', onRef);
        continuarBtn.removeEventListener('click', onCont);
      }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
      // fallback timeout
      setTimeout(()=>{ if(!done){ done=true; cleanup(); resolve('continuar'); } }, timeoutMs);
    });
  }

  // -------------------------
  // Flow: Boomerang
  // -------------------------
  async function beginBoomFlow_preRecord(){
    // helper just to show camera and small crop overlay if you want
    // For now we record center vertical crop when generating boomerang
    showOnly(null);
    try {
      await startFrontCamera();
    } catch(e){
      alert('Erro ao iniciar cÃ¢mera: ' + (e.message || e));
      showOnly(welcomeScreen);
      return false;
    }
    return true;
  }

  async function beginBoomFlow(){
    const ok = await beginBoomFlow_preRecord();
    if (!ok) return;

    // show an instruction then countdown
    progressEl.textContent = 'Preparando Boomerang...'; progressEl.classList.remove('hidden');

    for (let t=3; t>0; t--){
      countdownEl.textContent = String(t);
      await sleep(700);
    }
    countdownEl.textContent = '';
    progressEl.textContent = 'Gravando...';

    // record 2s short clip from camera (cropped to vertical)
    let shortBlob = null;
    try {
      shortBlob = await recordShortClipFromVideo(2000);
    } catch(e){
      logDebug('Erro gravando short clip: ' + e);
    }

    if (!shortBlob){
      progressEl.textContent = 'Erro ao gravar. Tente novamente';
      await sleep(1000);
      progressEl.classList.add('hidden');
      showOnly(welcomeScreen);
      stopFrontCamera();
      return;
    }

    logDebug('Short clip gravado size=' + (shortBlob.size || 0));

    // create thumbnail (first frame) for preview + for sending to index
    let thumb = null;
    try { thumb = await blobToDataURL(shortBlob, true); currentBoomerangThumb = thumb; } catch(e){ logDebug('Erro thumb do shortBlob: ' + e); }

    // generate boomerang (loop forward + reverse until ~12s)
    progressEl.textContent = 'Processando Boomerang...';
    let finalBlob = null;
    try {
      finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs: 12000, targetW: 720 });
    } catch(e){
      logDebug('Erro gerar boomerang: ' + e);
    }

    if (!finalBlob){
      progressEl.textContent = 'Erro processando boomerang';
      await sleep(800);
      progressEl.classList.add('hidden');
      showOnly(welcomeScreen);
      stopFrontCamera();
      return;
    }

    // create preview for user (video)
    currentBoomerangBlob = finalBlob;
    const localUrl = URL.createObjectURL(finalBlob);
    previewVideo.src = localUrl;
    previewVideo.style.display='block';
    previewImage.style.display='none';
    showScreenElement(previewScreen);
    try { await previewVideo.play().catch(()=>{}); } catch(e){}

    progressEl.classList.add('hidden');
    countdownEl.textContent = '';

    // Wait for user decision: refazer or continuar
    const decision = await waitForPreviewDecision();
    if (decision === 'refazer'){
      // discard and restart boomerang flow
      previewVideo.pause();
      previewVideo.src = '';
      currentBoomerangBlob = null;
      currentBoomerangThumb = null;
      showOnly(null);
      // keep camera open to allow re-record
      await beginBoomFlow();
      return;
    } else {
      // user accepted -> send to server
      previewVideo.pause();
      previewVideo.src = '';
      stopFrontCamera();
      showOnly(thankScreen);

      try {
        // send boomerang to server as ArrayBuffer via socket
        const arrayBuffer = await currentBoomerangBlob.arrayBuffer();
        socket.emit('boomerang_ready', { session, viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, data: arrayBuffer });
        logDebug('boomerang_ready emitido (via socket ArrayBuffer)');
        // also send small thumbnail as photo_ready so index can show quickly
        if (currentBoomerangThumb){
          socket.emit('photo_ready', { session, index: 0, viewerId: socket.id, photo: currentBoomerangThumb });
        }
        // also emit photos_submit like before for compatibility (with single thumb)
        socket.emit('photos_submit', { session, viewerId: socket.id, photos: [currentBoomerangThumb] });
      } catch(e){
        logDebug('Erro enviando boomerang: ' + e);
      }
      return;
    }
  }

  // record a short clip by capturing frames from the live video into an offscreen canvas stream
  async function recordShortClipFromVideo(msDuration = 2000){
    if (!stream) await startFrontCamera();
    const vw = videoEl.videoWidth || 640;
    const vh = videoEl.videoHeight || 1280;
    // we'll crop center vertical region to keep boomerang portrait
    const cropW = Math.min(vw, Math.round(vh * 0.6)); // choose a portrait crop width
    const cropH = Math.round(cropW * (16/9) * (1)); // approximate - we'll make it portrait-ish
    // to simplify: capture full video and later process into portrait canvas
    const off = document.createElement('canvas');
    // produce a portrait target width (e.g., 720x1280)
    const outW = 720;
    const outH = Math.round(outW * (16/9));
    off.width = outW; off.height = outH;
    const offCtx = off.getContext('2d');

    const captureStream = off.captureStream(30);
    const recorded = [];
    const recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });

    recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size) recorded.push(ev.data); };
    recorder.start();

    const start = performance.now();
    await new Promise((resolve) => {
      function frame(){
        try {
          // draw mirrored frame into canvas but unmirror (draw source mirrored to keep consistent)
          offCtx.save();
          // fill
          offCtx.fillStyle = '#000'; offCtx.fillRect(0,0,off.width,off.height);
          // draw video scaled to cover the portrait canvas; use center cropping
          const sW = videoEl.videoWidth || vw, sH = videoEl.videoHeight || vh;
          // compute cover scale
          const scale = Math.max(sW / off.width, sH / off.height);
          const sw = Math.round(off.width * scale), sh = Math.round(off.height * scale);
          const sx = Math.round((sW - (off.width * scale)) / 2 / scale * sW / sW); // we will just use drawImage with center cropping differently
          // simpler: drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh)
          // compute source crop coords to center
          const srcRatio = sW / sH;
          const dstRatio = off.width / off.height;
          let srcX = 0, srcY = 0, srcW = sW, srcH = sH;
          if (srcRatio > dstRatio) {
            // source wider â€” crop sides
            srcW = Math.round(sH * dstRatio);
            srcX = Math.round((sW - srcW)/2);
          } else {
            // source taller â€” crop top/bottom
            srcH = Math.round(sW / dstRatio);
            srcY = Math.round((sH - srcH)/2);
          }
          // draw mirrored (so final is unmirrored)
          offCtx.save();
          // draw video into off canvas (mirror to make it natural)
          offCtx.translate(off.width, 0);
          offCtx.scale(-1,1);
          offCtx.drawImage(videoEl, srcX, srcY, srcW, srcH, 0, 0, off.width, off.height);
          offCtx.restore();
          offCtx.restore();
        } catch(e){}
        if (performance.now() - start < msDuration) {
          requestAnimationFrame(frame);
        } else {
          setTimeout(()=>{ recorder.stop(); resolve(); }, 60);
        }
      }
      frame();
    });

    await new Promise(res => { recorder.onstop = res; });

    const blob = new Blob(recorded, { type: 'video/webm' });
    return blob;
  }

  // generate boomerang from short clip: play forward & reverse drawing to canvas and record that canvas
  async function generateBoomerangFromShortClip(shortBlob, options = { loopMs:12000, targetW:720 }){
    const loopMs = options.loopMs || 12000;
    const targetW = options.targetW || 720;
    // load video element
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(shortBlob);

    await new Promise((res, rej) => {
      v.onloadedmetadata = () => res();
      v.onerror = () => rej(new Error('Erro ao carregar short clip'));
    });

    // canvas target (portrait)
    const canvas = document.createElement('canvas');
    const aspect = v.videoWidth && v.videoHeight ? (v.videoHeight / v.videoWidth) : (16/9);
    canvas.width = targetW;
    canvas.height = Math.round(targetW * aspect);
    const ctx = canvas.getContext('2d');

    // draw template background if you have one (bomerang.png) - optional
    const template = new Image();
    template.src = 'bomerang.png';
    template.crossOrigin = 'anonymous';
    await new Promise(r => { template.onload = r; template.onerror = r; });

    const streamRec = canvas.captureStream(30);
    const chunks = [];
    const rec = new MediaRecorder(streamRec, { mimeType: 'video/webm;codecs=vp8' });
    rec.ondataavailable = (e)=>{ if (e.data && e.data.size) chunks.push(e.data); };
    rec.start();

    const startTime = performance.now();

    function drawFrame(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (template && template.complete && template.naturalWidth){
        ctx.drawImage(template, 0, 0, template.width, template.height, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      }
      try {
        ctx.drawImage(v, 0, 0, v.videoWidth, v.videoHeight, 0, 0, canvas.width, canvas.height);
      } catch(e){}
    }

    // helper to play forward
    async function playForward(){
      return new Promise(res => {
        v.currentTime = 0;
        v.play().catch(()=>{});
        function onTime(){
          drawFrame();
          if (v.ended || v.currentTime >= v.duration - 0.001) {
            v.pause();
            v.removeEventListener('timeupdate', onTime);
            res();
          }
        }
        v.addEventListener('timeupdate', onTime);
        drawFrame();
      });
    }

    // helper to play reverse by stepping back
    async function playReverse(){
      return new Promise(res => {
        v.pause();
        v.currentTime = v.duration;
        function step(){
          const stepTime = 1/30;
          v.currentTime = Math.max(0, v.currentTime - stepTime);
          drawFrame();
          if (v.currentTime > 0.02) requestAnimationFrame(step);
          else res();
        }
        step();
      });
    }

    while (performance.now() - startTime < loopMs){
      await playForward();
      if (performance.now() - startTime >= loopMs) break;
      await playReverse();
    }

    await sleep(80);
    await new Promise(res => { rec.onstop = res; rec.stop(); });

    const finalBlob = new Blob(chunks, { type: 'video/webm' });
    return finalBlob;
  }

  // convert blob to dataURL (and optionally extract first frame)
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((res, rej) => {
      if (!firstFrame){
        const reader = new FileReader();
        reader.onload = () => res(reader.result);
        reader.onerror = (e)=> rej(e);
        reader.readAsDataURL(blob);
      } else {
        const v = document.createElement('video');
        v.muted = true; v.playsInline = true;
        v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try {
            v.currentTime = 0.05;
            await sleep(80);
            const c = document.createElement('canvas');
            c.width = v.videoWidth || 320; c.height = v.videoHeight || 480;
            const ctx = c.getContext('2d');
            ctx.drawImage(v, 0, 0, c.width, c.height);
            res(c.toDataURL('image/jpeg', 0.8));
          } catch(e){ rej(e); }
        };
        v.onerror = (e)=> rej(e);
      }
    });
  }

  // -------------------------
  // Preview refazer/continuar wiring already uses waitForPreviewDecision
  // -------------------------

  // -------------------------
  // Cleanup helper
  // -------------------------
  function cleanupAll(){
    stopFrontCamera();
    photos = [];
    currentPhoto = null;
    currentBoomerangBlob = null;
    currentBoomerangThumb = null;
    qrOverlay.classList.remove('visible');
    qrOverlay.style.pointerEvents='none';
    previewImage.src = '';
    previewVideo.src = '';
    previewVideo.pause();
    progressEl.classList.add('hidden');
    countdownEl.textContent = '';
  }

  // -------------------------
  // Misc utilities
  // -------------------------
  function prettySize(n){
    if (!n) return '0';
    if (n < 1024) return n + ' B';
    if (n < 1024*1024) return (n/1024).toFixed(1)+' KB';
    return (n/1024/1024).toFixed(2)+' MB';
  }

  // Expose debug helper via window (for manual testing)
  window._celular = {
    startFrontCamera, stopFrontCamera, cleanupAll
  };

  // show/hide qr overlay on tap
  qrOverlay.addEventListener('click', () => {
    qrOverlay.classList.remove('visible');
    qrOverlay.style.pointerEvents='none';
  });

  // hide preview if user clicks outside (defensive)
  previewScreen.addEventListener('click', (ev) => {
    if (ev.target === previewScreen) {
      // treat as continuar
      continuarBtn.click();
    }
  });

  // Stop streams when page unloads
  window.addEventListener('pagehide', () => {
    cleanupAll();
  });

  // END IIFE
})();
</script>
</body>
</html>
