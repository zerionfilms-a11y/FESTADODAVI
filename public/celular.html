<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    #enterFsBtn{padding:18px 25px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:300px}
    #welcome{background:rgba(255,255,255,0.15);padding:25px;text-align:center;border-radius:15px;width:95%;max-width:400px;backdrop-filter:blur(15px);border:2px solid rgba(255,255,255,0.3)}
    #startBtn{padding:20px 28px;border-radius:14px;border:none;background:#b07e09;color:#fff;font-weight:800;cursor:pointer;font-size:22px;margin-top:12px;box-shadow:0 6px 18px rgba(0,0,0,0.35);width:100%;max-width:340px;transition:all 0.25s ease}
    .logo{max-width:180px;margin-bottom:20px;border-radius:10px}
    /* live preview elements */
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1}
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1}
    #progress{position:fixed;top:20px;left:0;right:0;text-align:center;font-size:28px;font-weight:700;z-index:150;color:#fff;text-shadow:0 0 10px #000;background:rgba(0,0,0,0.5);padding:10px;backdrop-filter:blur(5px)}
    #countdown{position:fixed;top:30%;left:0;right:0;text-align:center;font-size:120px;font-weight:800;text-shadow:0 0 20px #000, 0 0 30px #000;z-index:200;color:#ffffff;pointer-events:none}
    #msg{position:fixed;top:50%;left:0;right:0;text-align:center;font-size:28px;font-weight:700;z-index:100;color:#fff;text-shadow:0 0 10px #000}
    #previewScreen{background:rgba(0,0,0,0.9);z-index:300;padding:0}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}
    #previewImage{max-width:92%;max-height:82%;object-fit:contain;display:block;border-radius:8px}
    .preview-buttons{position:absolute;bottom:30px;left:0;right:0;display:flex;gap:15px;justify-content:center;padding:0 20px;z-index:310}
    .preview-btn{padding:12px 18px;border-radius:8px;border:none;font-weight:700;cursor:pointer;font-size:16px;flex:1;max-width:160px;background:rgba(0,0,0,0.7);color:white;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.3)}
    #refazerBtn{background:rgba(220,53,69,0.85)}
    #continuarBtn{background:rgba(40,167,69,0.85)}
    #thank { background: rgba(255,255,255,0.12); padding: 20px; border-radius: 14px; width:95%;max-width:420px;text-align:center;backdrop-filter:blur(12px);border:2px solid rgba(255,255,255,0.12)}
    .hidden { display: none !important; }
    .visible { display: flex !important; }
    #debugInfo {position:fixed;bottom:10px;left:10px;font-size:10px;color:#888;background:rgba(0,0,0,0.6);padding:6px;border-radius:6px;z-index:1000;white-space:pre-line;max-width:46%}
    .qr-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:400; opacity:0; pointer-events:none; transition:opacity 260ms ease; }
    .qr-overlay.visible { opacity:1; pointer-events:auto; }
    .qr-backdrop { position:absolute; inset:0; backdrop-filter:blur(10px); background: rgba(0,0,0,0.45); }
    .qr-modal { position:relative; background:rgba(255,255,255,0.98); padding:18px; border-radius:12px; text-align:center; box-shadow:0 10px 30px rgba(0,0,0,0.4); max-width:90%; width:360px; transform:translateY(12px) scale(.98); }
    .qr-modal canvas { width:260px; height:260px; object-fit:contain; display:block; margin:0 auto 12px; background:#fff; border-radius:6px; }
    @media (max-width:480px){ #countdown { font-size:84px } #previewImage{max-width:96%;max-height:70%} }
  </style>
</head>
<body>
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#fff,#f5f5f5);">
    <div style="text-align:center;background:rgba(0,0,0,0.03);padding:20px;border-radius:15px;backdrop-filter:blur(10px);width:95%;max-width:400px">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="font-size:24px;margin-bottom:20px;color:#222">ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <p style="font-size:16px;margin-bottom:20px;color:#444">Para melhor experiÃªncia, entre em tela cheia</p>
      <button id="enterFsBtn">ðŸŽ¬ Entrar em Tela Cheia</button>
    </div>
  </div>

  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div id="welcome">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#222">ðŸ“¸ Bem-vindo Ã  Cabine FotogrÃ¡fica</h1>
      <p style="color:#444">Clique abaixo para iniciar</p>
      <button id="startBtn">ðŸŽ¬ Iniciar SessÃ£o de Fotos</button>
    </div>
  </div>

  <!-- surfaces for live mirrored preview (canvasEl) and optional videoEl kept hidden -->
  <canvas id="canvasEl"></canvas>
  <video id="videoEl" autoplay playsinline muted style="display:none"></video>

  <div id="progress" class="hidden"></div>
  <div id="countdown"></div>
  <div id="msg"></div>

  <div id="previewScreen" class="screen hidden">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview da foto">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <div id="thankScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div id="thank">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#222">âœ¨ Obrigado por utilizar a cabine!</h1>
      <p style="color:#444">Espere o operador encerrar a sessÃ£o (ou reinicie para uma nova).</p>
    </div>
  </div>

  <div id="qrOverlay" class="qr-overlay hidden" aria-hidden="true">
    <div class="qr-backdrop"></div>
    <div class="qr-modal" role="dialog" aria-modal="true">
      <div id="qrTitle" style="font-weight:700;margin-bottom:8px;color:#222">Escaneie o QR para ver suas fotos</div>
      <canvas id="qrCanvas" width="260" height="260" style="display:block;margin:0 auto 8px;background:#fff"></canvas>
      <div style="font-size:14px;color:#333;margin-top:6px">As fotos ficarÃ£o disponÃ­veis por 7 dias</div>
    </div>
  </div>

  <div id="debugInfo"></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/* ===========================================================
   Celular (viewer) â€” captura LOCAL com cÃ¢mera frontal, alta-res
   - Preview MIRROR (espelhado) durante contagem
   - Captura em resoluÃ§Ã£o mÃ¡xima disponÃ­vel (canvas baseado em videoWidth/Height)
   - Preview final mostra exatamente a foto (sem inverter)
   - Envia photos_submit com array de dataURLs ao final
   - MantÃ©m handlers socket: show_qr, reset_session, stream_frame, photo_ready
   ============================================================ */

(function(){
  // ajuste do backend (conforme vocÃª informou)
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const socket = io(SERVER_URL, { transports: ['polling','websocket'], reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 1000, timeout: 20000, withCredentials: true, path: '/socket.io' });

  const params = new URLSearchParams(location.search);
  const session = params.get('session') || 'cabine-fixa';

  // DOM refs
  const debugEl = document.getElementById('debugInfo');
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const canvasEl = document.getElementById('canvasEl');
  const videoEl = document.getElementById('videoEl');
  const progressEl = document.getElementById('progress');
  const countdownEl = document.getElementById('countdown');
  const previewScreen = document.getElementById('previewScreen');
  const previewImage = document.getElementById('previewImage');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const clack = document.getElementById('clack');
  const inicio = document.getElementById('inicio');
  const fim = document.getElementById('fim');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrCanvas = document.getElementById('qrCanvas');

  // state
  let localStream = null;
  let photos = [];
  let currentPhotoIndex = 0;
  let mode = 'idle'; // 'idle' | 'capturing' | 'preview' | 'thank'
  let drawingFrame = false;
  let drawLoopReq = null;

  // Debug panel
  setInterval(()=> {
    debugEl.textContent = `SessÃ£o: ${session}\nSocket: ${socket && socket.connected ? 'ðŸŸ¢ conectado' : 'ðŸ”´ desconectado'}\nModo: ${mode}\nFotos capturadas: ${photos.length}`;
  }, 900);

  // UI helpers
  function showScreen(screenElement){
    [enterFs,welcomeScreen,previewScreen,thankScreen].forEach(s=>{
      if(s){ s.classList.add('hidden'); s.classList.remove('visible'); s.style.display='none'; }
    });
    canvasEl.style.display = 'none';
    countdownEl.textContent = '';
    progressEl.classList.add('hidden');
    if(screenElement){ screenElement.classList.remove('hidden'); screenElement.classList.add('visible'); screenElement.style.display='flex'; }
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  showScreen(enterFs);

  // -----------------------------
  // Camera start/stop (frontal, alta-res ideal)
  // -----------------------------
  async function startFrontCamera(){
    if (localStream) return;
    try {
      // ideal high-res (use ideal not exact to let device pick supported)
      const constraints = {
        video: {
          facingMode: { ideal: "user" },
          width: { ideal: 3264 },
          height: { ideal: 1836 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = localStream;
      videoEl.muted = true;
      videoEl.playsInline = true;
      videoEl.style.display = 'none'; // we render preview via canvas (mirrored) for consistent view
      await videoEl.play().catch(()=>{});
      logDebug('camera started: ' + (videoEl.videoWidth || 'unknown') + 'x' + (videoEl.videoHeight || 'unknown'));
    } catch (e) {
      logDebug('Erro ao iniciar cÃ¢mera frontal: ' + (e && e.message ? e.message : e));
      alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera frontal. Verifique permissÃµes.');
      throw e;
    }
  }

  function stopFrontCamera(){
    try {
      if(localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream = null; }
      if(drawLoopReq) { cancelAnimationFrame(drawLoopReq); drawLoopReq = null; }
      canvasEl.style.display = 'none';
      videoEl.pause();
      videoEl.srcObject = null;
    } catch(e){}
  }

  // draw live mirrored preview (canvas) from video
  function startMirroredPreview(){
    if (!localStream) return;
    canvasEl.style.display = 'block';
    const ctx = canvasEl.getContext('2d');
    function fitCanvas(){
      canvasEl.width = window.innerWidth;
      canvasEl.height = window.innerHeight;
    }
    fitCanvas();
    window.addEventListener('resize', fitCanvas);

    function drawLoop(){
      if (!localStream || mode === 'idle') { drawLoopReq = requestAnimationFrame(drawLoop); return; }
      const vw = videoEl.videoWidth || videoEl.clientWidth || 640;
      const vh = videoEl.videoHeight || videoEl.clientHeight || 480;
      // compute scale to cover canvas
      const scale = Math.max(canvasEl.width / vw, canvasEl.height / vh);
      const dw = vw * scale, dh = vh * scale;
      ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
      ctx.save();
      // mirror horizontally so user sees mirror
      ctx.translate(canvasEl.width/2, canvasEl.height/2);
      ctx.scale(-1, 1);
      ctx.translate(-canvasEl.width/2, -canvasEl.height/2);
      // draw centered
      ctx.drawImage(videoEl, (canvasEl.width - dw)/2, (canvasEl.height - dh)/2, dw, dh);
      ctx.restore();
      drawLoopReq = requestAnimationFrame(drawLoop);
    }
    if (!drawLoopReq) drawLoopReq = requestAnimationFrame(drawLoop);
  }

  // -----------------------------
  // Capture full-resolution from video stream
  // - create offline canvas matching video intrinsic size
  // - draw mirrored (so final image == preview) -> user asked preview==photo
  // -----------------------------
  function capturePhotoFullRes(){
    if (!localStream) throw new Error('Camera nÃ£o iniciada');
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    // create offscreen canvas in video resolution
    const c = document.createElement('canvas');
    c.width = vw;
    c.height = vh;
    const ctx = c.getContext('2d');
    // mirror draw so final image looks like preview seen by user
    ctx.save();
    ctx.translate(c.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(videoEl, 0, 0, c.width, c.height);
    ctx.restore();
    // export high quality jpeg
    const dataUrl = c.toDataURL('image/jpeg', 0.95);
    return dataUrl;
  }

  // -----------------------------
  // Preview show (uses captured dataURL exactly)
  // -----------------------------
  function showPhotoPreview(photoDataUrl){
    previewImage.src = photoDataUrl;
    showScreen(previewScreen);
    mode = 'preview';
  }

  // -----------------------------
  // Capture sequence (LOCAL) with countdown and refazer/continuar
  // -----------------------------
  async function takeOneLocal(index, timeoutMs = 15000){
    progressEl.textContent = `${index+1}/3`;
    progressEl.classList.remove('hidden');

    // countdown 5..1 (mirror preview already running)
    for (let t = 5; t > 0; t--){
      if (t <= 2) {
        countdownEl.textContent = 'SORRIA!';
        countdownEl.style.color = '#ffd600';
        if (t === 2) { try { clack.currentTime = 0; clack.play().catch(()=>{}); } catch(e){} }
      } else {
        countdownEl.textContent = String(t);
        countdownEl.style.color = '#fff';
      }
      await sleep(1000);
    }
    countdownEl.textContent = '';

    // capture
    try {
      const photo = capturePhotoFullRes();
      return photo;
    } catch(e){
      throw e;
    }
  }

  async function startLocalCaptureSequence(){
    // start camera if needed
    try {
      await startFrontCamera();
    } catch(e){
      showScreen(welcomeScreen);
      return;
    }
    // enable mirrored live preview
    mode = 'capturing';
    startMirroredPreview();

    photos = []; currentPhotoIndex = 0;

    for (let i = 0; i < 3; i++){
      try {
        const photo = await takeOneLocal(i, 15000);
        // push and show preview (preview is identical to capture because we mirrored when drawing)
        photos.push(photo);
        currentPhotoIndex = photos.length;
        showPhotoPreview(photo);

        // wait user decision
        const decision = await new Promise((resolve) => {
          const onRef = () => { refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); resolve('refazer'); };
          const onCont = () => { refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); resolve('continuar'); };
          refazerBtn.addEventListener('click', onRef);
          continuarBtn.addEventListener('click', onCont);
        });

        if (decision === 'refazer'){
          photos.pop();
          currentPhotoIndex = photos.length;
          // return to capturing (mirrored live)
          mode = 'capturing';
          showScreen(null);
          await sleep(200);
          i = i - 1; // redo this index
          continue;
        } else {
          // continue -> next
          mode = 'capturing';
          showScreen(null);
          await sleep(200);
          continue;
        }

      } catch(err){
        logDebug('Erro capturando local: ' + (err && err.message ? err.message : err));
        progressEl.textContent = 'Erro ao capturar. Tentando novamente...';
        await sleep(900);
        i = i - 1;
        continue;
      }
    }

    // finished 3 photos
    mode = 'thank';
    showScreen(thankScreen);
    // stop preview but keep camera (optional): we'll stop to free resources
    stopFrontCamera();

    // emit photos_submit to server (server expects this)
    try {
      socket.emit('photos_submit', { session, viewerId: socket.id, photos });
      logDebug('photos_submit enviado (local) fotos=' + photos.length);
    } catch(e){
      logDebug('Erro emit photos_submit: ' + e);
    }

    try { fim.currentTime = 0; fim.play().catch(()=>{}); } catch(e){}
  }

  // -----------------------------
  // Socket handlers (kept)
  // -----------------------------
  socket.on('connect', () => {
    logDebug('connected to server: ' + socket.id);
    socket.emit('join_session', { session, role: 'viewer' });
    // request cached stream from operator if server has frames (backwards compat)
    socket.emit('request_stream', { session, viewerId: socket.id });
  });

  socket.on('disconnect', (reason) => {
    logDebug('socket disconnected: ' + reason);
  });

  socket.on('stream_frame', ({ session: s, frame }) => {
    // legacy: if operator stream arrives and user is in capturing mode, draw it (but our local preview overrides)
    if (s && s !== session) return;
    if (mode === 'capturing') {
      try {
        // draw operator frame onto canvas (but we are using local preview when camera active)
        if (!localStream) drawFrameFromDataUrl(frame);
      } catch(e){}
    }
  });

  function drawFrameFromDataUrl(dataUrl){
    if (!dataUrl) return;
    const ctx = canvasEl.getContext('2d');
    const img = new Image();
    img.onload = () => {
      canvasEl.width = window.innerWidth;
      canvasEl.height = window.innerHeight;
      const scale = Math.max(canvasEl.width / img.width, canvasEl.height / img.height);
      const w = img.width * scale, h = img.height * scale;
      ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
      ctx.drawImage(img, (canvasEl.width - w)/2, (canvasEl.height - h)/2, w, h);
      canvasEl.style.display = 'block';
    };
    img.onerror = ()=>{};
    img.src = dataUrl;
  }

  // server may send photo_ready targeted to viewer (backwards compat)
  socket.on('photo_ready', ({ index, photo }) => {
    // if operator sends, show it immediately as preview
    if (mode !== 'capturing') {
      photos.push(photo);
      showPhotoPreview(photo);
      return;
    }
    // else dispatch event for other flows
    document.dispatchEvent(new CustomEvent('operator_photo_ready', { detail: { index, photo } }));
  });

  // show QR overlay
  socket.on('show_qr', ({ visualizadorUrl }) => {
    if (!visualizadorUrl) return;
    try {
      QRCode.toCanvas(qrCanvas, visualizadorUrl, { width: 260 }, (err) => {
        if (err) {
          const ctx = qrCanvas.getContext('2d');
          ctx.clearRect(0,0,qrCanvas.width,qrCanvas.height);
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,qrCanvas.width,qrCanvas.height);
          ctx.fillStyle = '#fff'; ctx.font = '12px Arial';
          ctx.fillText('Abrir: ' + visualizadorUrl.substring(0,30), 8, 20);
        }
        qrOverlay.classList.add('visible'); qrOverlay.classList.remove('hidden'); qrOverlay.setAttribute('aria-hidden','false');
      });
    } catch(e){
      const img = new Image();
      img.crossOrigin='anonymous';
      img.onload = ()=> {
        const ctx = qrCanvas.getContext('2d'); ctx.clearRect(0,0,qrCanvas.width,qrCanvas.height); ctx.drawImage(img,0,0,qrCanvas.width,qrCanvas.height);
        qrOverlay.classList.add('visible'); qrOverlay.classList.remove('hidden'); qrOverlay.setAttribute('aria-hidden','false');
      };
      img.onerror = ()=> {
        const ctx = qrCanvas.getContext('2d'); ctx.clearRect(0,0,qrCanvas.width,qrCanvas.height); ctx.fillStyle='#000';ctx.fillRect(0,0,qrCanvas.width,qrCanvas.height);ctx.fillStyle='#fff';ctx.fillText('Abra o link',10,20);
        qrOverlay.classList.add('visible'); qrOverlay.classList.remove('hidden'); qrOverlay.setAttribute('aria-hidden','false');
      };
      img.src = `https://chart.googleapis.com/chart?cht=qr&chs=260x260&chl=${encodeURIComponent(visualizadorUrl)}`;
    }
  });

  socket.on('reset_session', ({ session: s }) => {
    if (s && s !== session) return;
    photos = []; currentPhotoIndex = 0;
    mode = 'idle';
    qrOverlay.classList.remove('visible'); qrOverlay.classList.add('hidden'); qrOverlay.setAttribute('aria-hidden','true');
    stopFrontCamera();
    showScreen(welcomeScreen);
  });

  // -----------------------------
  // UI bindings
  // -----------------------------
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen(); } catch(e){}
    showScreen(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    startBtn.textContent = 'ðŸŽµ Preparando...';
    await inicio.play().catch(()=>{});
    startBtn.disabled = false;
    startBtn.textContent = 'ðŸŽ¬ Iniciar SessÃ£o de Fotos';
    // Start local capture sequence (camera frontal)
    showScreen(null); // hide front screens; show canvas
    try {
      await startLocalCaptureSequence();
    } catch(e){
      logDebug('Erro na sequÃªncia local: ' + (e && e.message ? e.message : e));
      showScreen(welcomeScreen);
    }
  });

  // small helper for debug panel
  function logDebug(msg){
    const t = new Date().toLocaleTimeString();
    debugEl.textContent = `[${t}] ${msg}\n` + debugEl.textContent;
    console.log(msg);
  }

  // expose for debug
  window._cabine = { socket, startLocalCaptureSequence };

  // cleanup on page hide/unload
  window.addEventListener('pagehide', () => { stopFrontCamera(); });
  window.addEventListener('beforeunload', () => { stopFrontCamera(); });

})(); // IIFE end
</script>
</body>
</html>
