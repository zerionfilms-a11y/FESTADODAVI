<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    .hidden { display:none !important; }
    .visible { display:flex !important; }
    button.btn {
      padding:14px 20px;border-radius:12px;border:none;cursor:pointer;font-weight:700;
      background:#ffd600;color:#000;font-size:18px;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
    }
    .big { padding:18px 28px;font-size:20px;border-radius:14px }
    .logo{max-width:160px;margin-bottom:12px;border-radius:8px}
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;transform:scaleX(-1);z-index:0}
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:2}
    #countdown{position:fixed;top:18%;left:0;right:0;text-align:center;font-size:120px;font-weight:800;z-index:40;color:#fff;text-shadow:0 0 30px #000;pointer-events:none}
    #progress{position:fixed;top:10px;left:10px;padding:8px 10px;background:rgba(0,0,0,0.45);border-radius:8px;z-index:60;font-size:14px}
    .modes { display:flex; gap:18px; margin-top:18px }
    .mode-btn { width:110px;height:110px;border-radius:999px;border:none;font-size:36px;display:flex;align-items:center;justify-content:center;cursor:pointer }
    .mode-btn.boom{background:linear-gradient(135deg,#5bd,#07a); color:white}
    .mode-btn.three{background:linear-gradient(135deg,#f4b400,#d18a00); color:white}
    .preview-buttons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:14px;justify-content:center;padding:0 20px;z-index:80}
    .preview-btn{padding:12px 18px;border-radius:10px;border:none;font-weight:700;cursor:pointer;font-size:16px;background:rgba(0,0,0,0.6);color:#fff}
    #qrOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:120;pointer-events:none;opacity:0;transition:opacity .18s}
    #qrOverlay.visible{pointer-events:auto;opacity:1}
    .qr-box{background:#fff;padding:14px;border-radius:12px;color:#000;text-align:center}
    #debugInfo{position:fixed;left:10px;bottom:10px;font-size:11px;color:#ddd;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;z-index:200;max-width:46%}
  </style>
</head>
<body>
  <!-- ENTER FULLSCREEN simple screen -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div style="text-align:center;background:rgba(0,0,0,0.22);padding:18px;border-radius:12px;width:92%;max-width:420px">
      <img src="logo.png" class="logo" alt="Logo" onerror="this.style.display='none'">
      <h1 style="margin:8px 0 6px 0">ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <p style="color:rgba(255,255,255,0.9)">Toque para entrar em tela cheia e comeÃ§ar</p>
      <div style="margin-top:12px">
        <button id="enterFsBtn" class="btn big">ðŸŽ¬ Entrar em Tela Cheia</button>
      </div>
    </div>
  </div>

  <!-- MODE CHOICE: appears immediately after Enter fullscreen -->
  <div id="choiceScreen" class="screen hidden" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <img src="logo.png" class="logo" alt="Logo" onerror="this.style.display='none'">
    <h2 style="margin-top:6px">Escolha o modo</h2>
    <div class="modes" style="margin-top:12px">
      <button id="btnBoom" class="mode-btn boom" title="Boomerang">&infin;</button>
      <button id="btnThree" class="mode-btn three" title="3 Fotos">â˜°</button>
    </div>
    <p style="margin-top:14px;color:rgba(255,255,255,0.9)">Toque no modo desejado para iniciar</p>
  </div>

  <!-- VIDEO & CANVAS for live preview and capture -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>

  <!-- countdown + progress -->
  <div id="countdown"></div>
  <div id="progress" style="display:none"></div>

  <!-- preview screen (Refazer / Continuar) -->
  <div id="previewScreen" class="screen hidden" style="background:rgba(0,0,0,0.9);z-index:70">
    <div style="position:relative;width:100%;height:100%">
      <img id="previewImage" src="" style="width:100%;height:100%;object-fit:contain;display:block">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <!-- thank -->
  <div id="thankScreen" class="screen hidden" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <img src="logo.png" class="logo" alt="Logo" onerror="this.style.display='none'">
    <h2>âœ¨ Obrigado por utilizar a cabine!</h2>
    <p>Espere o operador encerrar a sessÃ£o.</p>
  </div>

  <!-- QR overlay -->
  <div id="qrOverlay"><div class="qr-box"><canvas id="qrCanvas" width="220" height="220"></canvas><div style="font-size:13px">Visualizador gerado</div></div></div>

  <div id="debugInfo">debug</div>

  <!-- sounds -->
  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/* celular.html â€” corrigido:
   - Entrar em tela cheia -> mostra CHOICE (imediato)
   - Usa cÃ¢mera frontal do celular
   - MantÃ©m preview vivo desenhando video->canvas
   - 3 fotos: countdown, preview refazer/continuar, envia photos_submit
   - Boomerang: grava ~2s, gera loop forward+reverse ~15s, preview refazer/continuar, envia boomerang_ready + photo_ready (thumbnail)
*/

(function(){
  // ---------- CONFIG ----------
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app"; // ajuste se precisar
  const socket = io(SERVER_URL, { transports:['websocket','polling'], reconnection:true, path:'/socket.io' });

  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const choiceScreen = document.getElementById('choiceScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');

  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const countdownEl = document.getElementById('countdown');
  const progressEl = document.getElementById('progress');

  const previewScreen = document.getElementById('previewScreen');
  const previewImage = document.getElementById('previewImage');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');

  const thankScreen = document.getElementById('thankScreen');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugEl = document.getElementById('debugInfo');

  const clack = document.getElementById('clack');
  const inicio = document.getElementById('inicio');
  const fim = document.getElementById('fim');

  // state
  let stream = null;
  let mode = null; // 'boom' or 'three'
  let photos = [];
  let currentPhotoData = null;
  let currentPhotoIndex = 0;

  // boomerang params
  const BOOM_SHORT_MS = 2000;
  const BOOM_LOOP_MS = 15000;
  const BOOM_TARGET_W = 720; // reduced for mobile perf
  const BOOM_TARGET_H = Math.round(BOOM_TARGET_W * (6000/3375)); // keep aspect similar

  // helpers
  function show(el){ if(el) { el.classList.remove('hidden'); el.classList.add('visible'); el.style.display='flex'; } }
  function hide(el){ if(el){ el.classList.remove('visible'); el.classList.add('hidden'); el.style.display='none'; } }
  function showScreen(el){
    [enterFs, choiceScreen, previewScreen, thankScreen].forEach(s => hide(s));
    hide(qrOverlay);
    if(el) show(el);
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // continuous draw from video to canvas to avoid frozen frames
  let drawLoopActive = false;
  function startDrawLoop(){
    if(drawLoopActive) return;
    drawLoopActive = true;
    canvasEl.style.display='block';
    function loop(){
      if(!drawLoopActive) return;
      const vw = videoEl.videoWidth || window.innerWidth;
      const vh = videoEl.videoHeight || window.innerHeight;
      canvasEl.width = vw;
      canvasEl.height = vh;
      const ctx = canvasEl.getContext('2d');
      try {
        ctx.save();
        // mirror so user sees self naturally
        ctx.translate(canvasEl.width,0); ctx.scale(-1,1);
        ctx.drawImage(videoEl, 0, 0, canvasEl.width, canvasEl.height);
        ctx.restore();
      } catch(e){}
      requestAnimationFrame(loop);
    }
    loop();
  }
  function stopDrawLoop(){ drawLoopActive = false; canvasEl.style.display='none'; }

  // camera access (front)
  async function ensureFrontCamera(){
    if(stream) return stream;
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
      videoEl.srcObject = stream;
      videoEl.style.display='block';
      videoEl.play().catch(()=>{});
      return stream;
    } catch(e){
      console.error('camera error', e);
      alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera frontal. Verifique permissÃµes e tente novamente.');
      throw e;
    }
  }

  // BUTTON: Enter fullscreen -> immediately show choice (doesn't wait for fullscreen)
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen().catch(()=>{}); } catch(e){}
    // Immediately switch to choice screen (this fixes the "only enters fullscreen but doesn't go to choice" issue)
    showScreen(choiceScreen);
    // try to warm camera (do not block UI)
    ensureFrontCamera().then(() => {
      // draw a live canvas so user sees camera when they choose mode
      startDrawLoop();
    }).catch(()=>{});
    // debug log
    debugLog('Entrou em fullscreen â€” mostrando escolha');
    // notify server (optional)
    if(socket && socket.connected) socket.emit('cell_entered_fullscreen_local', { ts: Date.now() });
  });

  // MODE buttons
  btnThree.addEventListener('click', async ()=> {
    mode = 'three';
    debugLog('Modo escolhido: 3 Fotos');
    // ensure camera ready
    await ensureFrontCamera();
    startDrawLoop();
    photos = [];
    currentPhotoIndex = 0;
    showScreen(null); // hide UI to show live preview
    // small delay then start capture flow
    await sleep(200);
    runThreePhotosFlow();
  });

  btnBoom.addEventListener('click', async ()=> {
    mode = 'boom';
    debugLog('Modo escolhido: Boomerang');
    await ensureFrontCamera();
    startDrawLoop();
    showScreen(null);
    await sleep(200);
    startBoomerangFlow();
  });

  // THREE PHOTOS FLOW
  async function runThreePhotosFlow(){
    try {
      for(let i=0;i<3;i++){
        currentPhotoIndex = i;
        const photo = await captureSinglePhoto(); // includes countdown and capture
        currentPhotoData = photo;
        // show preview
        previewImage.src = photo;
        showScreen(previewScreen);
        // wait decision
        const decision = await waitPreviewDecision();
        if(decision === 'refazer'){ i = i - 1; continue; }
        photos.push(photo);
        hide(previewScreen);
        await sleep(250);
      }
      // finished
      await finalizeThreePhotos();
    } catch(e){
      console.error(e);
      debugLog('Erro no fluxo 3 fotos: ' + (e.message||e));
      showScreen(choiceScreen);
    }
  }

  async function captureSinglePhoto(){
    progressEl.style.display='block'; progressEl.textContent = `${currentPhotoIndex+1}/3`;
    countdownEl.textContent='';
    // 5..1 countdown
    for(let t=5;t>0;t--){
      if(t<=2){
        countdownEl.textContent = 'SORRIA!';
        countdownEl.style.color = '#ffd600';
        if(t===2) { try{ clack.currentTime=0; clack.play().catch(()=>{}); }catch(e){} }
      } else {
        countdownEl.textContent = String(t);
        countdownEl.style.color = '#fff';
      }
      await sleep(1000);
    }
    countdownEl.textContent = '';
    // draw immediate frame to canvas and capture unmirrored image
    canvasEl.width = videoEl.videoWidth || window.innerWidth;
    canvasEl.height = videoEl.videoHeight || window.innerHeight;
    const ctx = canvasEl.getContext('2d');
    // draw mirrored -> unmirror on capture
    ctx.save();
    ctx.translate(canvasEl.width,0); ctx.scale(-1,1);
    ctx.drawImage(videoEl, 0, 0, canvasEl.width, canvasEl.height);
    ctx.restore();
    const data = canvasEl.toDataURL('image/jpeg', 0.95);
    return data;
  }

  // wait preview decision (refazer / continuar)
  function waitPreviewDecision(){
    return new Promise((resolve) => {
      function onRef(){
        refazerBtn.removeEventListener('click', onRef);
        continuarBtn.removeEventListener('click', onCont);
        resolve('refazer');
      }
      function onCont(){
        refazerBtn.removeEventListener('click', onRef);
        continuarBtn.removeEventListener('click', onCont);
        resolve('continuar');
      }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    });
  }

  async function finalizeThreePhotos(){
    // show thank and stop camera draw
    showScreen(thankScreen);
    stopDrawLoop();
    // send photos to server
    if(socket && socket.connected){
      try {
        socket.emit('photos_submit', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, photos });
        debugLog('photos_submit emitido (3 fotos)');
      } catch(e){ debugLog('Erro emit photos_submit: '+(e.message||e)); }
    } else {
      debugLog('Socket nÃ£o conectado â€” photos_submit nÃ£o enviado');
    }
  }

  // BOOMERANG FLOW
  async function startBoomerangFlow(){
    try {
      // small countdown
      progressEl.style.display='block'; progressEl.textContent = 'Preparando Boomerang...';
      for(let t=3;t>0;t--){ countdownEl.textContent = String(t); await sleep(700); }
      countdownEl.textContent=''; progressEl.textContent = 'Gravando...';

      // record short clip cropped to full frame (we'll scale later)
      const shortBlob = await recordShortClip(BOOM_SHORT_MS);
      if(!shortBlob){ throw new Error('Falha ao gravar clipe curto'); }

      progressEl.textContent = 'Processando boomerang...';
      // produce final boomerang (forward+reverse looping) in-memory via canvas + MediaRecorder
      const finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs: BOOM_LOOP_MS, targetW: BOOM_TARGET_W, targetH: BOOM_TARGET_H });
      if(!finalBlob) throw new Error('Falha ao gerar boomerang final');

      // thumbnail
      const thumb = await blobToDataURL(finalBlob, true).catch(()=>null);

      // show preview (play loop) by creating object URL and drawing on canvas (simple preview)
      const url = URL.createObjectURL(finalBlob);
      previewImage.src = url;
      showScreen(previewScreen);

      const decision = await waitPreviewDecision();
      if(decision === 'refazer'){
        URL.revokeObjectURL(url);
        showScreen(choiceScreen);
        return;
      }

      // confirmed: emit boomerang_ready (send ArrayBuffer) and photo_ready thumb
      try {
        const ab = await finalBlob.arrayBuffer();
        socket.emit('boomerang_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, data: ab });
        debugLog('boomerang_ready emitido via socket (ArrayBuffer)');
        if(thumb) socket.emit('photo_ready', { session: (new URLSearchParams(location.search)).get('session') || 'cabine-fixa', index:0, viewerId: socket.id, photo: thumb });
      } catch(e){
        console.error(e);
        debugLog('Erro emit boomerang_ready: ' + (e.message||e));
        // fallback: open blob for manual upload
        const newUrl = URL.createObjectURL(finalBlob);
        window.open(newUrl, '_blank');
      }

      showScreen(thankScreen);
      stopDrawLoop();
      // revoke preview url after a while
      setTimeout(()=>{ try{ URL.revokeObjectURL(url); } catch(e){} }, 30000);

    } catch(e){
      console.error(e);
      debugLog('Boomerang error: ' + (e.message||e));
      showScreen(choiceScreen);
    }
  }

  // record short clip (draw video frames to offscreen canvas -> record)
  async function recordShortClip(durationMs = 2000){
    if(!stream) await ensureFrontCamera();
    // create offscreen canvas sized to video resolution (but limit for perf)
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    // target small record resolution (to reduce size)
    const outW = Math.min(1280, vw);
    const aspect = vh / vw;
    const outH = Math.round(outW * aspect);

    const off = document.createElement('canvas'); off.width = outW; off.height = outH;
    const offCtx = off.getContext('2d');
    const captureStream = off.captureStream(30);
    const recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });
    const chunks = [];
    recorder.ondataavailable = (ev) => { if(ev.data && ev.data.size) chunks.push(ev.data); };
    recorder.start();

    const start = performance.now();
    await new Promise((resolve) => {
      function frame(){
        try {
          // draw mirrored/unmirrored as desired (we draw unmirrored final)
          offCtx.save();
          offCtx.translate(off.width,0); offCtx.scale(-1,1);
          offCtx.drawImage(videoEl, 0, 0, off.width, off.height);
          offCtx.restore();
        } catch(e){}
        if(performance.now() - start < durationMs) requestAnimationFrame(frame);
        else { setTimeout(()=>{ recorder.stop(); resolve(); }, 60); }
      }
      frame();
    });

    await new Promise(r => { recorder.onstop = r; });
    const blob = new Blob(chunks, { type: 'video/webm' });
    return blob;
  }

  // produce boomerang final by playing forward+reverse repeatedly into a canvas and recording it
  async function generateBoomerangFromShortClip(shortBlob, opts = { loopMs:15000, targetW:720, targetH:1280 }){
    const loopMs = opts.loopMs || 15000;
    const targetW = opts.targetW || BOOM_TARGET_W;
    const targetH = opts.targetH || BOOM_TARGET_H;

    const v = document.createElement('video');
    v.muted = true;
    v.playsInline = true;
    v.src = URL.createObjectURL(shortBlob);

    await new Promise((res, rej) => {
      v.onloadedmetadata = () => res();
      v.onerror = (e) => rej(new Error('Erro ao carregar short clip'));
    });

    const canvas = document.createElement('canvas');
    canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    const recStream = canvas.captureStream(30);
    const chunks = [];
    const rec = new MediaRecorder(recStream, { mimeType: 'video/webm;codecs=vp8' });
    rec.ondataavailable = (e)=>{ if(e.data && e.data.size) chunks.push(e.data); };
    rec.start();

    const startTime = performance.now();

    // draw helper (we fill black background)
    function drawFrameFromVideoFrame(){
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      try {
        // fit video into area centered (we'll use full canvas for mobile boomerang)
        const vw = v.videoWidth || 320, vh = v.videoHeight || 240;
        const scale = Math.max(canvas.width / vw, canvas.height / vh);
        const w = vw * scale, h = vh * scale;
        ctx.drawImage(v, 0, 0, vw, vh, (canvas.width - w)/2, (canvas.height - h)/2, w, h);
      } catch(e){}
    }

    // play forward
    async function playForward(){
      return new Promise((res) => {
        v.currentTime = 0;
        v.play().catch(()=>{});
        const tick = () => {
          drawFrameFromVideoFrame();
          if(v.ended || v.currentTime >= v.duration - 0.001){ v.pause(); res(); }
          else requestAnimationFrame(tick);
        };
        tick();
      });
    }

    // play reverse manually
    async function playReverse(){
      return new Promise((res) => {
        v.pause();
        v.currentTime = v.duration;
        function step(){
          v.currentTime = Math.max(0, v.currentTime - (1/30));
          drawFrameFromVideoFrame();
          if(v.currentTime > 0.02) requestAnimationFrame(step);
          else res();
        }
        step();
      });
    }

    while(performance.now() - startTime < loopMs){
      await playForward();
      if(performance.now() - startTime >= loopMs) break;
      await playReverse();
    }

    await sleep(80);
    await new Promise(r => { rec.onstop = r; rec.stop(); });

    const finalBlob = new Blob(chunks, { type: 'video/webm' });
    URL.revokeObjectURL(v.src);
    return finalBlob;
  }

  // blob -> dataURL (optionally extract first frame)
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((res, rej) => {
      if(!firstFrame){
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsDataURL(blob);
      } else {
        const v = document.createElement('video');
        v.muted = true; v.playsInline = true; v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          await sleep(60);
          const c = document.createElement('canvas');
          c.width = v.videoWidth || 640; c.height = v.videoHeight || 480;
          const ctx = c.getContext('2d');
          try { ctx.drawImage(v,0,0,c.width,c.height); res(c.toDataURL('image/jpeg', 0.85)); }
          catch(e){ rej(e); }
          URL.revokeObjectURL(v.src);
        };
        v.onerror = rej;
      }
    });
  }

  // sockets & events
  socket.on('connect', ()=> debugLog('socket connected: ' + socket.id));
  socket.on('disconnect', ()=> debugLog('socket disconnected'));
  socket.on('reset_session', ()=> {
    debugLog('reset_session recebido');
    photos = []; currentPhotoData = null; currentPhotoIndex = 0;
    stopDrawLoop(); showScreen(choiceScreen);
  });

  // send small debug / health
  function debugLog(msg){
    debugEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + debugEl.textContent;
    console.log(msg);
  }

  // final: when 3 photos done, send photos_submit
  // already emitted inside finalizeThreePhotos()

  // initial screen ready
  showScreen(enterFs);
  debugLog('celular.html pronto');

  // expose for debug in console
  window._cabine_mobile = { ensureFrontCamera, startDrawLoop, stopDrawLoop, runThreePhotosFlow, startBoomerangFlow };

})();
</script>
</body>
</html>
