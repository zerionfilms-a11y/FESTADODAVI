<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular (Fotos + Boomerang)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    .hidden{display:none!important}
    .visible{display:flex!important}
    /* Fullscreen entry */
    #enterFsBtn{padding:18px 25px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:300px}
    /* welcome */
    #welcomeCard{background:rgba(255,255,255,0.12);padding:24px;border-radius:14px;text-align:center;max-width:420px;backdrop-filter:blur(8px)}
    .logo{max-width:160px;margin-bottom:14px;border-radius:8px}
    #startBtn{padding:16px 22px;border-radius:12px;border:none;background:#0b84ff;color:#fff;font-weight:800;cursor:pointer;font-size:20px;margin-top:12px;width:80%}
    /* selection */
    .mode-buttons{display:flex;gap:18px;justify-content:center;margin-top:14px}
    .mode-btn{width:96px;height:96px;border-radius:50%;border:none;display:flex;align-items:center;justify-content:center;font-size:30px;cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.45)}
    .mode-btn.boom{background:linear-gradient(135deg,#4f92ff,#0077cc);color:#fff}
    .mode-btn.three{background:linear-gradient(135deg,#ffd54a,#d18a00);color:#111}
    .mode-label{margin-top:8px;font-weight:700;color:#ddd;text-align:center}
    /* preview / camera */
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1;transform:scaleX(-1)} /* mirrored for user */
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:2;pointer-events:none}
    .overlayTop{position:fixed;top:12px;left:12px;z-index:20}
    #progress{position:fixed;top:16px;left:50%;transform:translateX(-50%);font-size:20px;padding:8px 12px;border-radius:10px;background:rgba(0,0,0,0.5);z-index:40}
    #countdown{position:fixed;top:30%;left:0;right:0;text-align:center;font-size:120px;font-weight:800;text-shadow:0 0 30px #000;z-index:40;color:#fff;pointer-events:none}
    #msg{position:fixed;top:50%;left:0;right:0;text-align:center;font-size:22px;font-weight:700;z-index:40;color:#fff;text-shadow:0 0 10px #000}
    /* crop frame (shows exactly area that will be put into moldura) */
    .crop-frame { position: absolute; border: 2px dashed rgba(255,255,255,0.95); pointer-events:none; z-index: 30; box-shadow:0 0 0 20000px rgba(0,0,0,0.25); border-radius:6px;}
    /* preview screen */
    #previewScreen{background:rgba(0,0,0,0.95);z-index:50;padding:0;display:flex;align-items:center;justify-content:center}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
    #previewMedia{width:100%;height:100%;object-fit:contain;display:block}
    .preview-buttons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:14px;justify-content:center;padding:0 20px;z-index:60}
    .preview-btn{padding:12px 18px;border-radius:10px;border:none;font-weight:700;cursor:pointer;font-size:16px;flex:1;max-width:160px;background:rgba(0,0,0,0.7);color:white;backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.12)}
    /* thank */
    #thank{background:rgba(255,255,255,0.12);padding:22px;border-radius:14px;text-align:center;max-width:420px}
    /* QR overlay */
    .qr-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:100; opacity:0; pointer-events:none; transition:opacity 280ms; }
    .qr-overlay.visible { opacity:1; pointer-events:auto; }
    .qr-modal { position:relative; background:rgba(255,255,255,0.98); padding:18px; border-radius:12px; text-align:center; box-shadow:0 10px 30px rgba(0,0,0,0.4); max-width:90%; width:360px; }
    .qr-modal canvas { width:260px; height:260px; display:block;margin:0 auto 12px;background:#fff;border-radius:6px;}
    /* debug */
    #debugInfo {position:fixed;bottom:10px;left:10px;font-size:11px;color:#ddd;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;z-index:120;white-space:pre-line;max-width:46%}
    @media (max-width:480px){ #countdown { font-size:72px } .mode-btn{width:72px;height:72px;font-size:22px} .logo{max-width:120px} }
  </style>
</head>
<body>

  <!-- 1) Enter fullscreen only -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#fff,#f5f5f5);">
    <div style="text-align:center;width:95%;max-width:420px">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="font-size:22px;margin:14px 0;color:#222">üì∏ Cabine Fotogr√°fica</h1>
      <p style="color:#444;margin-bottom:18px">Para melhor experi√™ncia, entre em tela cheia</p>
      <button id="enterFsBtn">üé¨ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- 2) Welcome screen (logo + iniciar sess√£o) -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div id="welcomeCard">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222;margin-bottom:8px">üì∏ Bem-vindo √† Cabine</h2>
      <p style="color:#333;margin-bottom:12px">Toque em Iniciar Sess√£o quando estiver pronto</p>
      <button id="startBtn">‚ñ∂Ô∏è Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- 3) Selection screen appears only after start -->
  <div id="selectionScreen" class="screen hidden" style="background:linear-gradient(135deg,#000,#111)">
    <div style="text-align:center">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="margin-top:6px;margin-bottom:6px">Escolha o modo</h2>
      <div class="mode-buttons" id="modeButtonsArea">
        <div style="text-align:center">
          <button id="btnBoom" class="mode-btn boom" title="Boomerang">&infin;</button>
          <div class="mode-label">Boomerang (Stories)</div>
        </div>
        <div style="text-align:center">
          <button id="btnThree" class="mode-btn three" title="3 Fotos">‚ò∞</button>
          <div class="mode-label">3 Fotos (Impress√£o)</div>
        </div>
      </div>
      <div style="margin-top:18px;color:#ccc;font-size:14px">Use a c√¢mera frontal. Posicione-se dentro do quadro que vai aparecer.</div>
    </div>
  </div>

  <!-- Camera preview canvas/video -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>
  <div id="progress" class="hidden"></div>
  <div id="countdown"></div>
  <div id="msg"></div>
  <div id="cropFrame" class="crop-frame hidden"></div>

  <!-- Preview screen (refazer / continuar) - show image or preview video -->
  <div id="previewScreen" class="screen hidden">
    <div id="previewContainer">
      <!-- this element will be either <img> or <video> depending on preview type -->
      <div id="previewHolder" style="width:100%;height:100%"><img id="previewMedia" src="" alt="Preview" /></div>
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">üîÑ Refazer</button>
        <button id="continuarBtn" class="preview-btn">‚úÖ Continuar</button>
      </div>
    </div>
  </div>

  <!-- Thank you -->
  <div id="thankScreen" class="screen hidden">
    <div id="thank">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222">‚ú® Obrigado por utilizar a cabine!</h2>
      <p style="color:#444">Aguarde enquanto processamos suas fotos.</p>
    </div>
  </div>

  <!-- QR overlay (server -> show_qr) -->
  <div id="qrOverlay" class="qr-overlay" aria-hidden="true">
    <div class="qr-modal">
      <div id="qrTitle" style="font-weight:700;margin-bottom:8px;color:#222">Escaneie o QR para ver suas fotos</div>
      <canvas id="qrCanvas" width="260" height="260"></canvas>
      <div style="font-size:14px;color:#333;margin-top:6px">As fotos ficar√£o dispon√≠veis por 7 dias</div>
    </div>
  </div>

  <div id="debugInfo" style="display:none"></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/* celular.html atualizado ‚Äî corrige preview travado, envia fotos soltas para Index,
   adiciona preview do boomerang antes de envio, usa c√¢mera frontal do celular.
   Backend: https://festadodavi-production-0591.up.railway.app
*/
(function(){
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const socket = io(SERVER_URL, { transports:['polling','websocket'], reconnection:true, path:'/socket.io' });

  // Template / boomerang area (template-based coords)
  const TEMPLATE_W = 3375, TEMPLATE_H = 6000;
  const BOOM_AREA = { x:295, y:272, w:2785, h:4159 }; // suas coords
  const BOOM_TARGET_W = 1080;

  // DOM
  const enterFsEl = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const selectionScreen = document.getElementById('selectionScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');
  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const progressEl = document.getElementById('progress');
  const countdownEl = document.getElementById('countdown');
  const cropFrame = document.getElementById('cropFrame');
  const previewScreen = document.getElementById('previewScreen');
  const previewHolder = document.getElementById('previewHolder');
  const previewMediaImg = document.getElementById('previewMedia');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugInfo = document.getElementById('debugInfo');

  // state
  let session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
  let stream = null;
  let photos = [];
  let previewLoopActive = false;
  let previewRaf = null;

  // helper: show/hide screens
  function showScreen(el){
    [enterFsEl, welcomeScreen, selectionScreen, previewScreen, thankScreen].forEach(s=>{
      if(!s) return;
      s.classList.add('hidden'); s.classList.remove('visible');
    });
    // hide preview/camera UI state
    canvasEl.style.display = 'none';
    videoEl.style.display = 'none';
    cropFrame.classList.add('hidden');
    countdownEl.textContent = '';
    if(el){ el.classList.remove('hidden'); el.classList.add('visible'); }
  }
  showScreen(enterFsEl);

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // debug helper
  function debug(msg){
    if(debugInfo) { debugInfo.style.display='block'; debugInfo.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + debugInfo.textContent; }
    console.log(msg);
  }

  // ---------- SOCKET ----------
  socket.on('connect', ()=> {
    debug('socket conectado: ' + socket.id);
    socket.emit('join_session', { session, role:'viewer' });
  });
  socket.on('disconnect', (r)=> debug('socket desconectado: ' + r));
  socket.on('show_qr', ({ visualizadorUrl }) => {
    if(!visualizadorUrl) return;
    try {
      QRCode.toCanvas(qrCanvas, visualizadorUrl, { width:260 }, (err) => {
        if(err) debug('erro QR: ' + err);
        qrOverlay.classList.add('visible'); qrOverlay.setAttribute('aria-hidden','false');
      });
    } catch(e) {
      qrOverlay.classList.add('visible'); qrOverlay.setAttribute('aria-hidden','false');
    }
  });
  socket.on('reset_session', ({ session: s })=>{
    if(s && s !== session) return;
    photos = [];
    showScreen(welcomeScreen);
    qrOverlay.classList.remove('visible');
    qrOverlay.setAttribute('aria-hidden','true');
  });

  // ---------- UI wiring ----------
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen(); } catch(e){}
    showScreen(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', async () => {
    // move to selection directly (you said welcome can be simple)
    showScreen(selectionScreen);
  });

  btnThree.addEventListener('click', async () => {
    // start three-photo flow (mobile camera only)
    await beginThreePhotosFlow();
  });

  btnBoom.addEventListener('click', async () => {
    await beginBoomerangFlow();
  });

  // ---------- CAMERA / PREVIEW LOOP ----------
  async function ensureFrontCamera(){
    if(stream) return stream;
    const constraints = {
      video: {
        facingMode: { ideal: "user" },
        width: { ideal: 3264 },
        height: { ideal: 1836 }
      },
      audio: false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = stream;
    videoEl.style.display = 'block';
    videoEl.style.transform = 'scaleX(-1)'; // mirror for user
    try { await videoEl.play(); } catch(e){}
    return stream;
  }

  // continuously draw camera into canvas (keeps the preview moving)
  function startPreviewLoop(){
    if(previewLoopActive) return;
    previewLoopActive = true;
    canvasEl.style.display = 'block';
    videoEl.style.display = 'block';
    function step(){
      drawCameraToCanvas();
      previewRaf = requestAnimationFrame(step);
    }
    step();
  }
  function stopPreviewLoop(){
    previewLoopActive = false;
    if(previewRaf) { cancelAnimationFrame(previewRaf); previewRaf = null; }
  }

  // draw current video frame (cover scaling) into canvas
  function drawCameraToCanvas(){
    if(!videoEl || !videoEl.videoWidth) return;
    const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
    canvasEl.width = window.innerWidth;
    canvasEl.height = window.innerHeight;
    const ctx = canvasEl.getContext('2d');
    const scale = Math.max(canvasEl.width / vw, canvasEl.height / vh);
    const w = vw * scale, h = vh * scale;
    const dx = (canvasEl.width - w) / 2;
    const dy = (canvasEl.height - h) / 2;

    // because videoEl is mirrored by CSS, draw mirrored to match user preview
    ctx.save();
    ctx.translate(canvasEl.width, 0);
    ctx.scale(-1, 1);
    // drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh)
    ctx.drawImage(videoEl, 0, 0, vw, vh, canvasEl.width - (dx + w), dy, w, h);
    ctx.restore();

    // compute and draw crop overlay for BOOM_AREA
    const sx = w / vw, sy = h / vh;
    const cx = dx + BOOM_AREA.x * sx;
    const cy = dy + BOOM_AREA.y * sy;
    const cw = BOOM_AREA.w * sx;
    const ch = BOOM_AREA.h * sy;
    cropFrame.style.left = `${cx}px`;
    cropFrame.style.top = `${cy}px`;
    cropFrame.style.width = `${cw}px`;
    cropFrame.style.height = `${ch}px`;
    cropFrame.classList.remove('hidden');
  }

  // ---------- THREE PHOTOS FLOW ----------
  async function beginThreePhotosFlow(){
    try {
      await ensureFrontCamera();
    } catch(e){
      alert('N√£o foi poss√≠vel acessar a c√¢mera frontal: ' + (e.message || e));
      showScreen(selectionScreen);
      return;
    }
    photos = [];
    // show live preview and crop
    startPreviewLoop();
    // small pause so camera warms up
    await sleep(300);
    // capture three photos sequentially
    await captureThreeSequence();
  }

  async function captureThreeSequence(){
    for(let i=0;i<3;i++){
      try {
        // show instruction
        showProgress(`${i+1}/3 ‚Äî Preparando...`);
        const dataUrl = await captureOnePhoto();
        hideProgress();
        // show preview and ask user decision
        const keep = await showPreviewAndDecideImage(dataUrl);
        if(!keep){
          i = i - 1; // redo this index
          continue;
        }
        photos.push(dataUrl); // keep it
      } catch(err){
        debug('Erro captura foto: ' + (err && err.message ? err.message : err));
        i = i - 1;
        await sleep(300);
        continue;
      }
    }

    // finalize: send photos array to server (Index will build montagens)
    try {
      showProgress('Enviando 3 fotos ao operador...');
      // ensure socket connected
      socket.emit('photos_submit', { session, viewerId: socket.id, photos });
      debug('photos_submit emitido com ' + photos.length + ' fotos');
      showScreen(thankScreen);
    } catch(e){
      debug('Erro enviando photos_submit: ' + e);
      alert('Erro enviando fotos para o operador.');
      showScreen(welcomeScreen);
    } finally {
      hideProgress();
      stopPreviewLoop();
    }
  }

  // Capture single photo (full camera resolution), unmirrored saved so operator sees natural orientation.
  async function captureOnePhoto(){
    // countdown
    for(let t=4;t>0;t--){
      countdownEl.textContent = (t>2) ? String(t) : 'SORRIA!';
      await sleep(1000);
    }
    countdownEl.textContent = '';
    // snapshot at camera resolution
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    const c = document.createElement('canvas');
    c.width = vw; c.height = vh;
    const ctx = c.getContext('2d');
    // mirror draw so the saved image matches what the person sees (un-mirrored for operator)
    ctx.save();
    ctx.translate(c.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(videoEl, 0, 0, vw, vh);
    ctx.restore();
    // return jpeg dataURL high quality
    return c.toDataURL('image/jpeg', 0.95);
  }

  // show preview image and ask refazer/continuar -> returns true to keep, false to retake
  function showPreviewAndDecideImage(dataUrl){
    return new Promise((resolve) => {
      // ensure image element used
      previewHolder.innerHTML = ''; // clear
      const img = document.createElement('img');
      img.id = 'previewMediaImg';
      img.src = dataUrl;
      img.style.width = '100%'; img.style.height='100%'; img.style.objectFit='contain';
      previewHolder.appendChild(img);
      showScreen(previewScreen);

      const onRef = () => { cleanup(); resolve(false); };
      const onCont = () => { cleanup(); resolve(true); };

      function cleanup(){
        refazerBtn.removeEventListener('click', onRef);
        continuarBtn.removeEventListener('click', onCont);
      }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    }).then(async (keep) => {
      // after decision, return to live preview
      await sleep(200);
      showScreen(null);
      startPreviewLoop();
      return keep;
    });
  }

  // ---------- BOOMERANG FLOW ----------
  async function beginBoomerangFlow(){
    try {
      await ensureFrontCamera();
    } catch(e){
      alert('N√£o foi poss√≠vel acessar a c√¢mera frontal: ' + (e.message || e));
      showScreen(selectionScreen);
      return;
    }
    // show live preview overlay
    startPreviewLoop();
    await sleep(250);

    // countdown then record short clip 2s
    showProgress('Preparando Boomerang...');
    for(let t=3;t>0;t--){ countdownEl.textContent = String(t); await sleep(700); }
    countdownEl.textContent = '';
    showProgress('Gravando 2s...');
    // ensure preview loop paused while recording? we want video playing; keep preview so user sees motion while recording
    const shortBlob = await recordCroppedShortClip(2000);
    if(!shortBlob){ hideProgress(); alert('Erro ao gravar clipe.'); showScreen(selectionScreen); return; }

    // generate boomerang final (forward+reverse loop ~15s)
    showProgress('Processando Boomerang...');
    // stop preview loop while heavy processing to avoid CPU contention
    stopPreviewLoop();
    const finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs:15000, targetW: BOOM_TARGET_W });
    hideProgress();
    if(!finalBlob){ alert('Erro processando boomerang'); showScreen(selectionScreen); return; }

    // create thumbnail and show preview video to user (allow refazer/continuar)
    const previewUrl = URL.createObjectURL(finalBlob);
    await showPreviewVideoAndDecide(previewUrl);

    // if user continued -> emit boomerang to server + send photo thumbnail + photos_submit for compatibility
    // If user refazer -> go back to selection
    // showPreviewVideoAndDecide already returns decision
    // it also sets window._lastBoomerangBlob for potential re-use
  }

  // record cropped short clip from camera (maps BOOM_AREA to camera pixel coords)
  async function recordCroppedShortClip(msDuration = 2000){
    if(!stream) return null;
    // ensure metadata loaded
    if(!videoEl.videoWidth || !videoEl.videoHeight){
      try { await videoEl.play(); } catch(e){}
    }
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;

    // map template->camera center-cover mapping (approx)
    const scale = Math.max(vw / TEMPLATE_W, vh / TEMPLATE_H);
    const drawW = TEMPLATE_W * scale, drawH = TEMPLATE_H * scale;
    const dx = (vw - drawW) / 2;
    const dy = (vh - drawH) / 2;
    const cropX = Math.max(0, Math.round(dx + BOOM_AREA.x * scale));
    const cropY = Math.max(0, Math.round(dy + BOOM_AREA.y * scale));
    const cropW = Math.max(8, Math.round(BOOM_AREA.w * scale));
    const cropH = Math.max(8, Math.round(BOOM_AREA.h * scale));

    // target output size to keep performance reasonable
    const outW = Math.min(1280, cropW);
    const outH = Math.round(outW * (cropH / cropW));
    const off = document.createElement('canvas');
    off.width = outW; off.height = outH;
    const ctx = off.getContext('2d');

    const captureStream = off.captureStream(30);
    let recorded = [];
    let recorder;
    try {
      recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });
    } catch(e) {
      try { recorder = new MediaRecorder(captureStream); } catch(e){ debug('MediaRecorder not supported'); return null; }
    }
    recorder.ondataavailable = ev => { if(ev.data && ev.data.size) recorded.push(ev.data); };
    recorder.start();

    const start = performance.now();
    await new Promise((resolve) => {
      function frame(){
        try {
          // draw mirrored to match preview feel
          ctx.save();
          ctx.translate(off.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(videoEl, cropX, cropY, cropW, cropH, 0, 0, off.width, off.height);
          ctx.restore();
        } catch(e){}
        if(performance.now() - start < msDuration) {
          requestAnimationFrame(frame);
        } else {
          setTimeout(()=>{ recorder.stop(); resolve(); }, 60);
        }
      }
      frame();
    });

    await new Promise(res => recorder.onstop = res);
    return new Blob(recorded, { type:'video/webm' });
  }

  // generate boomerang by replaying short clip forward+reverse repeatedly, drawing onto canvas under template
  async function generateBoomerangFromShortClip(shortBlob, options = { loopMs:15000, targetW:1080 }){
    const loopMs = options.loopMs || 15000;
    const targetW = options.targetW || 1080;

    // load short clip into video element
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(shortBlob);
    await new Promise((res, rej) => {
      v.onloadedmetadata = () => res();
      v.onerror = () => rej(new Error('Erro ao carregar clipe curto'));
    });

    const aspect = (v.videoWidth && v.videoHeight) ? (v.videoWidth / v.videoHeight) : (9/16);
    const targetH = Math.round(targetW / aspect);
    const canvas = document.createElement('canvas');
    canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // try load template (bomerang.png) - if missing continue with black bg
    const template = new Image(); template.crossOrigin = 'anonymous'; template.src = 'bomerang.png';
    await new Promise(r => { template.onload = r; template.onerror = r; });

    const stream = canvas.captureStream(30);
    let chunks = [];
    let rec;
    try {
      rec = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp8' });
    } catch(e){
      try { rec = new MediaRecorder(stream); } catch(e){ debug('MediaRecorder failed'); return null; }
    }
    rec.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
    rec.start();

    const startTime = performance.now();

    async function playForward(){
      return new Promise(res => {
        v.currentTime = 0; v.play().catch(()=>{});
        const onTick = () => {
          drawFrame();
          if(v.ended || v.currentTime >= v.duration - 0.001) { v.pause(); v.removeEventListener('timeupdate', onTick); res(); }
        };
        v.addEventListener('timeupdate', onTick);
        drawFrame();
      });
    }

    async function playReverse(){
      return new Promise(res => {
        v.pause();
        v.currentTime = v.duration;
        function step(){
          const stepSec = 1/30;
          v.currentTime = Math.max(0, v.currentTime - stepSec);
          drawFrame();
          if(v.currentTime > 0.02) requestAnimationFrame(step);
          else res();
        }
        step();
      });
    }

    function drawFrame(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(template && template.complete && template.naturalWidth) ctx.drawImage(template, 0, 0, TEMPLATE_W, TEMPLATE_H, 0,0, canvas.width, canvas.height);
      else { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); }
      try { ctx.drawImage(v, 0,0, v.videoWidth, v.videoHeight, 0,0, canvas.width, canvas.height); } catch(e){}
    }

    while(performance.now() - startTime < loopMs) {
      await playForward();
      if(performance.now() - startTime >= loopMs) break;
      await playReverse();
    }

    await sleep(120);
    await new Promise(res => { rec.onstop = res; rec.stop(); });

    return new Blob(chunks, { type: 'video/webm' });
  }

  // show preview video and ask user refazer/continuar; returns boolean choice
  async function showPreviewVideoAndDecide(videoUrl){
    return new Promise((resolve) => {
      previewHolder.innerHTML = '';
      const v = document.createElement('video');
      v.id = 'previewVideo';
      v.src = videoUrl;
      v.controls = true;
      v.loop = true;
      v.autoplay = true;
      v.style.width = '100%'; v.style.height='100%'; v.style.objectFit = 'contain';
      previewHolder.appendChild(v);
      showScreen(previewScreen);

      const onRef = () => { cleanup(); resolve(false); };
      const onCont = async () => {
        cleanup();
        // send video blob to server now
        try {
          showProgress('Enviando boomerang...');
          const blob = await fetch(videoUrl).then(r => r.blob());
          // send thumbnail too
          const thumb = await blobToDataURL(blob, true).catch(()=>null);
          // convert blob -> ArrayBuffer for binary socket emission
          const ab = await blob.arrayBuffer();
          // emit: metadata first, then binary as second arg (socket.io supports binary)
          socket.emit('boomerang_ready', { session, viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, size: ab.byteLength }, ab);
          if(thumb) socket.emit('photo_ready', { session, index: 0, viewerId: socket.id, photo: thumb });
          // also keep compatibility with photo flow
          socket.emit('photos_submit', { session, viewerId: socket.id, photos: [thumb] });
          debug('boomerang_ready emitido (binary) size=' + (ab.byteLength || 'unknown'));
        } catch(e){
          debug('Erro ao enviar boomerang: ' + e);
          // fallback: open blob in new tab
          window.open(videoUrl, '_blank');
        } finally {
          hideProgress();
        }
        resolve(true);
      };

      function cleanup(){
        refazerBtn.removeEventListener('click', onRef);
        continuarBtn.removeEventListener('click', onCont);
      }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    }).then(async (choice) => {
      // after decision, if refazer go back to selection screen; if continue show thank
      if(!choice){
        showScreen(selectionScreen);
        // re-enable preview loop
        await sleep(200);
        startPreviewLoop();
        return false;
      } else {
        showScreen(thankScreen);
        return true;
      }
    });
  }

  // convert blob to dataURL or extract first frame as thumbnail
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((res, rej) => {
      if(!firstFrame){
        const reader = new FileReader();
        reader.onload = () => res(reader.result);
        reader.onerror = rej;
        reader.readAsDataURL(blob);
      } else {
        const v = document.createElement('video');
        v.muted = true; v.playsInline = true;
        v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try {
            v.currentTime = Math.min(0.05, v.duration/2 || 0.05);
            await sleep(80);
            const c = document.createElement('canvas');
            c.width = v.videoWidth || 640; c.height = v.videoHeight || 360;
            const ctx = c.getContext('2d');
            ctx.drawImage(v, 0,0,c.width,c.height);
            res(c.toDataURL('image/jpeg', 0.85));
          } catch(e){ rej(e); }
        };
        v.onerror = rej;
      }
    });
  }

  // UI helpers
  function showProgress(text){ progressEl.classList.remove('hidden'); progressEl.textContent = text || ''; }
  function hideProgress(){ progressEl.classList.add('hidden'); progressEl.textContent = ''; }

  // Expose small debug helpers
  window._cabine_mobile = {
    socket,
    ensureFrontCamera,
    startPreviewLoop,
    stopPreviewLoop
  };

})(); // IIFE
</script>
</body>
</html>
