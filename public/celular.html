<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotográfica — Celular (Virtual Webcam)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#ffffff;color:#222222;overflow:hidden}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:18px;z-index:800}
    .card{display:flex;flex-direction:column;align-items:center;justify-content:center;width:96%;max-width:720px;padding:28px;border-radius:12px;background:#fff;border:1px solid rgba(0,0,0,0.06)}
    .logo{height:96px;margin-bottom:18px}
    h1{font-size:26px;margin-bottom:8px}
    p{font-size:16px;color:#444;margin-bottom:12px;text-align:center}
    .btn{padding:14px 20px;border-radius:10px;border:none;font-weight:700;cursor:pointer}
    .btn--brand{background:#b07e09;color:#fff}
    .btn--light{background:#fff;color:#222;border:1px solid rgba(0,0,0,0.06)}
    #videoEl{display:none;width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
    #remoteImg{width:100%;max-width:720px;height:auto;border-radius:8px;border:1px solid rgba(0,0,0,0.06);display:none;background:#000;object-fit:cover}
    #countdownOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:900;pointer-events:none;}
    #countdownText{color:#ffffff;font-size:140px;font-weight:900;text-shadow:0 6px 24px rgba(0,0,0,0.55)}
    #previewScreen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:920;background:rgba(0,0,0,0.88)}
    #previewImage{max-width:100%;max-height:100%;object-fit:contain;border-radius:6px}
    .preview-controls{position:absolute;bottom:28px;left:0;right:0;display:flex;justify-content:center;gap:16px;z-index:930}
    #debugInfo{position:fixed;bottom:10px;left:10px;font-size:12px;color:#666;background:rgba(255,255,255,0.95);padding:6px;border-radius:6px;z-index:950;border:1px solid rgba(0,0,0,0.06)}
  </style>
</head>
<body>
  <div id="enterScreen" class="screen">
    <div class="card">
      <img src="/public/logo1.png" class="logo" alt="Logo" onerror="this.onerror=null;this.src='/public/logo.png'">
      <h1>📸 Cabine Fotográfica</h1>
      <p>Entre em tela cheia e clique para iniciar sessão. Se o operador estiver transmitindo webcam, você verá a imagem durante a contagem.</p>
      <button id="enterFsBtn" class="btn btn--brand">🎬 Entrar em Tela Cheia</button>
      <button id="startBtn" class="btn btn--brand" style="margin-top:10px">🎬 Iniciar Sessão de Fotos</button>
    </div>
  </div>

  <!-- camada de vídeo remoto / local -->
  <div id="videoLayer" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100">
    <video id="videoEl" autoplay playsinline muted></video>
    <img id="remoteImg" src="" alt="Stream do Operador">
  </div>

  <div id="countdownOverlay" aria-hidden="true">
    <div id="countdownText">3</div>
  </div>

  <div id="previewScreen" style="display:none">
    <img id="previewImage" src="" alt="Preview">
    <div class="preview-controls">
      <button id="refazerBtn" class="btn btn--light">🔄 Refazer</button>
      <button id="continuarBtn" class="btn btn--brand">✅ Continuar</button>
    </div>
  </div>

  <div id="thankScreen" class="screen" style="display:none">
    <div class="card">
      <img src="/public/logo1.png" class="logo" alt="Logo" onerror="this.onerror=null;this.src='/public/logo.png'">
      <h1>✨ Obrigado por utilizar a cabine!</h1>
      <p>Aguarde o operador encerrar a sessão.</p>
    </div>
  </div>

  <div id="debugInfo"></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

  <script>
    // URL do servidor (mantenha a sua)
    const SERVER_URL = "https://festadodavi.onrender.com";
    const socket = io(SERVER_URL, { transports:["websocket"], reconnection:true, reconnectionAttempts:5, reconnectionDelay:1000, timeout:20000, forceNew:false, withCredentials:true });

    // elements
    const enterScreen = document.getElementById('enterScreen');
    const enterFsBtn = document.getElementById('enterFsBtn');
    const startBtn = document.getElementById('startBtn');
    const videoEl = document.getElementById('videoEl');
    const remoteImg = document.getElementById('remoteImg');
    const countdownOverlay = document.getElementById('countdownOverlay');
    const countdownText = document.getElementById('countdownText');
    const previewScreen = document.getElementById('previewScreen');
    const previewImage = document.getElementById('previewImage');
    const refazerBtn = document.getElementById('refazerBtn');
    const continuarBtn = document.getElementById('continuarBtn');
    const thankScreen = document.getElementById('thankScreen');
    const debugInfo = document.getElementById('debugInfo');
    const clack = document.getElementById('clack'), inicio = document.getElementById('inicio'), fim = document.getElementById('fim');

    const params = new URLSearchParams(location.search);
    const session = params.get('session');

    let localStream = null;
    let usingRemoteStream = false;
    let lastRemoteFrame = null; // last received frame dataURL
    let photos = [], currentPhotoIndex = 0, currentPhotoData = null;

    // show debug
    setInterval(()=>{ debugInfo.textContent = `Sessão: ${session||'none'} | RemoteStream: ${usingRemoteStream ? 'on' : 'off'} | Fotos: ${photos.length}` }, 800);

    // socket connection
    socket.on('connect', () => { if(session) socket.emit('cell_connected'); });

    // operator -> envia frames via 'stream_frame' events (server may relay)
    socket.on('stream_frame', ({ session: s, frame }) => {
      if(s !== session) return;
      // receive frame (dataURL) and display it
      lastRemoteFrame = frame;
      // show remote image element
      remoteImg.src = frame;
      remoteImg.style.display = 'block';
      videoEl.style.display = 'none';
      usingRemoteStream = true;
    });

    // if server or operator sends stop_stream for this session
    socket.on('stop_stream', ({ session: s }) => { if(s !== session) return stopUsingRemoteStream(); });

    function stopUsingRemoteStream(){
      usingRemoteStream = false;
      lastRemoteFrame = null;
      remoteImg.style.display = 'none';
      // show video element again (if camera available)
      if(localStream){ videoEl.style.display = 'block'; }
    }

    async function startLocalCameraFallback(){
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio:false });
        videoEl.srcObject = localStream; videoEl.style.display = 'block'; await videoEl.play();
      } catch(e){
        // fallback: no camera available - keep remote stream only
        console.warn('camera fallback failed', e);
      }
    }

    // fullscreen button
    enterFsBtn.addEventListener('click', async () => {
      try{ await document.documentElement.requestFullscreen(); }catch(e){}
    });

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true; startBtn.textContent = '🎵 Preparando...';
      await inicio.play().catch(()=>{});
      startBtn.disabled = false; startBtn.textContent = '🎬 Iniciar Sessão de Fotos';
      // before running capture we request operator stream (if any)
      if(session) {
        socket.emit('want_stream', { session }); // asks operator to send frames to this session
      }
      // ensure we have a fallback to local camera
      await startLocalCameraFallback();
      currentPhotoIndex = 0;
      photos = [];
      await runCaptureSequence();
    });

    // capture flow (uses remote frame if available during countdown)
    function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

    async function captureSinglePhoto(){
      // ask for stream while counting
      if(session) socket.emit('want_stream', { session });

      // show countdown (transparent background, just big number)
      countdownOverlay.style.display = 'flex';
      let c = 5;
      countdownText.textContent = String(c);
      await sleep(120);
      for(; c>0; c--){
        if(c <= 2){
          countdownText.textContent = 'SORRIA!';
          countdownText.style.color = '#ffffff';
          if(c===2){ clack.currentTime = 0; clack.play().catch(()=>{}); }
        } else {
          countdownText.textContent = String(c);
          countdownText.style.color = '#ffffff';
        }
        await sleep(1000);
      }
      // hide countdown to avoid black frame in some devices
      countdownOverlay.style.display = 'none';
      // stop requesting stream just before capture
      if(session) socket.emit('stop_stream', { session });

      // If we received remote frame(s), use the last one as the photo
      if(lastRemoteFrame){
        return lastRemoteFrame;
      }

      // otherwise use local camera capture
      const canvas = document.createElement('canvas');
      canvas.width = videoEl.videoWidth || 1280;
      canvas.height = videoEl.videoHeight || 720;
      const ctx = canvas.getContext('2d');
      ctx.translate(canvas.width, 0); ctx.scale(-1,1); // mirror
      ctx.drawImage(videoEl,0,0,canvas.width,canvas.height);
      return canvas.toDataURL('image/jpeg', 0.8);
    }

    function showPhotoPreview(photoData){
      previewImage.src = photoData;
      previewScreen.style.display = 'flex';
      previewScreen.classList.remove('hidden');
    }

    async function runCaptureSequence(){
      if(currentPhotoIndex >= 3){
        // finished all
        showThank();
        sendPhotosToServer();
        return;
      }
      currentPhotoData = await captureSinglePhoto();
      showPhotoPreview(currentPhotoData);
    }

    refazerBtn.addEventListener('click', async () => {
      // allow requesting stream again next capture
      previewScreen.style.display = 'none';
      currentPhotoData = null;
      await runCaptureSequence();
    });

    continuarBtn.addEventListener('click', async () => {
      photos.push(currentPhotoData);
      currentPhotoIndex++;
      previewScreen.style.display = 'none';
      currentPhotoData = null;
      await runCaptureSequence();
    });

    function showThank(){
      // hides everything and shows thank screen
      document.getElementById('enterScreen').style.display = 'none';
      previewScreen.style.display = 'none';
      thankScreen.style.display = 'flex';
      // play finish sound
      fim.play().catch(()=>{});
    }

    // Robust sendPhotosToServer: mantém lógica de retry semelhante ao original do celular
    function sendPhotosToServer(){
      if(session && photos.length>0){
        const sendPhotosWithRetry=(attempt=1,maxAttempts=5)=>{
          if(socket.connected){
            socket.emit('photos_from_cell',{ session, photos, attempt, totalAttempts:maxAttempts });
            logDebug(`📤 photos_from_cell emitted (attempt ${attempt})`);
            if(attempt<maxAttempts){ setTimeout(()=>sendPhotosWithRetry(attempt+1,maxAttempts),1500); }
          }else if(attempt<maxAttempts){
            // tenta reconexão automática
            setTimeout(()=>sendPhotosWithRetry(attempt+1,maxAttempts),2000);
          } else {
            console.warn('❌ Falha ao enviar fotos após tentativas');
          }
        };
        sendPhotosWithRetry();
      }
    }

    // if operator or server asks to reset session
    socket.on('reset_session', ()=>{ location.reload(); });

    // debug helper
    function logDebug(msg){
      if(debugInfo) {
        const ts = new Date().toLocaleTimeString();
        debugInfo.textContent += `[${ts}] ${msg}\n`;
        debugInfo.scrollTop = debugInfo.scrollHeight;
      }
      console.log(msg);
    }

    // initial message
    logDebug(`Sessão: ${session||'none'}. Ao iniciar, este dispositivo pedirá ao operador o stream (want_stream).`);
  </script>
</body>
</html>
