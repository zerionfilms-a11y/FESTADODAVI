<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular (Fotos + Boomerang)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    .hidden{display:none!important}
    .visible{display:flex!important}
    /* Fullscreen entry */
    #enterFsBtn{padding:18px 25px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:300px}
    /* welcome */
    #welcomeCard{background:rgba(255,255,255,0.12);padding:24px;border-radius:14px;text-align:center;max-width:420px;backdrop-filter:blur(8px)}
    .logo{max-width:160px;margin-bottom:14px;border-radius:8px}
    #startBtn{padding:16px 22px;border-radius:12px;border:none;background:#0b84ff;color:#fff;font-weight:800;cursor:pointer;font-size:20px;margin-top:12px;width:80%}
    /* selection */
    .mode-buttons{display:flex;gap:18px;justify-content:center;margin-top:14px}
    .mode-btn{width:96px;height:96px;border-radius:50%;border:none;display:flex;align-items:center;justify-content:center;font-size:30px;cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.45)}
    .mode-btn.boom{background:linear-gradient(135deg,#4f92ff,#0077cc);color:#fff}
    .mode-btn.three{background:linear-gradient(135deg,#ffd54a,#d18a00);color:#111}
    .mode-label{margin-top:8px;font-weight:700;color:#ddd;text-align:center}
    /* preview / camera */
    #videoEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:1;transform:scaleX(-1)} /* mirrored for user */
    #canvasEl{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;display:none;z-index:2;pointer-events:none}
    .overlayTop{position:fixed;top:12px;left:12px;z-index:20}
    #progress{position:fixed;top:16px;left:50%;transform:translateX(-50%);font-size:20px;padding:8px 12px;border-radius:10px;background:rgba(0,0,0,0.5);z-index:40}
    #countdown{position:fixed;top:30%;left:0;right:0;text-align:center;font-size:120px;font-weight:800;text-shadow:0 0 30px #000;z-index:40;color:#fff;pointer-events:none}
    #msg{position:fixed;top:50%;left:0;right:0;text-align:center;font-size:22px;font-weight:700;z-index:40;color:#fff;text-shadow:0 0 10px #000}
    /* crop frame (shows exactly area that will be put into moldura) */
    .crop-frame { position: absolute; border: 2px dashed rgba(255,255,255,0.95); pointer-events:none; z-index: 30; box-shadow:0 0 0 20000px rgba(0,0,0,0.25); border-radius:6px;}
    /* preview screen */
    #previewScreen{background:rgba(0,0,0,0.95);z-index:50;padding:0;display:flex;align-items:center;justify-content:center}
    #previewContainer{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
    #previewImage{width:100%;height:100%;object-fit:contain;display:block}
    .preview-buttons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:14px;justify-content:center;padding:0 20px;z-index:60}
    .preview-btn{padding:12px 18px;border-radius:10px;border:none;font-weight:700;cursor:pointer;font-size:16px;flex:1;max-width:160px;background:rgba(0,0,0,0.7);color:white;backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.12)}
    /* thank */
    #thank{background:rgba(255,255,255,0.12);padding:22px;border-radius:14px;text-align:center;max-width:420px}
    /* QR overlay */
    .qr-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:100; opacity:0; pointer-events:none; transition:opacity 280ms; }
    .qr-overlay.visible { opacity:1; pointer-events:auto; }
    .qr-modal { position:relative; background:rgba(255,255,255,0.98); padding:18px; border-radius:12px; text-align:center; box-shadow:0 10px 30px rgba(0,0,0,0.4); max-width:90%; width:360px; }
    .qr-modal canvas { width:260px; height:260px; display:block;margin:0 auto 12px;background:#fff;border-radius:6px;}
    /* debug */
    #debugInfo {position:fixed;bottom:10px;left:10px;font-size:11px;color:#ddd;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;z-index:120;white-space:pre-line;max-width:46%}
    @media (max-width:480px){ #countdown { font-size:72px } .mode-btn{width:72px;height:72px;font-size:22px} .logo{max-width:120px} }
  </style>
</head>
<body>

  <!-- 1) Enter fullscreen only -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#fff,#f5f5f5);">
    <div style="text-align:center;width:95%;max-width:420px">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="font-size:22px;margin:14px 0;color:#222">üì∏ Cabine Fotogr√°fica</h1>
      <p style="color:#444;margin-bottom:18px">Para melhor experi√™ncia, entre em tela cheia</p>
      <button id="enterFsBtn">üé¨ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- 2) Welcome screen (logo + iniciar sess√£o) -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div id="welcomeCard">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222;margin-bottom:8px">üì∏ Bem-vindo √† Cabine</h2>
      <p style="color:#333;margin-bottom:12px">Toque em Iniciar Sess√£o quando estiver pronto</p>
      <button id="startBtn">‚ñ∂Ô∏è Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- 3) Selection screen appears only after start -->
  <div id="selectionScreen" class="screen hidden" style="background:linear-gradient(135deg,#000,#111)">
    <div style="text-align:center">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="margin-top:6px;margin-bottom:6px">Escolha o modo</h2>
      <div class="mode-buttons" id="modeButtonsArea">
        <div style="text-align:center">
          <button id="btnBoom" class="mode-btn boom" title="Boomerang">&infin;</button>
          <div class="mode-label">Boomerang (Stories)</div>
        </div>
        <div style="text-align:center">
          <button id="btnThree" class="mode-btn three" title="3 Fotos">‚ò∞</button>
          <div class="mode-label">3 Fotos (Impress√£o)</div>
        </div>
      </div>
      <div style="margin-top:18px;color:#ccc;font-size:14px">Use a c√¢mera frontal. Posicione-se dentro do quadro que vai aparecer.</div>
    </div>
  </div>

  <!-- Camera preview canvas/video -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>
  <div id="progress" class="hidden"></div>
  <div id="countdown"></div>
  <div id="msg"></div>
  <div id="cropFrame" class="crop-frame hidden"></div>

  <!-- Preview screen (refazer / continuar) -->
  <div id="previewScreen" class="screen hidden">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview da foto">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">üîÑ Refazer</button>
        <button id="continuarBtn" class="preview-btn">‚úÖ Continuar</button>
      </div>
    </div>
  </div>

  <!-- Thank you -->
  <div id="thankScreen" class="screen hidden">
    <div id="thank">
      <img src="logo1.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222">‚ú® Obrigado por utilizar a cabine!</h2>
      <p style="color:#444">Aguarde enquanto processamos suas fotos.</p>
    </div>
  </div>

  <!-- QR overlay (server -> show_qr) -->
  <div id="qrOverlay" class="qr-overlay" aria-hidden="true">
    <div class="qr-modal">
      <div id="qrTitle" style="font-weight:700;margin-bottom:8px;color:#222">Escaneie o QR para ver suas fotos</div>
      <canvas id="qrCanvas" width="260" height="260"></canvas>
      <div style="font-size:14px;color:#333;margin-top:6px">As fotos ficar√£o dispon√≠veis por 7 dias</div>
    </div>
  </div>

  <div id="debugInfo" style="display:none"></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/* celular.html completo
   - Fluxo:
     enterFs -> welcome -> selection -> chosen flow (three photos OR boomerang)
   - Usa apenas c√¢mera frontal do celular para capturas.
   - Socket -> SERVER_URL
*/
(function(){
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const socket = io(SERVER_URL, { transports:['polling','websocket'], reconnection:true, path:'/socket.io' });

  // Template / boomerang area (template-based coords)
  const TEMPLATE_W = 3375, TEMPLATE_H = 6000;
  // Area provided (as you specified earlier). We'll map center-crop.
  const BOOM_AREA = { x:295, y:272, w:2785, h:4159 };

  // DOM
  const enterFsEl = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const selectionScreen = document.getElementById('selectionScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');
  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const countdownEl = document.getElementById('countdown');
  const progressEl = document.getElementById('progress');
  const msgEl = document.getElementById('msg');
  const cropFrame = document.getElementById('cropFrame');
  const previewScreen = document.getElementById('previewScreen');
  const previewImage = document.getElementById('previewImage');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugInfo = document.getElementById('debugInfo');

  // state
  let session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
  let mode = null; // 'three' or 'boom'
  let stream = null;
  let photos = [];
  let currentIndex = 0;
  let waitingForOperator = false;

  // helper to show/hide screens
  function showScreen(el){
    [enterFsEl, welcomeScreen, selectionScreen, previewScreen, thankScreen].forEach(s=>{
      if(!s) return;
      s.classList.add('hidden');
      s.classList.remove('visible');
    });
    // hide camera preview by default
    videoEl.style.display = 'none';
    canvasEl.style.display = 'none';
    cropFrame.classList.add('hidden');
    if(el){ el.classList.remove('hidden'); el.classList.add('visible'); }
  }
  showScreen(enterFsEl);

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // Socket events
  socket.on('connect', ()=> {
    debug('socket conectado: ' + socket.id);
    socket.emit('join_session', { session, role:'viewer' });
  });
  socket.on('disconnect', (r)=> debug('socket desconectado: ' + r));
  socket.on('show_qr', ({ visualizadorUrl }) => {
    if(!visualizadorUrl) return;
    try {
      QRCode.toCanvas(qrCanvas, visualizadorUrl, { width:260 }, (err) => {
        if(err) debug('erro QR: ' + err);
        qrOverlay.classList.add('visible'); qrOverlay.setAttribute('aria-hidden','false');
      });
    } catch(e) {
      qrOverlay.classList.add('visible'); qrOverlay.setAttribute('aria-hidden','false');
    }
  });
  socket.on('reset_session', ({ session: s })=>{
    if(s && s !== session) return;
    // reset UI to welcome
    photos = []; currentIndex = 0; mode = null;
    showScreen(welcomeScreen);
    qrOverlay.classList.remove('visible'); qrOverlay.setAttribute('aria-hidden','true');
  });

  // UI wiring
  enterFsBtn.addEventListener('click', async ()=>{
    try { await document.documentElement.requestFullscreen(); } catch(e){}
    // after entering fullscreen, go to welcome screen
    showScreen(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', async ()=>{
    // play sound if available
    try { document.getElementById('inicio').currentTime = 0; document.getElementById('inicio').play().catch(()=>{}); } catch(e){}
    // move to selection screen (buttons appear only now)
    showScreen(selectionScreen);
  });

  // user selects a mode on selection screen
  btnThree.addEventListener('click', async ()=>{
    mode = 'three';
    await beginThreePhotosFlow();
  });
  btnBoom.addEventListener('click', async ()=>{
    mode = 'boom';
    await beginBoomerangFlow();
  });

  // ensure front camera (high resolution) - no explicit limit to 600x400
  async function ensureFrontCamera(){
    if(stream) return stream;
    const constraints = {
      video: {
        facingMode: { ideal: "user" },
        width: { ideal: 3264 }, // try to request high res
        height: { ideal: 1836 }
      },
      audio: false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = stream;
    // Show mirrored preview so user sees themself naturally
    videoEl.style.display = 'block';
    videoEl.style.transform = 'scaleX(-1)';
    try { await videoEl.play(); } catch(e){}
    return stream;
  }

  // draw camera frame to full-screen canvas (used in preview/crop overlay)
  function drawCameraToCanvas(options = {}) {
    const ctx = canvasEl.getContext('2d');
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    canvasEl.width = window.innerWidth;
    canvasEl.height = window.innerHeight;
    // compute cover scaling of video into canvas (center crop)
    const scale = Math.max(canvasEl.width / vw, canvasEl.height / vh);
    const w = vw * scale, h = vh * scale;
    const dx = (canvasEl.width - w) / 2;
    const dy = (canvasEl.height - h) / 2;
    ctx.save();
    ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
    // Because videoEl is mirrored (CSS), draw flipped to keep preview consistent
    ctx.translate(canvasEl.width, 0);
    ctx.scale(-1, 1);
    // drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh)
    // Use the full video frame
    ctx.drawImage(videoEl, 0, 0, vw, vh, canvasEl.width - (dx + w), dy, w, h);
    ctx.restore();
  }

  // Map TEMPLATE BOOM_AREA to canvas coords for overlay - assumes template covers full camera frame with center-cover
  function computeCropOnCanvas() {
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    const cw = canvasEl.width, ch = canvasEl.height;
    if(!vw || !vh) return null;
    const scale = Math.max(cw / vw, ch / vh);
    const w = vw * scale, h = vh * scale;
    const dx = (cw - w) / 2;
    const dy = (ch - h) / 2;
    const sx = w / vw;
    // Map template coords -> canvas coords (we assume template sized like vw x vh)
    const cx = dx + BOOM_AREA.x * sx;
    const cy = dy + BOOM_AREA.y * (h / vh);
    const cwRect = BOOM_AREA.w * sx;
    const chRect = BOOM_AREA.h * (h / vh);
    return { x: Math.round(cx), y: Math.round(cy), w: Math.round(cwRect), h: Math.round(chRect) };
  }

  // Show crop overlay
  function showCropOverlay() {
    canvasEl.style.display = 'block';
    drawCameraToCanvas();
    const rect = computeCropOnCanvas();
    if(rect) {
      cropFrame.style.left = rect.x + 'px';
      cropFrame.style.top = rect.y + 'px';
      cropFrame.style.width = rect.w + 'px';
      cropFrame.style.height = rect.h + 'px';
      cropFrame.classList.remove('hidden');
    } else {
      cropFrame.classList.add('hidden');
    }
  }

  // PHOTOS FLOW
  async function beginThreePhotosFlow(){
    // prepare camera
    try {
      await ensureFrontCamera();
    } catch(e){
      alert('N√£o foi poss√≠vel acessar a c√¢mera frontal: ' + (e.message || e));
      showScreen(selectionScreen);
      return;
    }
    photos = [];
    currentIndex = 0;
    // show camera with overlay (so they see framing)
    canvasEl.style.display = 'block';
    videoEl.style.display = 'block';
    showCropOverlay();
    // small pause so user sees framing
    await sleep(350);
    // start capture sequence (3)
    await captureThreeSequence();
  }

  async function captureThreeSequence(){
    for(let i=0;i<3;i++){
      try {
        const photoData = await captureOnePhoto(i);
        photos.push(photoData);
        // show preview and wait decision
        const keep = await showPreviewAndDecide(photoData);
        if(!keep){
          // user chose refazer: decrement i and continue (replace)
          i = i - 1;
          photos.pop();
          continue;
        }
        // else continue to next
      } catch(err){
        console.warn('capture error', err);
        // try again same index
        i = i - 1;
        await sleep(400);
        continue;
      }
    }
    // all photos done
    // send to server
    showProgress('Enviando fotos...');
    try {
      socket.emit('photos_submit', { session, viewerId: socket.id, photos });
      showScreen(thankScreen);
    } catch(e){
      console.error(e);
      alert('Erro enviando fotos');
      showScreen(welcomeScreen);
    } finally {
      hideProgress();
    }
  }

  // Capture a single photo from the video stream.
  // We capture at the camera's native resolution (videoWidth/videoHeight) and mirror it
  async function captureOnePhoto(index){
    // countdown: 5..1 but last 2 show "SORRIA!"
    progressEl.classList.remove('hidden');
    for(let t=5;t>0;t--){
      if(t<=2){
        countdownEl.textContent = 'SORRIA!';
      } else {
        countdownEl.textContent = String(t);
      }
      // small sound on last beep
      if(t===2){
        try { document.getElementById('clack').currentTime = 0; document.getElementById('clack').play().catch(()=>{}); } catch(e){}
      }
      await sleep(1000);
    }
    countdownEl.textContent = '';
    // draw a frame at full resolution
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;
    const c = document.createElement('canvas');
    c.width = vw;
    c.height = vh;
    const ctx = c.getContext('2d');
    // Mirror horizontally so preview and final match user's expectation
    ctx.save();
    ctx.translate(c.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(videoEl, 0, 0, vw, vh);
    ctx.restore();
    // toDataURL full quality
    const dataUrl = c.toDataURL('image/jpeg', 0.95);
    return dataUrl;
  }

  // show preview and wait for user to refazer or continuar
  function showPreviewAndDecide(dataUrl){
    return new Promise((resolve) => {
      previewImage.src = dataUrl;
      showScreen(previewScreen);
      refazerBtn.onclick = () => { resolve(false); };
      continuarBtn.onclick = () => { resolve(true); };
    }).then(async (r) => {
      // after decision go back to camera preview
      // small delay to avoid flash
      await sleep(150);
      // show camera preview again (if still needed)
      canvasEl.style.display = 'block';
      videoEl.style.display = 'block';
      showCropOverlay();
      return r;
    });
  }

  // BOOMERANG FLOW
  async function beginBoomerangFlow(){
    try {
      await ensureFrontCamera();
    } catch(e){
      alert('N√£o foi poss√≠vel acessar a c√¢mera frontal: ' + (e.message || e));
      showScreen(selectionScreen);
      return;
    }
    // show preview with crop frame
    canvasEl.style.display = 'block';
    videoEl.style.display = 'block';
    showCropOverlay();
    await sleep(250);
    // countdown 3s before recording
    progressEl.classList.remove('hidden');
    progressEl.textContent = 'Preparando Boomerang...';
    for(let t=3;t>0;t--){
      countdownEl.textContent = String(t);
      await sleep(700);
    }
    countdownEl.textContent = '';
    progressEl.textContent = 'Gravando...';
    // record short clip of 2000ms cropping to BOOM area mapped to camera
    const shortBlob = await recordCroppedShortClip(2000);
    if(!shortBlob){
      alert('Erro ao gravar clipe');
      showScreen(selectionScreen);
      return;
    }
    // thumbnail for preview
    const thumb = await blobToDataURL(shortBlob, true).catch(()=>null);
    // generate final boomerang (forward+reverse loop) ~15s
    progressEl.textContent = 'Processando Boomerang...';
    const finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs:15000 });
    if(!finalBlob){
      alert('Erro ao processar boomerang');
      showScreen(selectionScreen);
      return;
    }
    // emit to server
    try {
      const arr = await finalBlob.arrayBuffer();
      socket.emit('boomerang_ready', { session, viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, data: arr });
      if(thumb) socket.emit('photo_ready', { session, index: 0, viewerId: socket.id, photo: thumb });
      socket.emit('photos_submit', { session, viewerId: socket.id, photos: [thumb] });
    } catch(e){
      console.error('emit boomerang error', e);
      // fallback: open blob for manual download
      const url = URL.createObjectURL(finalBlob);
      window.open(url, '_blank');
    }
    progressEl.textContent = 'Boomerang pronto!';
    await sleep(800);
    showScreen(thankScreen);
  }

  // record a short clipped clip: crop mapped area from camera -> offscreen canvas -> MediaRecorder
  async function recordCroppedShortClip(msDuration = 2000){
    if(!stream) return null;
    // ensure video metadata ready
    if(!videoEl.videoWidth || !videoEl.videoHeight){
      try { await videoEl.play(); } catch(e){}
    }
    const vw = videoEl.videoWidth || 1280;
    const vh = videoEl.videoHeight || 720;

    // Map template->camera center-cover mapping similar to computeCropOnCanvas but in camera pixel space
    // Strategy: compute how template (TEMPLATE_W x TEMPLATE_H) would be scaled to camera resolution vw x vh with cover
    const scale = Math.max(vw / TEMPLATE_W, vh / TEMPLATE_H);
    const drawW = TEMPLATE_W * scale, drawH = TEMPLATE_H * scale;
    const dx = (vw - drawW) / 2;
    const dy = (vh - drawH) / 2;
    // Map BOOM_AREA onto camera pixel coordinates
    const cropX = Math.max(0, Math.round(dx + BOOM_AREA.x * scale));
    const cropY = Math.max(0, Math.round(dy + BOOM_AREA.y * scale));
    const cropW = Math.max(8, Math.round(BOOM_AREA.w * scale));
    const cropH = Math.max(8, Math.round(BOOM_AREA.h * scale));

    // target out size (keep reasonable)
    const outW = Math.min(1280, cropW);
    const outH = Math.round(outW * (cropH / cropW));

    const off = document.createElement('canvas');
    off.width = outW;
    off.height = outH;
    const ctx = off.getContext('2d');

    const captureStream = off.captureStream(30);
    let recorded = [];
    let recorder;
    try {
      recorder = new MediaRecorder(captureStream, { mimeType: 'video/webm;codecs=vp8' });
    } catch(e) {
      try { recorder = new MediaRecorder(captureStream); } catch(e){ return null; }
    }
    recorder.ondataavailable = ev => { if(ev.data && ev.data.size) recorded.push(ev.data); };
    recorder.start();

    const start = performance.now();
    await new Promise((resolve) => {
      function frame(){
        try {
          // draw current video frame cropping camera pixels cropX/cropY/cropW/cropH -> scale to outW/outH
          // Note: videoEl is mirrored by CSS; drawImage reads the raw pixels (not mirrored), so we mirror in canvas to match preview
          ctx.save();
          ctx.translate(off.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(videoEl, cropX, cropY, cropW, cropH, 0, 0, off.width, off.height);
          ctx.restore();
        } catch(e){}
        if(performance.now() - start < msDuration){
          requestAnimationFrame(frame);
        } else {
          setTimeout(()=>{ recorder.stop(); resolve(); }, 80);
        }
      }
      frame();
    });

    await new Promise(res => recorder.onstop = res);
    return new Blob(recorded, { type:'video/webm' });
  }

  // generate boomerang from short clip: play forward+reverse to canvas with optional template underlay
  async function generateBoomerangFromShortClip(shortBlob, opts = { loopMs:15000, targetW:1080 }){
    const loopMs = opts.loopMs || 15000;
    const targetW = opts.targetW || 1080;

    // load short clip into video element
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(shortBlob);

    await new Promise((res, rej) => {
      v.onloadedmetadata = () => res();
      v.onerror = () => rej(new Error('erro load short'));
    });

    // canvas sized targetW x targetH keeping short clip aspect ratio
    const aspect = (v.videoWidth && v.videoHeight) ? (v.videoWidth / v.videoHeight) : (16/9);
    const targetH = Math.round(targetW / aspect);

    const canvas = document.createElement('canvas');
    canvas.width = targetW;
    canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // try to load boomerang template (bomerang.png) if exists and draw it beneath
    const template = new Image();
    template.crossOrigin = 'anonymous';
    template.src = 'bomerang.png';
    await new Promise(res => { template.onload = res; template.onerror = res; });

    const stream = canvas.captureStream(30);
    let chunks = [];
    let rec;
    try {
      rec = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp8' });
    } catch(e){
      try { rec = new MediaRecorder(stream); } catch(e){ return null; }
    }
    rec.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
    rec.start();

    const startTime = performance.now();

    // forward playback
    const playForward = () => {
      return new Promise(res => {
        v.currentTime = 0;
        v.play().catch(()=>{});
        const onTime = () => {
          drawFrame();
          if(v.ended || v.currentTime >= v.duration - 0.001) {
            v.pause();
            v.removeEventListener('timeupdate', onTime);
            res();
          }
        };
        v.addEventListener('timeupdate', onTime);
        drawFrame();
      });
    };

    // reverse playback by stepping frames backwards
    const playReverse = () => {
      return new Promise(res => {
        v.pause();
        v.currentTime = v.duration || 0;
        function step(){
          // estimate step
          const stepSec = 1/30;
          v.currentTime = Math.max(0, v.currentTime - stepSec);
          drawFrame();
          if(v.currentTime > 0.02) requestAnimationFrame(step);
          else res();
        }
        step();
      });
    };

    function drawFrame(){
      // draw template background scaled to canvas if available
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(template && template.complete && template.naturalWidth){
        // scale template from TEMPLATE_WxTEMPLATE_H to canvas size
        ctx.drawImage(template, 0, 0, TEMPLATE_W, TEMPLATE_H, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      }
      try {
        // draw current frame of short clip centered/cover into canvas
        ctx.drawImage(v, 0, 0, v.videoWidth, v.videoHeight, 0, 0, canvas.width, canvas.height);
      } catch(e){}
    }

    // loop forward+reverse until loopMs elapsed
    while(performance.now() - startTime < loopMs){
      await playForward();
      if(performance.now() - startTime >= loopMs) break;
      await playReverse();
    }

    // stop recorder
    await sleep(120);
    await new Promise(res => { rec.onstop = res; rec.stop(); });

    return new Blob(chunks, { type:'video/webm' });
  }

  // convert blob to dataURL (or extract first frame)
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((res, rej) => {
      if(!firstFrame){
        const reader = new FileReader();
        reader.onload = () => res(reader.result);
        reader.onerror = rej;
        reader.readAsDataURL(blob);
      } else {
        const v = document.createElement('video');
        v.muted = true; v.playsInline = true;
        v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try {
            v.currentTime = Math.min(0.05, v.duration/2 || 0.05);
            await sleep(80);
            const c = document.createElement('canvas');
            c.width = v.videoWidth || 640; c.height = v.videoHeight || 360;
            const ctx = c.getContext('2d');
            ctx.drawImage(v, 0, 0, c.width, c.height);
            res(c.toDataURL('image/jpeg', 0.85));
          } catch(e){ rej(e); }
        };
        v.onerror = rej;
      }
    });
  }

  // preview helper
  function showPreview(dataUrl){
    previewImage.src = dataUrl;
    showScreen(previewScreen);
  }

  // progress helper
  function showProgress(text){ progressEl.classList.remove('hidden'); progressEl.textContent = text || ''; }
  function hideProgress(){ progressEl.classList.add('hidden'); progressEl.textContent = ''; }

  // debug
  function debug(msg){ if(!debugInfo) return; debugInfo.style.display='block'; debugInfo.textContent = new Date().toLocaleTimeString() + ' ‚Äî ' + msg + '\n' + debugInfo.textContent; console.log(msg); }

  // Expose debug on window (optional)
  window._cabine_mobile = { socket, ensureFrontCamera, captureOnePhoto };

})(); // IIFE
</script>
</body>
</html>
