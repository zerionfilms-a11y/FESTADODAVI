<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:18px}
    .card{background:rgba(0,0,0,0.35);padding:16px;border-radius:12px;text-align:center;width:95%;max-width:420px}
    .logo{max-width:160px;margin-bottom:12px}
    button{cursor:pointer;border:none;border-radius:10px;padding:12px 16px;font-weight:700}
    #enterFsBtn{background:#ffd600;color:#000}
    #startBtn{background:#fff;color:#0b84ff}
    .mode-btn{flex:1;padding:12px 10px;border-radius:12px}
    .boom-btn{background:linear-gradient(135deg,#5bd,#07a);color:#fff}
    .three-btn{background:linear-gradient(135deg,#f4b400,#d18a00);color:#fff}
    .mode-buttons{display:flex;gap:12px;margin-top:12px}

    /* camera and canvas */
    #videoEl{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:10;display:none;transform:rotate(90deg) scaleX(-1);} 
    /* rotate to treat device in landscape: we'll draw frames correctly on canvas */
    #canvasEl{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:20;display:none}
    #countdown{position:fixed;top:20%;left:0;right:0;text-align:center;font-size:100px;font-weight:800;z-index:90;text-shadow:0 0 20px #000}
    #progress{position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:95;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px}

    /* preview overlay */
    #previewScreen{position:fixed;inset:0;background:rgba(0,0,0,0.92);z-index:200;display:none;align-items:center;justify-content:center;flex-direction:column;padding:12px}
    #previewVideo{max-width:92%;max-height:66%;border-radius:8px;background:#000}
    #previewImage{max-width:92%;max-height:66%;border-radius:8px}
    .preview-controls{position:fixed;left:0;right:0;bottom:18px;display:flex;gap:12px;justify-content:center;z-index:210}
    .preview-btn{padding:12px 18px;border-radius:10px;font-weight:800}
    #refazerBtn{background:#e74c3c;color:#fff}
    #continuarBtn{background:#2ecc71;color:#fff}

    #debugInfo{position:fixed;left:8px;bottom:8px;background:rgba(255,255,255,0.05);padding:6px;border-radius:6px;font-size:12px;z-index:999}
    .recording-indicator{position:fixed;top:12px;left:12px;z-index:999;color:#fff;background:rgba(0,0,0,0.4);padding:6px;border-radius:8px;display:flex;gap:8px;align-items:center}
    .dot{width:10px;height:10px;border-radius:50%;background:#f44336;box-shadow:0 0 8px rgba(244,67,54,0.6)}
    .hidden{display:none !important}
    .visible{display:flex !important}
  </style>
</head>
<body>
  <!-- 1) Only fullscreen prompt -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div class="card">
      <img src="logo.png" class="logo" alt="logo" onerror="this.style.display='none'">
      <h2>üì∏ Cabine Fotogr√°fica</h2>
      <p style="margin-top:8px">Escaneou o QR? Entre em tela cheia para come√ßar.</p>
      <div style="margin-top:12px">
        <button id="enterFsBtn">üé¨ Entrar em Tela Cheia</button>
      </div>
    </div>
  </div>

  <!-- 2) Welcome (logo + start) -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div class="card">
      <img src="logo.png" class="logo" alt="logo" onerror="this.style.display='none'">
      <h2>üì∏ Pronto para iniciar?</h2>
      <p style="margin:8px 0">Clique em iniciar para escolher o modo</p>
      <button id="startBtn">üé¨ Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- 3) Choose mode -->
  <div id="chooseScreen" class="screen hidden" style="background:linear-gradient(135deg,#001e3c,#0b84ff)">
    <div class="card">
      <img src="logo.png" class="logo" alt="logo" onerror="this.style.display='none'">
      <h3>Escolha o modo</h3>
      <div class="mode-buttons" style="margin-top:12px">
        <button id="modeBoom" class="mode-btn boom-btn">üéûÔ∏è Boomerang</button>
        <button id="modeThree" class="mode-btn three-btn">üì∑ 3 Fotos</button>
      </div>
    </div>
  </div>

  <!-- Live camera (we rotate video element to handle landscape capture properly) -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>
  <div id="countdown"></div>
  <div id="progress" class="hidden"></div>
  <div id="debugInfo"></div>

  <!-- Preview overlay with controls always visible over video -->
  <div id="previewScreen" class="hidden" role="dialog" aria-modal="true">
    <video id="previewVideo" playsinline controls style="display:none"></video>
    <img id="previewImage" style="display:none" alt="preview">
    <div class="preview-controls">
      <button id="refazerBtn" class="preview-btn">üîÑ Refazer</button>
      <button id="continuarBtn" class="preview-btn">‚úÖ Continuar</button>
    </div>
  </div>

  <div id="thankScreen" class="screen hidden">
    <div class="card">
      <h2>‚ú® Obrigado!</h2>
      <p>Espere o operador processar ou verificar o QR no index.</p>
    </div>
  </div>

  <div class="recording-indicator hidden" id="recIndicator"><span class="dot"></span><div>GRAVANDO</div></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/*
  celular.html ‚Äî vers√£o com boomerang real (forward+reverse loop at√© BOOM_FINAL_MS),
  preview com bot√µes vis√≠veis, grava√ß√£o horizontal e ajustes de performance.
  Ajuste SERVER_URL e SESSION de acordo com sua instala√ß√£o.
*/

(async function(){
  const SERVER_URL = "https://agoraequeeuquerover-production.up.railway.app"; // ajuste se necess√°rio
  const socket = io(SERVER_URL, { transports:['websocket','polling'], path:'/socket.io' });

  // Configura√ß√µes do boomerang
  const SHORT_MS = 2000;      // dura√ß√£o do clipe curto gravado (2s)
  const BOOM_FINAL_MS = 15000; // dura√ß√£o final do boomerang (15s)
  const CAPTURE_WIDTH = 720;  // largura para grava√ß√£o/performance (horizontal)
  const CAPTURE_HEIGHT = 1280; // altura ‚Äî we'll flip orientation if needed

  // DOM
  const $ = id => document.getElementById(id);
  const enterFs = $('enterFs'), enterFsBtn = $('enterFsBtn');
  const welcomeScreen = $('welcomeScreen'), startBtn = $('startBtn');
  const chooseScreen = $('chooseScreen'), modeBoom = $('modeBoom'), modeThree = $('modeThree');
  const videoEl = $('videoEl'), canvasEl = $('canvasEl'), countdownEl = $('countdown'), progressEl = $('progress');
  const previewScreen = $('previewScreen'), previewVideo = $('previewVideo'), previewImage = $('previewImage');
  const refazerBtn = $('refazerBtn'), continuarBtn = $('continuarBtn');
  const thankScreen = $('thankScreen');
  const debugInfo = $('debugInfo'), recIndicator = $('recIndicator');
  const clack = $('clack'), inicio = $('inicio'), fim = $('fim');

  const SESSION = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';

  let stream = null;
  let photos = [];
  let currentPhoto = null;

  // helpers UI
  function showScreen(el){
    [enterFs, welcomeScreen, chooseScreen, previewScreen, thankScreen].forEach(s=>{
      if(!s) return;
      s.classList.add('hidden'); s.style.display='none';
    });
    videoEl.style.display='none'; canvasEl.style.display='none'; countdownEl.textContent=''; progressEl.classList.add('hidden');
    if(el){ el.classList.remove('hidden'); el.style.display='flex'; }
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  setInterval(()=>{ debugInfo.textContent = `sess:${SESSION} | socket:${socket.connected?'online':'offline'}` }, 800);

  // Start state
  showScreen(enterFs);

  // -------- camera helpers (landscape capture) ----------
  async function startCamera(){
    if(stream) return stream;
    try {
      // ask for front camera; use ideal not exact for compatibility
      const constraints = {
        video: {
          facingMode: { ideal: "user" },
          width: { ideal: CAPTURE_HEIGHT },   // note: we request rotated sizes for landscape handling
          height: { ideal: CAPTURE_WIDTH },
        },
        audio: false
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream;
      // For consistent capture we rotate video element visually to landscape (mobile rotated)
      videoEl.style.display = 'block';
      await videoEl.play().catch(()=>{});
      return stream;
    } catch (err) {
      console.error('startCamera err', err);
      alert('N√£o foi poss√≠vel acessar a c√¢mera. Verifique permiss√µes.');
      throw err;
    }
  }

  function stopCamera(){
    if(stream){
      try{ stream.getTracks().forEach(t=>t.stop()); }catch(e){}
    }
    stream = null;
    try{ videoEl.pause(); videoEl.srcObject = null; }catch(e){}
    videoEl.style.display='none';
  }

  // Countdown helper (shows numbers or SORRIA)
  async function runCountdown(sec=3, playClack=false){
    progressEl.classList.remove('hidden');
    for(let t=sec;t>0;t--){
      if(t<=2){
        countdownEl.textContent = 'SORRIA!';
        if(playClack && t===2){ try{ clack.currentTime=0; clack.play().catch(()=>{}); }catch(e){}}
      } else {
        countdownEl.textContent = String(t);
      }
      await sleep(1000);
    }
    countdownEl.textContent = '';
    progressEl.classList.add('hidden');
  }

  // Capture single photo into dataURL (unmirror so preview looks natural)
  async function capturePhoto(){
    await startCamera();
    videoEl.style.display='block';
    await runCountdown(5, true);

    // draw to canvas oriented horizontally
    // We'll draw rotated frames so user holds device horizontal while preview remains correct.
    const vw = videoEl.videoWidth || CAPTURE_HEIGHT;
    const vh = videoEl.videoHeight || CAPTURE_WIDTH;

    // We want horizontal capture: ensure canvas has width>height
    const cw = Math.max(vw, vh);
    const ch = Math.min(vw, vh);
    canvasEl.width = cw; canvasEl.height = ch;
    const ctx = canvasEl.getContext('2d');

    // draw mirrored (flip horizontally) so final image matches user expectation
    ctx.save();
    ctx.translate(cw, 0); ctx.scale(-1, 1);
    // draw video rotated if needed (video element has been rotated visually), drawImage will map frames correctly
    ctx.drawImage(videoEl, 0, 0, cw, ch);
    ctx.restore();

    const dataUrl = canvasEl.toDataURL('image/jpeg', 0.92);
    return dataUrl;
  }

  // Show image preview overlay (with buttons visible)
  function showImagePreview(dataUrl){
    previewVideo.style.display='none';
    previewVideo.src = '';
    previewImage.style.display='block';
    previewImage.src = dataUrl;
    previewScreen.style.display='flex';
    previewScreen.classList.remove('hidden');
  }

  // -------- Boomerang implementation ----------
  // 1) record SHORT_MS clip from videoEl using offscreen canvas
  async function recordShortClip(ms=SHORT_MS){
    await startCamera();
    // prepare offscreen canvas with reduced resolution for performance (landscape)
    // capture width: CAPTURE_HEIGHT x CAPTURE_WIDTH is what we asked earlier, but to reduce load:
    const outW = 640; // smaller width for mobile-friendly performance
    const outH = 360; // horizontal clip (landscape)
    const off = document.createElement('canvas');
    off.width = outW; off.height = outH;
    const ctx = off.getContext('2d');

    const streamCap = off.captureStream(24);
    const recorded = [];
    const recorder = new MediaRecorder(streamCap, { mimeType: 'video/webm;codecs=vp8' });
    recorder.ondataavailable = e => { if(e.data && e.data.size) recorded.push(e.data); };
    recorder.start();

    const start = performance.now();
    await new Promise((res) => {
      function frame(){
        try {
          // draw current video frame scaled to outW/outH (fit cover)
          ctx.save();
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,outW,outH);
          // draw video into canvas scaled
          ctx.drawImage(videoEl, 0, 0, outW, outH);
          ctx.restore();
        } catch(e){}
        if(performance.now() - start < ms) requestAnimationFrame(frame);
        else setTimeout(()=>{ recorder.stop(); res(); }, 80);
      }
      frame();
    });
    await new Promise(r => recorder.onstop = r);
    return new Blob(recorded, { type: 'video/webm' });
  }

  // 2) generate final boomerang by playing short clip forward+reverse repeatedly until BOOM_FINAL_MS
  async function makeBoomerangFromShort(shortBlob, finalMs = BOOM_FINAL_MS){
    // load short clip into a video element (hidden)
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true; v.src = URL.createObjectURL(shortBlob);
    await new Promise((res, rej) => { v.onloadedmetadata = () => res(); v.onerror = (e)=>rej(e); });

    // use canvas sized to small preview to minimize CPU
    const targetW = 640, targetH = 360;
    const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // set up recorder
    const s = canvas.captureStream(24);
    const chunks = [];
    const rec = new MediaRecorder(s, { mimeType: 'video/webm;codecs=vp8' });
    rec.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
    rec.start();

    function drawFrame(){
      try {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(v, 0, 0, v.videoWidth, v.videoHeight, 0, 0, canvas.width, canvas.height);
      } catch(e){}
    }

    // helpers to play forward and reverse
    async function playForward(){
      return new Promise(res => {
        v.currentTime = 0;
        v.play().catch(()=>{});
        const onTick = () => {
          drawFrame();
          if(v.ended || v.currentTime >= v.duration - 0.001){
            v.pause();
            v.removeEventListener('timeupdate', onTick);
            res();
          }
        };
        v.addEventListener('timeupdate', onTick);
        drawFrame();
      });
    }
    async function playReverse(){
      return new Promise(res => {
        v.pause();
        v.currentTime = v.duration;
        function step(){
          const stepMs = 1000/24;
          v.currentTime = Math.max(0, v.currentTime - (stepMs/1000));
          drawFrame();
          if(v.currentTime > 0.02) requestAnimationFrame(step);
          else res();
        }
        step();
      });
    }

    const tStart = performance.now();
    // loop forward+reverse until time elapsed
    while(performance.now() - tStart < finalMs){
      await playForward();
      if(performance.now() - tStart >= finalMs) break;
      await playReverse();
    }

    // stop and return blob
    await sleep(120);
    await new Promise(r => { rec.onstop = r; rec.stop(); });
    const finalBlob = new Blob(chunks, { type: 'video/webm' });
    try{ URL.revokeObjectURL(v.src); }catch(e){}
    return finalBlob;
  }

  // preview helpers (ensuring buttons visible)
  function openVideoPreview(blob){
    previewImage.style.display='none';
    previewImage.src='';
    previewVideo.style.display='block';
    previewVideo.src = URL.createObjectURL(blob);
    previewVideo.controls = true;
    previewVideo.loop = true; // loop for preview
    previewScreen.style.display='flex';
    previewScreen.classList.remove('hidden');
    // ensure buttons are visible (they are fixed in CSS)
  }
  function openImagePreview(dataUrl){
    previewVideo.style.display='none';
    previewVideo.src='';
    previewImage.style.display='block';
    previewImage.src = dataUrl;
    previewScreen.style.display='flex';
    previewScreen.classList.remove('hidden');
  }
  function closePreview(){
    try{ previewVideo.pause(); URL.revokeObjectURL(previewVideo.src); }catch(e){}
    previewVideo.src = '';
    previewImage.src = '';
    previewScreen.style.display='none';
    previewScreen.classList.add('hidden');
  }

  // send boomerang binary (ArrayBuffer) to server
  async function sendBoomerang(blob){
    try {
      progressEl.textContent = 'Enviando boomerang...'; progressEl.classList.remove('hidden');
      const buf = await blob.arrayBuffer();
      socket.emit('boomerang_binary', { session: SESSION, viewerId: socket.id, filename: `boom_${Date.now()}.webm`, data: buf });
      // also send a thumbnail
      try {
        const thumb = await extractFirstFrameAsDataUrl(blob);
        if(thumb) socket.emit('photo_ready', { session: SESSION, index: 0, viewerId: socket.id, photo: thumb });
      } catch(e){}
      progressEl.classList.add('hidden');
    } catch(err){
      console.error('sendBoomerang err', err);
      progressEl.classList.add('hidden');
    }
  }

  // extract first frame of video blob for thumbnail
  async function extractFirstFrameAsDataUrl(blob){
    return new Promise((res, rej) => {
      const v = document.createElement('video');
      v.muted = true; v.playsInline = true;
      v.src = URL.createObjectURL(blob);
      v.onloadeddata = async () => {
        try {
          v.currentTime = 0.02;
          await sleep(60);
          const c = document.createElement('canvas'); c.width = v.videoWidth || 320; c.height = v.videoHeight || 180;
          const ctx = c.getContext('2d'); ctx.drawImage(v, 0, 0, c.width, c.height);
          const d = c.toDataURL('image/jpeg', 0.8);
          res(d);
          URL.revokeObjectURL(v.src);
        } catch(e){ rej(e); }
      };
      v.onerror = (e) => rej(e);
    });
  }

  // -------- 3 photos flow ----------
  async function takeThreePhotosFlow(){
    photos = [];
    try {
      for(let i=0;i<3;i++){
        await startCamera();
        videoEl.style.display='block';
        const data = await capturePhoto();
        currentPhoto = data;
        openImagePreview(data);
        const choice = await new Promise(res => {
          const onRef = ()=>{ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); res('refazer'); };
          const onCont = ()=>{ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); res('continuar'); };
          refazerBtn.addEventListener('click', onRef);
          continuarBtn.addEventListener('click', onCont);
        });
        closePreview();
        if(choice === 'refazer'){ i--; continue; }
        photos.push(currentPhoto);
      }
      // after 3 photos, send to server (server will create montagens and QR)
      stopCamera();
      showScreen(thankScreen);
      if(socket.connected) socket.emit('photos_submit', { session: SESSION, viewerId: socket.id, photos });
      else { socket.connect(); setTimeout(()=>socket.emit('photos_submit', { session: SESSION, viewerId: socket.id, photos }), 1000); }
    } catch(err){
      console.error('3photos err', err);
      alert('Erro ao tirar fotos: '+(err.message||err));
      stopCamera();
      showScreen(welcomeScreen);
    }
  }

  // -------- boomerang flow ----------
  async function boomerangFlow(){
    try {
      await startCamera();
      videoEl.style.display='block';
      await runCountdown(3, false);

      // show recording indicator
      recIndicator.classList.remove('hidden');

      // record short clip
      const shortBlob = await recordShortClip(SHORT_MS);
      recIndicator.classList.add('hidden');

      if(!shortBlob) throw new Error('Erro gravando curto');

      // generate boomerang by forward+reverse loops
      progressEl.textContent = 'Processando boomerang...'; progressEl.classList.remove('hidden');
      const finalBoom = await makeBoomerangFromShort(shortBlob, BOOM_FINAL_MS);
      progressEl.classList.add('hidden');

      if(!finalBoom) throw new Error('Erro processando boomerang');

      // preview final boomerang (loop)
      openVideoPreview(finalBoom);

      // wait decision
      const choice = await new Promise(res => {
        const onRef = ()=>{ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); res('refazer'); };
        const onCont = ()=>{ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); res('continuar'); };
        refazerBtn.addEventListener('click', onRef);
        continuarBtn.addEventListener('click', onCont);
      });

      closePreview();
      if(choice === 'refazer'){ showScreen(chooseScreen); return; }

      // send to server
      stopCamera();
      showScreen(thankScreen);
      await sendBoomerang(finalBoom);

    } catch(err){
      console.error('boomerangFlow err', err);
      alert('Erro bumerangue: '+(err.message||err));
      stopCamera();
      showScreen(welcomeScreen);
    }
  }

  // -------- UI wiring ----------
  enterFsBtn.addEventListener('click', async ()=>{
    try{ await document.documentElement.requestFullscreen(); }catch(e){}
    showScreen(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session: SESSION, viewerId: socket.id });
  });

  startBtn.addEventListener('click', async ()=>{
    showScreen(chooseScreen);
  });

  modeThree.addEventListener('click', async ()=>{
    // 3 photos flow
    showScreen(null);
    await takeThreePhotosFlow();
  });

  modeBoom.addEventListener('click', async ()=>{
    showScreen(null);
    await boomerangFlow();
  });

  // socket events basic
  socket.on('connect', ()=>{ socket.emit('join_session', { session: SESSION, role: 'viewer' }); });
  socket.on('reset_session', ()=>{ stopCamera(); showScreen(welcomeScreen); });
  socket.on('show_qr', ({ visualizadorUrl })=>{
    // server may send visualizador url -> open new tab so user sees QR or visualizador
    if(visualizadorUrl) try { window.open(visualizadorUrl, '_blank'); } catch(e){}
  });

  // expose for debug
  window._cell = { startCamera, stopCamera };

})(); // IIFE end
</script>
</body>
</html>
