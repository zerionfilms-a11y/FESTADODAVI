<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine Fotogr√°fica ‚Äî Celular (Fotos + Boomerang)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    .hidden{display:none!important}
    .visible{display:flex!important}
    /* Buttons & cards */
    #enterFsBtn{padding:18px 25px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:20px;margin:15px;width:90%;max-width:300px}
    #startBtn{padding:14px 20px;border-radius:12px;border:none;background:#0b84ff;color:#fff;font-weight:800;cursor:pointer;font-size:18px;margin-top:12px}
    .logo{max-width:140px;margin-bottom:12px;border-radius:8px}
    .mode-buttons{display:flex;gap:18px;justify-content:center;margin-top:14px}
    .mode-btn{width:92px;height:92px;border-radius:50%;border:none;display:flex;align-items:center;justify-content:center;font-size:30px;cursor:pointer}
    .mode-btn.boom{background:linear-gradient(135deg,#4f92ff,#0077cc);color:#fff}
    .mode-btn.three{background:linear-gradient(135deg,#ffd54a,#d18a00);color:#111}
    /* Camera and preview */
    #videoEl{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:1;transform:scaleX(-1)}
    #canvasEl{position:fixed;inset:0;z-index:2;display:none;pointer-events:none}
    #cropFrame{position:absolute;border:3px dashed rgba(255,255,255,0.95);z-index:30;border-radius:8px;box-shadow:0 0 0 20000px rgba(0,0,0,0.25);pointer-events:none}
    #countdown{position:fixed;top:24%;left:0;right:0;text-align:center;font-size:120px;font-weight:900;z-index:60;color:#fff;text-shadow:0 0 40px #000}
    #recDot{position:fixed;top:14px;left:14px;padding:8px 12px;border-radius:999px;background:rgba(0,0,0,0.5);z-index:60;color:#fff;display:flex;gap:8px;align-items:center}
    .blink{animation: blink 800ms infinite}
    @keyframes blink { 0%{opacity:1}50%{opacity:0.15}100%{opacity:1} }
    /* preview modal */
    #previewScreen{position:fixed;inset:0;z-index:80;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.95)}
    #previewHolder{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    #previewHolder img, #previewHolder video{max-width:100%;max-height:100%;object-fit:contain}
    .previewButtons{position:absolute;bottom:28px;left:0;right:0;display:flex;gap:12px;justify-content:center;z-index:90;padding:0 20px}
    .btn{padding:12px 16px;border-radius:10px;border:none;background:rgba(255,255,255,0.06);color:#fff;font-weight:700;cursor:pointer}
    /* small UI */
    #progress{position:fixed;top:12px;right:12px;background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:10px;z-index:60}
    #qrOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:120;opacity:0;pointer-events:none;transition:opacity 220ms}
    #qrOverlay.visible{opacity:1;pointer-events:auto}
    #qrModal{background:#fff;padding:18px;border-radius:12px;color:#000;box-shadow:0 10px 30px rgba(0,0,0,0.35)}
    #debugInfo{position:fixed;bottom:8px;left:8px;font-size:12px;color:#ddd;z-index:130;background:rgba(0,0,0,0.45);padding:6px;border-radius:6px;display:none}
    @media(max-width:480px){ #countdown{font-size:72px} .mode-btn{width:72px;height:72px;font-size:22px} }
  </style>
</head>
<body>
  <!-- Step 1: Enter fullscreen -->
  <div id="enterFs" class="screen visible" style="background:linear-gradient(135deg,#fff,#f5f5f5);">
    <div style="text-align:center;width:95%;max-width:420px">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h1 style="color:#222;margin-bottom:10px">üì∏ Cabine Fotogr√°fica</h1>
      <p style="color:#444;margin-bottom:16px">Clique para entrar em tela cheia</p>
      <button id="enterFsBtn">üé¨ Entrar em Tela Cheia</button>
    </div>
  </div>

  <!-- Step 2: Welcome -->
  <div id="welcomeScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div style="text-align:center;padding:18px;border-radius:12px;background:rgba(0,0,0,0.02)">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222;margin-bottom:8px">Preparado?</h2>
      <p style="color:#444;margin-bottom:12px">Toque em Iniciar Sess√£o</p>
      <button id="startBtn">‚ñ∂Ô∏è Iniciar Sess√£o</button>
    </div>
  </div>

  <!-- Step 3: Mode selection -->
  <div id="selectionScreen" class="screen hidden" style="background:linear-gradient(135deg,#000,#111)">
    <div style="text-align:center">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h2 style="margin-bottom:6px">Escolha o modo</h2>
      <div class="mode-buttons">
        <div style="text-align:center">
          <button id="btnBoom" class="mode-btn boom">&infin;</button>
          <div style="color:#ddd;margin-top:6px">Boomerang</div>
        </div>
        <div style="text-align:center">
          <button id="btnThree" class="mode-btn three">‚ò∞</button>
          <div style="color:#ddd;margin-top:6px">3 Fotos</div>
        </div>
      </div>
      <p style="color:#ccc;margin-top:14px">Ser√° usada a c√¢mera frontal do celular. Posicione-se dentro do quadro.</p>
    </div>
  </div>

  <!-- Live camera preview -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>
  <div id="cropFrame" style="display:none"></div>

  <!-- Countdown / REC -->
  <div id="countdown"></div>
  <div id="recDot" style="display:none"><span id="recIndicator" class=""></span><strong id="recLabel">REC</strong></div>
  <div id="progress" style="display:none"></div>

  <!-- Preview modal -->
  <div id="previewScreen" class="hidden">
    <div id="previewHolder"></div>
    <div class="previewButtons">
      <button id="refazerBtn" class="btn">üîÑ Refazer</button>
      <button id="continuarBtn" class="btn">‚úÖ Continuar</button>
    </div>
  </div>

  <!-- Thank you -->
  <div id="thankScreen" class="screen hidden" style="background:linear-gradient(135deg,#fff,#f7f7f7)">
    <div style="text-align:center">
      <img src="logo1.png" class="logo" onerror="this.style.display='none'">
      <h2 style="color:#222">‚ú® Obrigado!</h2>
      <p style="color:#444">Aguarde o operador, suas fotos ser√£o processadas.</p>
    </div>
  </div>

  <!-- QR overlay -->
  <div id="qrOverlay">
    <div id="qrModal" style="display:none">
      <canvas id="qrCanvas" width="260" height="260"></canvas>
      <div style="margin-top:8px;font-size:14px;color:#222">Escaneie o QR para ver suas fotos</div>
    </div>
  </div>

  <div id="debugInfo"></div>

<script>
/*
  Vers√£o corrigida do celular.html
  - BOOMERANG: grava√ß√£o direta da c√¢mera (MediaRecorder no stream) por 2s (inicio imediato ap√≥s contagem),
    preview ao vivo durante a grava√ß√£o (n√£o congelamento), indicador REC, contagem agressiva,
    crop vertical mostrado corretamente, gera√ß√£o de boomerang a partir do blob gravado e preview final (Refazer/Continuar).
  - 3 fotos: continua gravando capturas em dataURL e emite 'photos_submit' com array
  - Backend: https://festadodavi-production-0591.up.railway.app
*/

(function(){
  const SERVER_URL = "https://festadodavi-production-0591.up.railway.app";
  const socket = io(SERVER_URL, { transports:['polling','websocket'], reconnection:true, path:'/socket.io' });

  // Template coords (vertical stories template)
  const TEMPLATE_W = 3375, TEMPLATE_H = 6000;
  const BOOM_AREA = { x:295, y:272, w:2785, h:4159 }; // coords fornecidas
  const BOOM_TARGET_W = 720; // reduzir para performance (se quiser 1080 troque aqui)
  const BOOM_LOOP_MS = 15000;
  const BOOM_RECORD_MS = 2000; // 2s de movimento

  // DOM
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const selectionScreen = document.getElementById('selectionScreen');
  const btnBoom = document.getElementById('btnBoom');
  const btnThree = document.getElementById('btnThree');
  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const cropFrame = document.getElementById('cropFrame');
  const countdownEl = document.getElementById('countdown');
  const recDot = document.getElementById('recDot');
  const recIndicator = document.getElementById('recIndicator');
  const recLabel = document.getElementById('recLabel');
  const progressEl = document.getElementById('progress');
  const previewScreen = document.getElementById('previewScreen');
  const previewHolder = document.getElementById('previewHolder');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const qrOverlay = document.getElementById('qrOverlay');
  const qrModal = document.getElementById('qrModal');
  const qrCanvas = document.getElementById('qrCanvas');
  const debugInfo = document.getElementById('debugInfo');

  let session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
  let stream = null;
  let previewRaf = null;
  let photos = [];

  // small debug helper
  function debug(msg){
    if(debugInfo){ debugInfo.style.display='block'; debugInfo.textContent = '['+new Date().toLocaleTimeString()+'] '+msg+"\n"+debugInfo.textContent; }
    console.log(msg);
  }

  // socket basic handlers
  socket.on('connect', ()=> { debug('socket conectado: ' + socket.id); socket.emit('join_session', { session, role: 'viewer' }); });
  socket.on('show_qr', ({ visualizadorUrl }) => {
    if(!visualizadorUrl) return;
    qrModal.style.display = 'block';
    try { QRCode.toCanvas(qrCanvas, visualizadorUrl, { width:260 }, (err)=>{ if(err) debug('QR error: '+err); qrOverlay.classList.add('visible'); }); } catch(e){ qrOverlay.classList.add('visible'); }
  });
  socket.on('reset_session', ()=> { photos = []; showScreen(welcomeScreen); });

  // UI flow: enter fullscreen -> welcome -> selection -> capture
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen(); } catch(e){}
    showScreen(welcomeScreen);
    socket.emit('cell_entered_fullscreen', { session, viewerId: socket.id });
  });

  startBtn.addEventListener('click', ()=> showScreen(selectionScreen));
  btnThree.addEventListener('click', () => beginThreePhotosFlow());
  btnBoom.addEventListener('click', () => beginBoomerangFlow());

  function showScreen(el){
    [enterFs, welcomeScreen, selectionScreen, previewScreen, thankScreen].forEach(s => { if(s){ s.classList.add('hidden'); s.classList.remove('visible'); } });
    // hide camera overlays by default
    canvasEl.style.display = 'none';
    videoEl.style.display = 'none';
    cropFrame.style.display = 'none';
    countdownEl.textContent = '';
    if(el){ el.classList.remove('hidden'); el.classList.add('visible'); }
  }

  // ensure front camera and show live preview
  async function ensureFrontCamera(){
    if(stream) return stream;
    try {
      const constraints = { video: { facingMode: { ideal: "user" }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream;
      videoEl.style.display = 'block';
      videoEl.style.transform = 'scaleX(-1)'; // mirror user preview
      await videoEl.play().catch(()=>{});
      return stream;
    } catch(e){
      throw e;
    }
  }

  // preview loop - continually draw video -> canvas so overlay is live
  function startPreviewLoop(){
    canvasEl.style.display = 'block';
    videoEl.style.display = 'block';
    function step(){
      drawPreview();
      previewRaf = requestAnimationFrame(step);
    }
    if(!previewRaf) step();
  }
  function stopPreviewLoop(){
    if(previewRaf){ cancelAnimationFrame(previewRaf); previewRaf = null; }
  }

  function drawPreview(){
    if(!videoEl.videoWidth) return;
    const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
    const cw = window.innerWidth, ch = window.innerHeight;
    canvasEl.width = cw; canvasEl.height = ch;
    const ctx = canvasEl.getContext('2d');
    // cover scaling
    const scale = Math.max(cw / vw, ch / vh);
    const w = vw * scale, h = vh * scale;
    const dx = (cw - w)/2, dy = (ch - h)/2;
    // Because videoEl is mirrored via CSS, draw mirrored to canvas to match user perception
    ctx.save(); ctx.translate(cw,0); ctx.scale(-1,1);
    try { ctx.drawImage(videoEl, 0,0, vw, vh, 0, dy, w, h); } catch(e){}
    ctx.restore();

    // compute crop area in canvas coordinates (maps BOOM_AREA from TEMPLATE -> canvas)
    const sx = w / TEMPLATE_W;
    const sy = h / TEMPLATE_H;
    const cx = dx + BOOM_AREA.x * sx;
    const cy = dy + BOOM_AREA.y * sy;
    const cwCrop = BOOM_AREA.w * sx;
    const chCrop = BOOM_AREA.h * sy;
    cropFrame.style.left = cx + 'px';
    cropFrame.style.top = cy + 'px';
    cropFrame.style.width = cwCrop + 'px';
    cropFrame.style.height = chCrop + 'px';
    cropFrame.style.display = 'block';
  }

  /* --------------------
     THREE PHOTOS FLOW
     - capture three photos from camera, show preview for each (refazer/continuar)
     - after 3 photos, emit photos_submit to server with array of dataURLs
     -------------------- */
  async function beginThreePhotosFlow(){
    try { await ensureFrontCamera(); } catch(e){ alert('Falha c√¢mera: '+e.message); showScreen(selectionScreen); return; }
    photos = [];
    startPreviewLoop();
    await sleep(200);
    for(let i=0;i<3;i++){
      try {
        await showCountdown(4); // 4s countdown (3,2,1,SORRIA)
        const dataUrl = await capturePhoto();
        const keep = await showImagePreviewForDecision(dataUrl);
        if(!keep){ i--; continue; } // refazer
        photos.push(dataUrl);
      } catch(e){
        debug('Erro captura: '+(e.message || e));
        i--; await sleep(300);
      }
    }
    // send photos_submit to server for Index to produce montagens
    showProgress('Enviando fotos...');
    try {
      socket.emit('photos_submit', { session, viewerId: socket.id, photos });
      debug('photos_submit emitido ('+photos.length+' fotos)');
      showScreen(thankScreen);
    } catch(e){
      debug('Erro envio photos_submit: '+e);
      alert('Erro enviando fotos.');
      showScreen(selectionScreen);
    } finally {
      hideProgress();
      stopPreviewLoop();
    }
  }

  async function capturePhoto(){
    const vw = videoEl.videoWidth || 1280, vh = videoEl.videoHeight || 720;
    const c = document.createElement('canvas'); c.width = vw; c.height = vh;
    const ctx = c.getContext('2d');
    // un-mirror before saving so operator gets natural orientation
    ctx.save(); ctx.translate(c.width,0); ctx.scale(-1,1);
    ctx.drawImage(videoEl, 0,0, vw, vh);
    ctx.restore();
    return c.toDataURL('image/jpeg', 0.95);
  }

  // show image preview, returns true to keep, false to refazer
  function showImagePreviewForDecision(dataUrl){
    return new Promise((resolve) => {
      previewHolder.innerHTML = '';
      const img = document.createElement('img'); img.src = dataUrl;
      previewHolder.appendChild(img);
      showScreen(previewScreen);
      const onRef = () => { cleanup(); resolve(false); };
      const onCont = () => { cleanup(); resolve(true); };
      function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    }).then(async (keep) => {
      await sleep(200);
      showScreen(null); startPreviewLoop();
      return keep;
    });
  }

  /* --------------------
     BOOMERANG FLOW (corrigido)
     - contagem agressiva (3..2..1.. REC)
     - grava√ß√£o direta da c√¢mera (MediaRecorder on stream) por 2s
     - preview ao vivo n√£o congela
     - gera√ß√£o final: replay forward+reverse em canvas + MediaRecorder (loop ~15s)
     - preview final (video) com Refazer/Continuar
     -------------------- */
  async function beginBoomerangFlow(){
    try { await ensureFrontCamera(); } catch(e){ alert('Falha c√¢mera: '+e.message); showScreen(selectionScreen); return; }
    // ensure preview running (live)
    startPreviewLoop();
    await sleep(250);
    // countdown
    await showCountdown(3);
    // show REC indicator
    showRec(true);
    showProgress('Gravando...');
    // record short clip directly from stream (raw)
    const shortBlob = await recordRawClipFromStream(BOOM_RECORD_MS);
    showRec(false);
    hideProgress();
    if(!shortBlob){ alert('Erro ao gravar. Tente novamente.'); showScreen(selectionScreen); return; }
    debug('Short clip size: '+(shortBlob.size||0));

    // now generate boomerang final (play forward+reverse repeatedly onto canvas and record)
    showProgress('Processando Boomerang...');
    stopPreviewLoop(); // pause preview to reduce CPU contention while processing
    const finalBlob = await generateBoomerangFromShortClip(shortBlob, { loopMs: BOOM_LOOP_MS, targetW: BOOM_TARGET_W });
    hideProgress();
    if(!finalBlob){ alert('Erro processando boomerang'); showScreen(selectionScreen); startPreviewLoop(); return; }

    // show preview video and allow refazer/continuar
    const videoUrl = URL.createObjectURL(finalBlob);
    const decision = await showVideoPreviewDecision(videoUrl);
    if(!decision){
      // refazer: go back to selection and allow re-record
      startPreviewLoop();
      return;
    }
    // continue: send boomerang (binary) + thumbnail + photos_submit compat
    showProgress('Enviando Boomerang...');
    try {
      const ab = await finalBlob.arrayBuffer();
      // emit metadata and binary as second arg (socket.io supports binary)
      socket.emit('boomerang_ready', { session, viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, size: ab.byteLength }, ab);
      // send thumbnail (first frame) and a photos_submit for compatibility
      const thumb = await blobToDataURL(finalBlob, true).catch(()=>null);
      if(thumb) socket.emit('photo_ready', { session, index: 0, viewerId: socket.id, photo: thumb });
      if(thumb) socket.emit('photos_submit', { session, viewerId: socket.id, photos: [thumb] });
      debug('boomerang_ready emitido (binary) size=' + ab.byteLength);
      showScreen(thankScreen);
    } catch(e){
      debug('Erro enviando boomerang: ' + e);
      // fallback open blob
      window.open(videoUrl, '_blank');
      showScreen(selectionScreen);
    } finally {
      hideProgress();
    }
  }

  // record raw clip directly from camera stream (fast, immediate)
  function recordRawClipFromStream(msDuration){
    return new Promise(async (resolve) => {
      if(!stream){
        try { await ensureFrontCamera(); } catch(e){ resolve(null); return; }
      }
      const options = (() => {
        try { return { mimeType: 'video/webm;codecs=vp8' }; } catch(e){ return {}; }
      })();
      let recorder;
      let chunks = [];
      try {
        recorder = new MediaRecorder(stream, options);
      } catch(e){
        try { recorder = new MediaRecorder(stream); } catch(e){ debug('MediaRecorder not supported'); resolve(null); return; }
      }
      recorder.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
      recorder.start();
      setTimeout(()=> {
        if(recorder && recorder.state === 'recording') recorder.stop();
      }, msDuration);
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type:'video/webm' });
        resolve(blob);
      };
      // safety timeout
      setTimeout(()=>{ if(recorder && recorder.state === 'recording') recorder.stop(); }, msDuration + 3000);
    });
  }

  // generate boomerang by replaying short clip forward+reverse into canvas and recording canvas
  async function generateBoomerangFromShortClip(shortBlob, opts = { loopMs:15000, targetW:720 }){
    const loopMs = opts.loopMs || 15000;
    const targetW = opts.targetW || 720;

    // load short clip into hidden video
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true;
    v.src = URL.createObjectURL(shortBlob);
    await new Promise((res,rej)=>{ v.onloadedmetadata = res; v.onerror = ()=> rej(new Error('Erro carregar clip')); });

    // compute target canvas size keeping aspect
    const aspect = (v.videoWidth && v.videoHeight) ? (v.videoWidth / v.videoHeight) : (9/16);
    const targetH = Math.round(targetW / aspect);
    const canvas = document.createElement('canvas');
    canvas.width = targetW; canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // load template if exists (bomerang.png)
    const template = new Image(); template.crossOrigin = 'anonymous'; template.src = 'bomerang.png';
    await new Promise(r => { template.onload = r; template.onerror = r; });

    // map BOOM_AREA from TEMPLATE -> canvas
    const scaleFactor = targetW / TEMPLATE_W;
    const area = {
      x: Math.round(BOOM_AREA.x * scaleFactor),
      y: Math.round(BOOM_AREA.y * scaleFactor),
      w: Math.round(BOOM_AREA.w * scaleFactor),
      h: Math.round(BOOM_AREA.h * scaleFactor)
    };

    // start recording canvas
    const streamCap = canvas.captureStream(30);
    let chunks = [];
    let rec;
    try { rec = new MediaRecorder(streamCap, { mimeType: 'video/webm;codecs=vp8' }); } catch(e) { try { rec = new MediaRecorder(streamCap); } catch(e){ debug('MediaRecorder on canvas failed'); return null; } }
    rec.ondataavailable = ev => { if(ev.data && ev.data.size) chunks.push(ev.data); };
    rec.start();

    const startTime = performance.now();

    // helper draw frame
    function drawFrame(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(template && template.complete && template.naturalWidth) ctx.drawImage(template, 0,0, TEMPLATE_W, TEMPLATE_H, 0,0, canvas.width, canvas.height);
      else { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); }
      try { ctx.drawImage(v, 0,0, v.videoWidth, v.videoHeight, area.x, area.y, area.w, area.h); } catch(e){}
    }

    // playback helpers: forward via timeupdate, reverse by stepping
    async function playForward(){
      return new Promise(res => {
        v.currentTime = 0; v.play().catch(()=>{});
        const onTick = () => { drawFrame(); if(v.ended || v.currentTime >= v.duration - 0.001){ v.pause(); v.removeEventListener('timeupdate', onTick); res(); } };
        v.addEventListener('timeupdate', onTick);
        drawFrame();
      });
    }
    async function playReverse(){
      return new Promise(res => {
        v.pause();
        v.currentTime = v.duration;
        function step(){
          const stepSec = 1/30;
          v.currentTime = Math.max(0, v.currentTime - stepSec);
          drawFrame();
          if(v.currentTime > 0.02) requestAnimationFrame(step); else res();
        }
        step();
      });
    }

    while(performance.now() - startTime < loopMs){
      await playForward();
      if(performance.now() - startTime >= loopMs) break;
      await playReverse();
    }

    // stop recorder
    await sleep(120);
    await new Promise(res => { rec.onstop = res; rec.stop(); });

    return new Blob(chunks, { type: 'video/webm' });
  }

  // show countdown (n..1..SORRIA)
  async function showCountdown(seconds = 3){
    for(let t = seconds; t>0; t--){
      countdownEl.textContent = (t <= 1) ? 'SORRIA!' : String(t);
      await sleep(1000);
    }
    countdownEl.textContent = '';
  }

  function showRec(on){
    if(on){
      recDot.style.display = 'flex';
      recIndicator.classList.add('blink');
      recLabel.textContent = 'REC';
    } else {
      recDot.style.display = 'none';
      recIndicator.classList.remove('blink');
    }
  }

  // show/hide progress
  function showProgress(txt){ progressEl.style.display = 'block'; progressEl.textContent = txt || ''; }
  function hideProgress(){ progressEl.style.display = 'none'; progressEl.textContent = ''; }

  // show preview video and ask decision (refazer/continuar)
  function showVideoPreviewDecision(videoUrl){
    return new Promise((resolve) => {
      previewHolder.innerHTML = '';
      const v = document.createElement('video'); v.src = videoUrl; v.loop = true; v.autoplay = true; v.controls = true;
      previewHolder.appendChild(v);
      previewScreen.classList.remove('hidden'); previewScreen.classList.add('visible');
      const onRef = () => { cleanup(); resolve(false); };
      const onCont = () => { cleanup(); resolve(true); };
      function cleanup(){ refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); previewScreen.classList.add('hidden'); previewScreen.classList.remove('visible'); }
      refazerBtn.addEventListener('click', onRef);
      continuarBtn.addEventListener('click', onCont);
    });
  }

  // convert blob to dataURL, optionally firstFrame
  function blobToDataURL(blob, firstFrame=false){
    return new Promise((res,rej) => {
      if(!firstFrame){
        const reader = new FileReader();
        reader.onload = ()=> res(reader.result);
        reader.onerror = rej;
        reader.readAsDataURL(blob);
      } else {
        const v = document.createElement('video'); v.muted = true; v.playsInline = true; v.src = URL.createObjectURL(blob);
        v.onloadeddata = async () => {
          try {
            v.currentTime = Math.min(0.05, v.duration/2 || 0.05);
            await sleep(80);
            const c = document.createElement('canvas'); c.width = v.videoWidth || 640; c.height = v.videoHeight || 480;
            const ctx = c.getContext('2d'); ctx.drawImage(v,0,0,c.width,c.height);
            res(c.toDataURL('image/jpeg', 0.85));
          } catch(e){ rej(e); }
        };
        v.onerror = rej;
      }
    });
  }

  // show image preview (used for three-photo flow)
  // (implemented earlier as showImagePreviewForDecision)

  // util sleep
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // expose small debug
  window._cabine_mobile = { socket, ensureFrontCamera, startPreviewLoop: () => startPreviewLoop(), stopPreviewLoop: () => stopPreviewLoop() };

})(); // IIFE
</script>
</body>
</html>
