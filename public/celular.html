<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:Arial,Helvetica,sans-serif;background:#fff;color:#000;overflow:hidden}
    .screen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;padding:18px}
    .visible{display:flex}
    .logo{max-width:160px;margin-bottom:14px}
    #enterFsBtn{padding:14px 18px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:800;font-size:18px}
    #startBtn{padding:14px 18px;border-radius:12px;border:none;background:#0b84ff;color:#fff;font-weight:800;font-size:18px}
    #videoBg{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:0;display:none;transform:scaleX(-1)}
    #countdown{position:fixed;left:0;right:0;top:28%;z-index:3;display:none;font-weight:900;font-size:120px;text-align:center;color:#fff;text-shadow:0 8px 28px rgba(0,0,0,0.8)}
    #previewBox{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:6;background:rgba(0,0,0,0.88);flex-direction:column;padding:18px}
    #previewImg{max-width:92vw;border-radius:14px;border:6px solid rgba(255,255,255,0.06)}
    .controls-row{display:flex;gap:12px;margin-top:14px}
    .btnSmall{padding:12px 14px;border-radius:10px;border:0;font-weight:800;cursor:pointer}
    .btnRedo{background:#dc3545;color:#fff}
    .btnContinue{background:#28a745;color:#fff}
    #thankBox{display:none;align-items:center;justify-content:center;flex-direction:column;padding:18px}
    #status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.5);color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;z-index:12}
  </style>
</head>
<body>
  <div id="status">Conectando...</div>

  <div id="enterScreen" class="screen visible" style="background:#fff">
    <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
    <h1>ðŸ“¸ Cabine FotogrÃ¡fica</h1>
    <p>Para melhor experiÃªncia, entre em tela cheia</p>
    <button id="enterFsBtn">ðŸ”² Entrar em Tela Cheia</button>
  </div>

  <div id="welcomeScreen" class="screen" style="background:#fff">
    <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
    <h1>ðŸ“¸ Bem-vindo Ã  Cabine FotogrÃ¡fica</h1>
    <p>Clique abaixo para iniciar</p>
    <button id="startBtn">ðŸŽ¬ Iniciar SessÃ£o de Fotos</button>
    <div id="waiting" style="margin-top:12px;color:#666;display:none">Aguardando cÃ¢mera do operador...</div>
  </div>

  <img id="videoBg" src="" alt="preview">

  <div id="countdown">3</div>

  <div id="previewBox">
    <img id="previewImg" alt="Preview">
    <div class="controls-row">
      <button id="refazerBtn" class="btnSmall btnRedo">ðŸ”„ Refazer</button>
      <button id="continuarBtn" class="btnSmall btnContinue">âœ… Continuar</button>
    </div>
  </div>

  <div id="thankBox" class="screen" style="background:linear-gradient(135deg,#0b84ff,#004aad);color:#fff">
    <img src="logo1.png" class="logo" alt="Logo" onerror="this.style.display='none'">
    <h1>âœ¨ Obrigado!</h1>
    <p>Espere o operador finalizar a sessÃ£o.</p>
  </div>

<script>
const params = new URLSearchParams(location.search);
const SESSION = params.get('session') || 'cabine-fixa';
const SERVER = params.get('server') || 'https://festadodavi.onrender.com';

const $ = id => document.getElementById(id);
const statusEl = $('status'), enterScreen = $('enterScreen'), enterFsBtn = $('enterFsBtn');
const welcomeScreen = $('welcomeScreen'), startBtn = $('startBtn'), waiting = $('waiting');
const videoBg = $('videoBg'), countdownEl = $('countdown');
const previewBox = $('previewBox'), previewImg = $('previewImg'), refazerBtn = $('refazerBtn'), continuarBtn = $('continuarBtn');
const thankBox = $('thankBox');

let socket = null;
let connected = false;
let haveFrame = false;
let sessionStarted = false;
let currentIndex = 0;
let photos = [];
let captureLock = false; // prevent duplicates

function show(screen){
  [enterScreen, welcomeScreen, previewBox, thankBox].forEach(s=>{ s.style.display = 'none'; s.classList.remove('visible'); });
  if(screen === 'enter'){ enterScreen.style.display='flex'; enterScreen.classList.add('visible'); }
  if(screen === 'welcome'){ welcomeScreen.style.display='flex'; welcomeScreen.classList.add('visible'); }
  if(screen === 'preview'){ previewBox.style.display='flex'; }
  if(screen === 'thank'){ thankBox.style.display='flex'; thankBox.classList.add('visible'); }
}

function initSocket(){
  if(socket) return;
  socket = io(SERVER, { transports:['websocket'], reconnection:true, timeout:20000 });

  socket.on('connect', ()=>{ connected = true; statusEl.textContent = 'Conectado'; socket.emit('join_session', { session: SESSION, role: 'viewer' }); socket.emit('request_stream', { session: SESSION }); });
  socket.on('disconnect', ()=>{ connected = false; statusEl.textContent = 'Desconectado'; });

  socket.on('stream_frame', ({ frame }) => {
    haveFrame = true;
    if(sessionStarted){
      videoBg.src = frame; videoBg.style.display = 'block';
    }
  });

  socket.on('stream_pending', ()=>{ haveFrame = false; });

  socket.on('photo_ready', ({ index, photo, mirror }) => {
    captureLock = false;
    // preview final: if operator sent mirror true, we keep the image mirrored so it matches background preview; otherwise show as-is
    previewImg.src = photo;
    previewImg.style.transform = mirror ? 'scaleX(-1)' : 'none';
    // show preview controls
    previewBox.style.display = 'flex';
  });

  socket.on('photos_received', ({ status }) => {
    statusEl.textContent = 'Fotos enviadas: ' + status;
  });

  socket.on('reset_session', ({ session }) => {
    // operator finalized session -> viewer returns to welcomeScreen (not enterScreen)
    sessionStarted = false;
    haveFrame = false;
    photos = []; currentIndex = 0; captureLock = false;
    previewBox.style.display = 'none';
    videoBg.style.display = 'none'; videoBg.src = '';
    show('welcome');
    statusEl.textContent = 'SessÃ£o reiniciada';
  });
}

// ensure first fullscreen action only once
enterFsBtn.addEventListener('click', async () => {
  try { await document.documentElement.requestFullscreen(); } catch(e){}
  show('welcome');
  // init socket once user interacted
  initSocket();
});

// start session (visitor clicks to start) - now only after clicking they will see preview and countdown flow
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  sessionStarted = true;
  show(null); // hide screens
  // tell server we entered full screen (optional)
  socket && socket.emit('cell_entered_fullscreen', { session: SESSION });
  // start showing frames (if available)
  if(!haveFrame){
    waiting.style.display = 'block';
    socket && socket.emit('request_stream', { session: SESSION });
    // wait short while
    await new Promise(r => setTimeout(r, 1000));
  }
  waiting.style.display = 'none';
  // run capture sequence
  currentIndex = 0; photos = [];
  await runCaptureSequence();
});

// capture 3 photos sequence
async function runCaptureSequence(){
  if(currentIndex >= 3){
    // finished capture: send to server
    previewBox.style.display = 'none';
    videoBg.style.display = 'none';
    // send photos
    if(socket && socket.connected){
      socket.emit('photos_submit', { session: SESSION, viewerId: socket.id, photos });
      statusEl.textContent = 'Enviando fotos...';
    } else {
      statusEl.textContent = 'Sem conexÃ£o para enviar';
    }
    // show thank you screen and WAIT for operator reset
    show('thank');
    return;
  }
  // start the countdown and request operator to capture (take_photo event)
  await takeOnePhoto(currentIndex);
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function takeOnePhoto(index){
  if(captureLock) return;
  captureLock = true;
  // countdown overlay (3..1)
  countdownEl.style.display = 'block';
  for(let t=3;t>0;t--){
    countdownEl.textContent = t === 1 ? 'SORRIA!' : String(t);
    await sleep(900);
  }
  countdownEl.style.display = 'none';
  // request operator to capture (operator will emit photo_ready)
  statusEl.textContent = 'Pedindo captura ao operador...';
  socket && socket.emit('take_photo', { session: SESSION, index, viewerId: socket.id });
  // wait for photo_ready (with timeout)
  let waited = 0;
  const timeoutMs = 10000;
  while(captureLock && waited < timeoutMs){
    await sleep(200);
    waited += 200;
  }
  if(captureLock){
    // timed out â€” fallback: try to request lastFrame snapshot as image (server might have cached). We request server to send lastFrame via stream_frame cached â€” but no direct capture => show error and allow retry
    captureLock = false;
    alert('Tempo esgotado para captura. Por favor peÃ§a ao operador para verificar webcam.');
    show('welcome');
    return;
  }
  // when photo_ready arrives, previewBox is shown by handler with previewImg filled
  // user decides: refazer or continuar
  // set handlers for the current preview interaction
  await waitForPreviewDecision(index);
}

function waitForPreviewDecision(index){
  return new Promise((resolve) => {
    refazerBtn.onclick = async () => {
      previewBox.style.display = 'none';
      // repeat the same index
      await sleep(300);
      captureLock = false;
      resolve(false); // not accepted
      runCaptureSequence();
    };
    continuarBtn.onclick = async () => {
      // accept this photo: push into photos and continue
      photos.push(previewImg.src);
      previewBox.style.display = 'none';
      currentIndex++;
      captureLock = false;
      resolve(true);
      await sleep(300);
      runCaptureSequence();
    };
  });
}

function stopShowingPreview(){
  previewBox.style.display = 'none';
}

// helper to ensure preview orientation consistent with stream (operator sends mirror true)
socketInitSafely();
function socketInitSafely(){
  // try to init socket asap so we can request stream on start; but do not show preview until user clicks startBtn
  initSocket();
}

function initSocket(){
  if(window.__socketInitialized) return;
  window.__socketInitialized = true;
  if(typeof io === 'undefined'){ statusEl.textContent = 'Socket.IO nÃ£o carregado'; return; }
  socket = io(SERVER, { transports:['websocket'], reconnection:true });

  socket.on('connect', ()=>{ connected = true; statusEl.textContent = 'Conectado'; socket.emit('join_session', { session: SESSION, role: 'viewer' }); socket.emit('request_stream', { session: SESSION }); });
  socket.on('disconnect', ()=>{ connected = false; statusEl.textContent = 'Desconectado'; });

  socket.on('stream_frame', ({ frame }) => {
    haveFrame = true;
    if(sessionStarted) { videoBg.src = frame; videoBg.style.display = 'block'; }
  });

  socket.on('stream_pending', ()=>{ haveFrame = false; });

  socket.on('photo_ready', ({ index, photo, mirror }) => {
    // show preview with same orientation as preview stream
    previewImg.src = photo;
    previewImg.style.transform = mirror ? 'scaleX(-1)' : 'none';
    previewBox.style.display = 'flex';
    statusEl.textContent = 'Foto recebida';
    // clear capture lock only when preview is shown, so waitForPreviewDecision will continue
    captureLock = false;
  });

  socket.on('photos_received', ({ status }) => {
    statusEl.textContent = 'Fotos recebidas: ' + status;
  });

  socket.on('reset_session', ({ session }) => {
    // operator finalized: return visitor to welcome (not enter-screen)
    sessionStarted = false; haveFrame = false; photos = []; currentIndex = 0; captureLock = false;
    previewBox.style.display = 'none'; videoBg.style.display='none'; videoBg.src='';
    show('welcome');
    statusEl.textContent = 'SessÃ£o finalizada pelo operador';
  });
}

// initial view
show('enter');

</script>
</body>
</html>
