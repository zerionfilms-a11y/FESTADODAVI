<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular (com Boomerang + 3 Fotos)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    /* ======================
       Estilos principais
       ====================== */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:18px}
    .hidden{display:none!important}
    .visible{display:flex!important}

    /* Entrar em tela cheia */
    #enterFs { background: linear-gradient(135deg,#0b84ff,#002b6d); }
    .card { background: rgba(255,255,255,0.08); padding:22px; border-radius:14px; text-align:center; width:100%; max-width:420px; backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.04); }
    .logo { max-width:160px; margin-bottom:10px; display:block; margin-left:auto; margin-right:auto; }
    h1 { font-size:20px; margin-bottom:8px; color:#fff; }
    p.lead { color: rgba(255,255,255,0.9); margin-bottom:12px; }

    button.primary { background:#ffd600; color:#000; border:none; padding:14px 18px; border-radius:12px; font-weight:800; font-size:16px; cursor:pointer; width:100%; max-width:320px; }
    button.ghost { background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.15); padding:12px 16px; border-radius:10px; cursor:pointer; }

    /* Escolha modo */
    #chooseMode { background: linear-gradient(135deg,#001e3c,#0b84ff); }
    .mode-buttons{display:flex;gap:18px;justify-content:center;margin-top:12px}
    .mode-btn{width:120px;height:120px;border-radius:16px;border:none;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:18px;cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.35)}
    .mode-btn .icon{font-size:30px;margin-bottom:8px}
    .mode-btn.boom{background:linear-gradient(135deg,#08a, #056);}
    .mode-btn.photo{background:linear-gradient(135deg,#ffd600,#e0a800); color:#000;}
    .mode-label{font-weight:700}

    /* Camera / preview */
    #videoEl, #canvasEl { position:fixed; inset:0; width:100%; height:100%; object-fit:cover; z-index:1; display:none; }
    #cameraUI { position:fixed; inset:0; z-index: 40; display:flex; flex-direction:column; justify-content:flex-end; align-items:center; pointer-events:none; }
    .controls { pointer-events:all; width:100%; max-width:900px; margin:18px; display:flex; gap:10px; justify-content:center; align-items:center; }
    .big-btn { padding:14px 20px; border-radius:12px; border:none; font-weight:800; cursor:pointer; background:rgba(0,0,0,0.55); color:#fff; }
    .big-btn.primary { background: linear-gradient(135deg,#ffd600,#d0a100); color:#000; }

    #countdown { position:fixed; top:18%; left:0; right:0; text-align:center; font-size:120px; font-weight:900; z-index:120; color:#fff; text-shadow: 0 4px 30px rgba(0,0,0,0.8); pointer-events:none; }
    #statusBar { position:fixed; top:12px; left:12px; right:12px; z-index:120; display:flex; justify-content:space-between; align-items:center; color:#fff; font-size:13px; }
    #progress { position:fixed; top:56px; left:0; right:0; text-align:center; z-index:120; color:#ffd600; font-weight:800; display:none; }

    /* Preview modal */
    #previewScreen { background: rgba(0,0,0,0.92); z-index:200; justify-content:center; }
    #previewImage { width:100%; height:100%; object-fit:contain; display:block; }
    .preview-buttons { position:absolute; bottom:28px; left:0; right:0; display:flex; gap:12px; justify-content:center; z-index:210; pointer-events:all; }

    /* Thank screen */
    #thankScreen { background: linear-gradient(135deg,#001e3c,#0b84ff); }

    /* debug */
    #debugInfo { position:fixed; bottom:10px; left:10px; font-size:11px; color:#ddd; background:rgba(0,0,0,0.45); padding:6px; border-radius:6px; z-index:9999; max-width:46%; }

    @media (max-width:520px){
      #countdown{font-size:64px}
      .mode-buttons{gap:10px}
      .mode-btn{width:86px;height:86px}
    }
  </style>
</head>
<body>
  <!-- ========== ENTER FULLSCREEN ========== -->
  <div id="enterFs" class="screen visible">
    <div class="card">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1>ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <p class="lead">Para comeÃ§ar, entre em tela cheia. Em seguida escolha: <strong>Boomerang</strong> ou <strong>3 Fotos</strong>.</p>
      <button id="enterFsBtn" class="primary" aria-label="Entrar em tela cheia">ðŸŽ¬ Entrar em Tela Cheia</button>
      <div style="height:10px"></div>
      <button id="helpBtn" class="ghost" onclick="alert('Use o botÃ£o para entrar em tela cheia. Depois escolha Boom ou Fotos.')">Ajuda rÃ¡pida</button>
    </div>
  </div>

  <!-- ========== CHOOSE MODE ========== -->
  <div id="chooseMode" class="screen hidden">
    <div class="card" style="max-width:520px">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1>Escolha o modo</h1>
      <p class="lead">Selecione o modo desejado â€” nada serÃ¡ executado atÃ© vocÃª tocar em uma opÃ§Ã£o.</p>
      <div class="mode-buttons" role="group" aria-label="Modos">
        <button id="boomBtn" class="mode-btn boom" aria-label="Boomerang">
          <div class="icon">âˆž</div>
          <div class="mode-label">Boomerang</div>
        </button>
        <button id="photoBtn" class="mode-btn photo" aria-label="3 Fotos">
          <div class="icon">â˜°</div>
          <div class="mode-label">3 Fotos</div>
        </button>
      </div>
    </div>
  </div>

  <!-- ========== CAMERA + UI ========== -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="canvasEl"></canvas>

  <div id="cameraUI" class="hidden">
    <div id="statusBar">
      <div id="sessionLabel">SessÃ£o: <span id="sessionId">â€”</span></div>
      <div id="connectionLabel">Socket: <span id="sockState">â€”</span></div>
    </div>
    <div id="countdown" class="hidden"></div>
    <div id="progress">Status</div>

    <div class="controls" style="pointer-events:all; justify-content:center">
      <button id="recBtn" class="big-btn primary hidden">GRAVANDO</button>
      <button id="captureBtn" class="big-btn">Tirar / Iniciar</button>
      <button id="cancelBtn" class="big-btn" style="display:none;background:rgba(255,255,255,0.08)">Cancelar</button>
    </div>
  </div>

  <!-- ========== PREVIEW (foto ou boomerang preview) ========== -->
  <div id="previewScreen" class="screen hidden" aria-modal="true" role="dialog">
    <div id="previewContainer" style="position:relative;width:100%;height:100%">
      <img id="previewImage" src="" alt="Preview">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <!-- ========== THANK YOU ========== -->
  <div id="thankScreen" class="screen hidden">
    <div class="card">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1>âœ¨ Obrigado!</h1>
      <p class="lead">Aguarde o operador. VocÃª pode fechar a tela depois.</p>
      <button class="ghost" onclick="location.reload()">Voltar</button>
    </div>
  </div>

  <div id="debugInfo"></div>

  <audio id="clack" src="clack.mp3" preload="auto"></audio>
  <audio id="inicio" src="inicio.mp3" preload="auto"></audio>
  <audio id="fim" src="fim.mp3" preload="auto"></audio>

<script>
/*
  celular.html - completo
  Fluxo:
   1) Entrar em tela cheia -> automaticamente mostra TELA DE ESCOLHA (boom/photo)
   2) Ao escolher:
      - 'photo' -> inicia fluxo 3x fotos (countdown, preview, refazer/continuar) -> enviar photos_submit (array de dataURL) ao servidor
      - 'boom'  -> grava clipe curto (2s) a partir da cÃ¢mera frontal -> cria boomerang loop (ida+volta repetido atÃ© ~15s) -> preview (tocar loop) -> refazer/continuar -> envia boomerang (ArrayBuffer) ao servidor
   3) Envia eventos socket: photos_submit, boomerang_ready. O servidor/index Ã© responsÃ¡vel por montar/gerar QR se assim preferir.
   4) Usa cÃ¢mera frontal do dispositivo (facingMode: user).
*/

const SERVER_URL = "https://festadodavi.onrender.com"; // preferÃªncia salva; altere aqui se quiser usar outro backend
const socket = io(SERVER_URL, { transports:['websocket','polling'], reconnection:true, reconnectionAttempts:10, path:'/socket.io' });

/* -------------------------
   Element refs
   ------------------------- */
const enterFsEl = document.getElementById('enterFs');
const enterFsBtn = document.getElementById('enterFsBtn');
const chooseModeEl = document.getElementById('chooseMode');
const boomBtn = document.getElementById('boomBtn');
const photoBtn = document.getElementById('photoBtn');

const videoEl = document.getElementById('videoEl');
const canvasEl = document.getElementById('canvasEl');

const cameraUI = document.getElementById('cameraUI');
const captureBtn = document.getElementById('captureBtn');
const cancelBtn = document.getElementById('cancelBtn');
const recBtn = document.getElementById('recBtn');

const previewScreen = document.getElementById('previewScreen');
const previewImage = document.getElementById('previewImage');
const refazerBtn = document.getElementById('refazerBtn');
const continuarBtn = document.getElementById('continuarBtn');

const countdownEl = document.getElementById('countdown');
const progressEl = document.getElementById('progress');
const debugInfo = document.getElementById('debugInfo');
const sessionIdEl = document.getElementById('sessionId');
const sockStateEl = document.getElementById('sockState');

let session = (new URLSearchParams(location.search)).get('session') || 'cabine-fixa';
sessionIdEl.textContent = session;

let stream = null;
let currentMode = null; // 'photo' or 'boom'
let photos = [];
let tempPhoto = null;
let shortClipBlob = null; // blob do clipe curto de 2s
let finalBoomerangBlob = null;
let recorder = null;

/* -------------------------
   Small utils
   ------------------------- */
function log(...args) {
  const t = new Date().toLocaleTimeString();
  debugInfo.textContent = `[${t}] ${args.map(a => (typeof a === 'object' ? JSON.stringify(a) : a)).join(' ') }\n` + debugInfo.textContent;
  console.log(...args);
}

function show(elem){ elem.classList.remove('hidden'); elem.classList.add('visible'); }
function hide(elem){ elem.classList.add('hidden'); elem.classList.remove('visible'); }
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

/* -------------------------
   SOCKET
   ------------------------- */
socket.on('connect', () => {
  sockStateEl.textContent = 'ðŸŸ¢';
  log('Socket conectado', socket.id);
  // avisar servidor que viewer conectou (para index exibir na lista etc)
  socket.emit('cell_connected', { session, viewerId: socket.id });
});

socket.on('disconnect', ()=> {
  sockStateEl.textContent = 'ðŸ”´';
  log('Socket desconectado');
});

socket.on('request_stream', ({ session: s }) => {
  // caso o index peÃ§a um frame
  // aqui podemos enviar um frame estÃ¡tico (thumbnail) se houver
  log('request_stream recebido', s);
});

/* -------------------------
   UI FLOW
   ------------------------- */

// 1) Entrar tela cheia -> abrir chooseMode imediatamente
enterFsBtn.addEventListener('click', async () => {
  try { await document.documentElement.requestFullscreen(); } catch(e){ /* ios/safari might not allow */ }
  // after fullscreen request, go to choice screen
  hide(enterFsEl);
  show(chooseModeEl);
});

// Ensure clicking choose mode options doesn't auto-run camera until user selects
boomBtn.addEventListener('click', async () => {
  currentMode = 'boom';
  hide(chooseModeEl);
  await startBoomFlow();
});

photoBtn.addEventListener('click', async () => {
  currentMode = 'photo';
  hide(chooseModeEl);
  await startPhotoFlow();
});

/* -------------------------
   CAMERA START/STOP
   ------------------------- */
async function startCameraFront() {
  if (stream) return stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false });
    videoEl.srcObject = stream;
    videoEl.style.display = 'block';
    show(cameraUI);
    await videoEl.play().catch(()=>{});
    log('Camera iniciada (frontal)');
    return stream;
  } catch (e) {
    log('Erro ao acessar camera frontal', e);
    alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera. Verifique permissÃµes.');
    throw e;
  }
}

function stopCamera() {
  try {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    videoEl.pause(); videoEl.srcObject = null; videoEl.style.display = 'none';
    hide(cameraUI);
    log('Camera parada');
  } catch(e) { log(e); }
}

/* -------------------------
   PHOTO FLOW (3 fotos)
   ------------------------- */
async function startPhotoFlow(){
  photos = [];
  await startCameraFront();
  captureBtn.textContent = 'Tirar foto';
  captureBtn.onclick = async () => {
    captureBtn.disabled = true;
    try {
      const data = await captureSinglePhotoWithCountdown();
      tempPhoto = data;
      showPhotoPreview(data);
    } finally {
      captureBtn.disabled = false;
    }
  };

  // allow cancellation
  cancelBtn.style.display = 'inline-block';
  cancelBtn.onclick = () => { stopCamera(); hide(cameraUI); show(chooseModeEl); cancelBtn.style.display='none'; };

  // start with first automatic or wait?
  // We'll wait for user to press 'Tirar foto' each time so they control it.
}

async function captureSinglePhotoWithCountdown() {
  // show camera moving during countdown (videoEl plays)
  show(countdownEl);
  for (let t=3; t>0; t--) {
    countdownEl.textContent = t;
    if (t===2) { try{ clack.currentTime=0; clack.play().catch(()=>{});}catch(e){} }
    await sleep(1000);
  }
  countdownEl.textContent = '';
  hide(countdownEl);
  // draw current frame mirrored (unmirror later if necessary)
  const w = videoEl.videoWidth || 1280;
  const h = videoEl.videoHeight || 720;
  canvasEl.width = w; canvasEl.height = h;
  const ctx = canvasEl.getContext('2d');
  // mirror so final result matches user's expectation
  ctx.save(); ctx.translate(w,0); ctx.scale(-1,1);
  ctx.drawImage(videoEl, 0, 0, w, h);
  ctx.restore();
  const dataUrl = canvasEl.toDataURL('image/jpeg', 0.95);
  log('Foto capturada', dataUrl.slice(0,60)+'...');
  return dataUrl;
}

function showPhotoPreview(dataUrl){
  previewImage.src = dataUrl;
  show(previewScreen);
  // wire buttons
  refazerBtn.onclick = async () => {
    hide(previewScreen);
    // keep camera running for a retake
    await sleep(120);
  };
  continuarBtn.onclick = async () => {
    photos.push(dataUrl);
    hide(previewScreen);
    log('Fotos atuais:', photos.length);
    if (photos.length >= 3) {
      // finalize and send to server
      await finalizePhotosSubmission();
    } else {
      // continue: user must hit 'Tirar foto' again
      // nothing to do; user will press captureBtn again
    }
  };
}

/* send photos to server and show thank you */
async function finalizePhotosSubmission(){
  progressEl.style.display = 'block';
  progressEl.textContent = 'Enviando fotos...';
  try {
    // emit photos_submit with array of dataURLs
    socket.emit('photos_submit', { session, viewerId: socket.id, photos });
    log('photos_submit emitido', photos.length);
  } catch(e){ log('Erro emit photos_submit', e); }
  progressEl.textContent = 'Pronto!';
  await sleep(700);
  progressEl.style.display = 'none';
  stopCamera();
  show(thankScreen);
}

/* -------------------------
   BOOMERANG FLOW
   ------------------------- */
async function startBoomFlow(){
  // prepare camera
  await startCameraFront();
  // Reset
  shortClipBlob = null;
  finalBoomerangBlob = null;

  // Start recording button will record a short clip (2s)
  captureBtn.textContent = 'Gravar Boomerang (2s)';
  captureBtn.onclick = async () => {
    captureBtn.disabled = true;
    try {
      await recordShortClipAndProcess();
    } catch(e) { log('Erro boomerang flow', e); alert('Erro ao gravar boomerang'); }
    finally { captureBtn.disabled = false; }
  };

  cancelBtn.style.display = 'inline-block';
  cancelBtn.onclick = () => { stopCamera(); hide(cameraUI); show(chooseModeEl); cancelBtn.style.display='none'; };
}

/* record short 2s clip from camera using captureStream on video element */
function recordShortClipMs(ms=2000){
  return new Promise(async (resolve, reject) => {
    try {
      // prefer capturing from videoEl to keep same resolution/orientation
      const vs = videoEl.captureStream(30);
      const options = { mimeType: 'video/webm;codecs=vp8' };
      let ch = [];
      const rec = new MediaRecorder(vs, options);
      rec.ondataavailable = (e) => { if (e.data && e.data.size) ch.push(e.data); };
      rec.onstop = () => {
        const blob = new Blob(ch, { type: 'video/webm' });
        resolve(blob);
      };
      rec.onerror = (e) => reject(e);
      rec.start();
      // small pre-roll to let camera settle
      await sleep(120);
      await sleep(ms);
      rec.stop();
    } catch (e) { reject(e); }
  });
}

/* Create boomerang by playing short clip forward+reverse onto an offscreen canvas, then recording that canvas for target duration (~15000ms) */
async function generateBoomerangFromShortClip(shortBlob, targetMs = 15000, targetW = 720){
  // Load short clip into video element
  const tmpVideo = document.createElement('video');
  tmpVideo.src = URL.createObjectURL(shortBlob);
  tmpVideo.muted = true;
  tmpVideo.playsInline = true;
  await tmpVideo.play().catch(()=>{});
  // create canvas sized to match desired aspect (use short clip aspect)
  const vw = tmpVideo.videoWidth || 640;
  const vh = tmpVideo.videoHeight || 480;
  const aspect = vw/vh;
  const outW = targetW;
  const outH = Math.round(outW / aspect);

  const canvas = document.createElement('canvas');
  canvas.width = outW; canvas.height = outH;
  const ctx = canvas.getContext('2d');

  const stream = canvas.captureStream(30);
  let chunks = [];
  const rec = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
  rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
  rec.start();

  const startTime = performance.now();

  // helper to draw frame of tmpVideo (currentTime)
  function drawFrameFromVideo() {
    try {
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      // draw video centered covering canvas
      // drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh)
      const scale = Math.max(canvas.width / tmpVideo.videoWidth, canvas.height / tmpVideo.videoHeight);
      const dw = tmpVideo.videoWidth * scale;
      const dh = tmpVideo.videoHeight * scale;
      ctx.drawImage(tmpVideo, (canvas.width - dw)/2, (canvas.height - dh)/2, dw, dh);
    } catch(e) { /* ignore painting errors */ }
  }

  // play repeated forward + reverse until targetMs
  while (performance.now() - startTime < targetMs) {
    // forward play
    await playOnce(tmpVideo, true, drawFrameFromVideo);
    if (performance.now() - startTime >= targetMs) break;
    // reverse play (simulate reverse by stepping time backward)
    await playOnce(tmpVideo, false, drawFrameFromVideo);
  }

  await sleep(120);
  await new Promise(res => { rec.onstop = res; rec.stop(); });

  const finalBlob = new Blob(chunks, { type: 'video/webm' });
  return finalBlob;

  // helper: playOnce: if forward true do play normally and draw on timeupdate; if false step backward manually
  function playOnce(video, forward=true, drawFn){
    return new Promise((resolve) => {
      if (forward) {
        video.currentTime = 0;
        const onTime = () => { drawFn(); if (video.ended || video.currentTime >= video.duration - 0.001) { video.removeEventListener('timeupdate', onTime); resolve(); } };
        video.addEventListener('timeupdate', onTime);
        video.play().catch(()=>{});
      } else {
        // reverse: manually step from end to start
        video.pause();
        video.currentTime = video.duration;
        const step = () => {
          video.currentTime = Math.max(0, video.currentTime - (1/30)); // step ~1/30s
          drawFn();
          if (video.currentTime > 0.02) {
            requestAnimationFrame(step);
          } else {
            resolve();
          }
        };
        step();
      }
    });
  }
}

/* Main sequence: record short clip and process final boomerang */
async function recordShortClipAndProcess(){
  progressEl.style.display = 'block'; progressEl.textContent = 'Gravando clipe curto (2s)...';
  countdownEl.classList.remove('hidden');
  countdownEl.textContent = '3';
  await sleep(350);
  countdownEl.textContent = '2'; await sleep(350);
  countdownEl.textContent = '1'; await sleep(350);
  countdownEl.textContent = '';
  // record 2s from videoEl
  try {
    shortClipBlob = await recordShortClipMs(2000);
    log('Short clip gravado', shortClipBlob.size);
  } catch(e){ log('Erro gravando short clip', e); progressEl.style.display='none'; throw e; }

  // now create final boomerang by combining forward+reverse loops -> ~15s
  progressEl.textContent = 'Processando boomerang (isso demora um pouco)...';
  finalBoomerangBlob = await generateBoomerangFromShortClip(shortClipBlob, 15000, 720);
  log('Boomerang gerado', finalBoomerangBlob.size);

  // create thumbnail preview (first frame)
  const thumb = await blobToDataURL(finalBoomerangBlob, true).catch(()=>null);
  if (thumb) {
    previewImage.src = thumb;
  } else {
    // fallback: objectURL
    previewImage.src = URL.createObjectURL(finalBoomerangBlob);
  }
  hide(progressEl);
  show(previewScreen);

  // preview controls
  refazerBtn.onclick = async () => {
    hide(previewScreen);
    // allow retake
    await sleep(200);
  };

  continuarBtn.onclick = async () => {
    // send boomerang to server: prefer ArrayBuffer to avoid base64 bloat
    try {
      progressEl.style.display='block'; progressEl.textContent = 'Enviando boomerang...';
      const ab = await finalBoomerangBlob.arrayBuffer();
      socket.emit('boomerang_ready', { session, viewerId: socket.id, filename: `boomerang_${Date.now()}.webm`, data: ab });
      // Also send a thumbnail via photos_submit for compatibility if needed
      if (thumb) socket.emit('photos_submit', { session, viewerId: socket.id, photos: [thumb] });
      log('boomerang_ready emitido');
      progressEl.textContent = 'Enviado';
      await sleep(600);
      progressEl.style.display='none';
      stopCamera();
      hide(previewScreen);
      show(thankScreen);
    } catch(e){ log('Erro enviando boomerang', e); progressEl.textContent = 'Erro no envio'; await sleep(800); progressEl.style.display='none'; }
  };
}

/* Convert blob to dataURL or extract first frame as dataURL */
function blobToDataURL(blob, firstFrame=false){
  return new Promise((resolve, reject) => {
    if (!firstFrame) {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = e => reject(e);
      reader.readAsDataURL(blob);
    } else {
      const v = document.createElement('video');
      v.muted = true; v.playsInline = true;
      v.src = URL.createObjectURL(blob);
      v.onloadeddata = async () => {
        try {
          v.currentTime = 0.03;
          await sleep(80);
          const c = document.createElement('canvas');
          c.width = v.videoWidth || 640;
          c.height = v.videoHeight || 480;
          const ctx = c.getContext('2d');
          ctx.drawImage(v, 0, 0, c.width, c.height);
          resolve(c.toDataURL('image/jpeg', 0.85));
        } catch(e){ reject(e); }
      };
      v.onerror = (e) => reject(e);
    }
  });
}

/* -------------------------
   Clean up on unload
   ------------------------- */
window.addEventListener('beforeunload', () => {
  try { stopCamera(); socket.disconnect(); } catch(e){ }
});

/* expose debug helpers */
window._cabine_mobile = { startCameraFront, stopCamera, recordShortClipAndProcess, generateBoomerangFromShortClip };

log('celular.html carregado â€” pronto.');
</script>
</body>
</html>
