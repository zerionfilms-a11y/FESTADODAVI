<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Cabine FotogrÃ¡fica â€” Celular</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
  <style>
    /* ---------- layout bÃ¡sico ---------- */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#000;color:#fff;overflow:hidden}
    .screen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;padding:15px}
    .screen.visible{display:flex}
    /* Use z-index explÃ­cito para evitar empilhamento inesperado */
    #enterFs{z-index:100}
    #welcomeScreen{z-index:110}
    #cameraScreen{z-index:115}
    #previewScreen{z-index:220}
    #thankScreen{z-index:210}
    /* botÃ£o */
    #enterFsBtn{padding:16px 22px;border-radius:12px;border:none;background:#ffd600;color:#000;font-weight:700;cursor:pointer;font-size:18px;width:90%;max-width:320px}
    #startBtn{padding:14px 20px;border-radius:12px;border:none;background:#fff;color:#0b84ff;font-weight:700;cursor:pointer;font-size:18px;width:90%;max-width:320px}
    .logo{max-width:180px;margin-bottom:18px;border-radius:8px}
    /* camera & canvas */
    #cameraContainer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000;}
    #videoEl{width:100%;height:100%;object-fit:cover;transform:scaleX(-1);display:block}
    #canvasEl{position:absolute;inset:0;display:none}
    /* preview */
    #previewContainer{position:relative;width:100%;height:100%}
    #previewImage{width:100%;height:100%;object-fit:contain;display:block}
    .preview-buttons{position:absolute;bottom:36px;left:16px;right:16px;display:flex;gap:12px;justify-content:center}
    .preview-btn{padding:12px 16px;border-radius:8px;border:none;font-weight:700;cursor:pointer;font-size:16px;background:rgba(0,0,0,0.7);color:#fff}
    #refazerBtn{background:#dc3545}
    #continuarBtn{background:#28a745}
    /* progress/status */
    #statusBar{position:fixed;left:12px;top:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.5);z-index:999;font-weight:700;display:flex;align-items:center;gap:8px}
    #statusDot{width:12px;height:12px;border-radius:50%;background:#b22222;box-shadow:0 0 8px rgba(0,0,0,0.6)}
    #countdown{position:fixed;top:28%;left:0;right:0;text-align:center;font-size:110px;font-weight:800;text-shadow:0 0 20px #000;color:#fff;z-index:500;pointer-events:none}
    /* small screens */
    @media (max-width:480px){ #countdown{font-size:64px} .preview-btn{font-size:14px} }
  </style>
</head>
<body>

  <!-- TELA INICIAL (fundo iniciar.png) -->
  <div id="enterFs" class="screen visible" style="background:url('iniciar.png') center/cover no-repeat;">
    <div style="text-align:center;background:rgba(0,0,0,0.45);padding:18px;border-radius:12px;width:95%;max-width:420px;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <!-- botÃ£o clicÃ¡vel real -->
      <button id="enterFsBtn" aria-label="Entrar em tela cheia">ðŸŽ¬ Entrar em Tela Cheia</button>
      <p style="opacity:0.9;margin-top:12px;font-size:14px">Toque para abrir em tela cheia e iniciar</p>
    </div>
  </div>

  <!-- TELA DE BOAS-VINDAS / INICIAR -->
  <div id="welcomeScreen" class="screen" style="background:linear-gradient(135deg,#001e3c,#0b84ff);">
    <div style="text-align:center;padding:20px;border-radius:12px;background:rgba(255,255,255,0.04);width:95%;max-width:420px;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1 style="margin-bottom:10px">ðŸ“¸ Cabine FotogrÃ¡fica</h1>
      <button id="startBtn">ðŸŽ¬ Iniciar SessÃ£o</button>
    </div>
  </div>

  <!-- TELA DA CÃ‚MERA (mostra vÃ­deo) -->
  <div id="cameraScreen" class="screen" style="background:#000;">
    <div id="cameraContainer">
      <video id="videoEl" autoplay playsinline muted></video>
      <canvas id="canvasEl"></canvas>
    </div>
  </div>

  <!-- PREVIEW -->
  <div id="previewScreen" class="screen" style="background:rgba(0,0,0,0.9);">
    <div id="previewContainer">
      <img id="previewImage" src="" alt="Preview">
      <div class="preview-buttons">
        <button id="refazerBtn" class="preview-btn">ðŸ”„ Refazer</button>
        <button id="continuarBtn" class="preview-btn">âœ… Continuar</button>
      </div>
    </div>
  </div>

  <!-- THANK YOU -->
  <div id="thankScreen" class="screen" style="background:linear-gradient(135deg,#001e3c,#0b84ff);">
    <div style="text-align:center;padding:20px;border-radius:12px;background:rgba(255,255,255,0.04);width:95%;max-width:420px;">
      <img src="logo.png" alt="Logo" class="logo" onerror="this.style.display='none'">
      <h1>âœ¨ Obrigado por usar a cabine!</h1>
      <p id="sendStatus">(enviando...)</p>
      <p style="opacity:0.9;font-size:13px;margin-top:10px">Aguardando confirmaÃ§Ã£o do operador (QR aparecerÃ¡ automaticamente).</p>
    </div>
  </div>

  <!-- STATUS -->
  <div id="statusBar" style="display:none">
    <div id="statusDot"></div>
    <div id="statusText">Aguardando</div>
  </div>

  <div id="countdown" style="display:none"></div>

<script>
/* ----------
  Celular â€” versÃ£o corrigida para evitar telas sobrepostas e tornar fluxo previsÃ­vel
  - Substitua apenas este arquivo no seu public/
  - Backend padrÃ£o (mude se precisar): https://festadodavi.onrender.com
---------- */

(() => {
  const BASE_SERVER = "festadodavi-production-0591.up.railway.app"; // seu backend
  const socket = io(BASE_SERVER, { autoConnect:false, transports:['websocket','polling'] });

  // DOM
  const enterFs = document.getElementById('enterFs');
  const enterFsBtn = document.getElementById('enterFsBtn');
  const welcomeScreen = document.getElementById('welcomeScreen');
  const startBtn = document.getElementById('startBtn');
  const cameraScreen = document.getElementById('cameraScreen');
  const cameraContainer = document.getElementById('cameraContainer');
  const videoEl = document.getElementById('videoEl');
  const canvasEl = document.getElementById('canvasEl');
  const previewScreen = document.getElementById('previewScreen');
  const previewImage = document.getElementById('previewImage');
  const refazerBtn = document.getElementById('refazerBtn');
  const continuarBtn = document.getElementById('continuarBtn');
  const thankScreen = document.getElementById('thankScreen');
  const sendStatus = document.getElementById('sendStatus');
  const statusBar = document.getElementById('statusBar');
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  const countdownEl = document.getElementById('countdown');

  // session from query
  const params = new URLSearchParams(location.search);
  const session = params.get('session') || 'cabine-fixa';

  // state
  let stream = null;
  let photos = [];
  let currentPhotoData = null;
  let currentIndex = 0;
  let sending = false;

  // showScreen utility: garante que sÃ³ UMA tela fica visÃ­vel â€” elimina sobreposiÃ§Ã£o
  function showScreen(target) {
    // todas as telas
    const screens = [enterFs, welcomeScreen, cameraScreen, previewScreen, thankScreen];
    screens.forEach(s => {
      if (!s) return;
      if (s === target) {
        s.classList.add('visible');
        // special handling for camera screen: show/hide cameraContainer
        if (s === cameraScreen) {
          cameraContainer.style.display = 'flex';
          // video MUST be visible when camera screen shown
          if (videoEl.srcObject) videoEl.style.display = 'block';
          canvasEl.style.display = 'none';
        }
      } else {
        s.classList.remove('visible');
      }
    });

    // ensure preview overlay hidden unless target is preview
    if (target !== previewScreen) {
      previewScreen.style.display = previewScreen.classList.contains('visible') ? 'flex' : 'none';
      previewImage.src = previewImage.src; // noop
    } else {
      previewScreen.style.display = 'flex';
    }

    // camera container toggling
    if (target === cameraScreen) {
      cameraContainer.style.display = 'flex';
    } else {
      cameraContainer.style.display = 'none';
    }

    // status bar visibility
    if (target === enterFs || target === welcomeScreen) {
      hideStatus();
    } else {
      showStatus();
    }
  }

  // status helpers
  function showStatus(){ statusBar.style.display = 'flex'; }
  function hideStatus(){ statusBar.style.display = 'none'; }
  function setStatus(text, color) {
    statusText.textContent = text || '';
    statusDot.style.background = color || '#b22222';
    showStatus();
  }

  // camera helpers
  async function startCamera() {
    try {
      const constraints = { video: { facingMode: "user" }, audio: false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream;
      videoEl.style.display = 'block';
      await videoEl.play().catch(()=>{});
      setStatus('CÃ¢mera ativa', '#28a745');
    } catch(e) {
      console.error('Erro cÃ¢mera', e);
      alert('NÃ£o foi possÃ­vel acessar a cÃ¢mera. Verifique permissÃµes.');
      showScreen(welcomeScreen);
      throw e;
    }
  }
  function stopCamera() {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    videoEl.pause();
    videoEl.srcObject = null;
    videoEl.style.display = 'none';
    canvasEl.style.display = 'none';
    setStatus('CÃ¢mera parada', '#b22222');
  }

  // capture one photo with countdown
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function capturePhoto() {
    // ensure video frame ready
    if (!videoEl.videoWidth) {
      // give it a moment
      await sleep(200);
    }

    // countdown visible
    countdownEl.style.display = 'block';
    for (let t=3; t>0; t--) {
      countdownEl.textContent = t === 1 ? 'SORRIA!' : String(t);
      await sleep(900);
    }
    countdownEl.style.display = 'none';

    // draw to canvas and unmirror
    canvasEl.width = videoEl.videoWidth || 1280;
    canvasEl.height = videoEl.videoHeight || 720;
    canvasEl.style.display = 'block';
    const ctx = canvasEl.getContext('2d');
    ctx.save();
    ctx.translate(canvasEl.width,0);
    ctx.scale(-1,1);
    ctx.drawImage(videoEl, 0, 0, canvasEl.width, canvasEl.height);
    ctx.restore();
    const dataUrl = canvasEl.toDataURL('image/jpeg', 0.95);
    return dataUrl;
  }

  // flow: take 3 photos
  async function run3PhotosFlow() {
    photos = [];
    currentIndex = 0;
    try {
      await startCamera();
    } catch(e){ return; }
    showScreen(cameraScreen);

    while (currentIndex < 3) {
      setStatus(`${currentIndex+1}/3`, '#ffc107');
      const dataUrl = await capturePhoto();
      currentPhotoData = dataUrl;

      // show preview
      previewImage.src = currentPhotoData;
      // preview visible and block camera underneath
      showScreen(previewScreen);

      // wait for user choice
      const decision = await new Promise((resolve) => {
        const onRef = () => { refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); resolve('refazer'); };
        const onCont = () => { refazerBtn.removeEventListener('click', onRef); continuarBtn.removeEventListener('click', onCont); resolve('continuar'); };
        refazerBtn.addEventListener('click', onRef);
        continuarBtn.addEventListener('click', onCont);
      });

      if (decision === 'refazer') {
        // just continue the loop without increment
        showScreen(cameraScreen);
        await sleep(180);
        continue;
      } else {
        photos.push(currentPhotoData);
        currentIndex++;
        showScreen(cameraScreen);
        await sleep(180);
        continue;
      }
    }

    // finished
    stopCamera();
    showScreen(thankScreen);
    sendStatus.textContent = '(enviando...)';
    await sendPhotosToServer();
  }

  /* ---------------------- SOCKET + SEND ---------------------- */
  function ensureSocketConnected() {
    return new Promise((resolve) => {
      if (socket && socket.connected) {
        resolve(true);
        return;
      }
      // connect and wait a little
      socket.connect();
      let waited = 0;
      const iv = setInterval(() => {
        if (socket.connected) {
          clearInterval(iv);
          resolve(true);
        } else if (waited > 6000) {
          clearInterval(iv);
          resolve(false);
        }
        waited += 300;
      }, 300);
    });
  }

  async function sendPhotosToServer() {
    if (!photos || photos.length === 0) {
      sendStatus.textContent = '(nenhuma foto)';
      return false;
    }
    if (sending) return false;
    sending = true;

    setStatus('Conectando ao servidor...', '#ffc107');
    const ok = await ensureSocketConnected();
    if (!ok) {
      setStatus('Falha conexÃ£o', '#b22222');
      sendStatus.textContent = '(erro: sem conexÃ£o)';
      sending = false;
      return false;
    }

    setStatus('Enviando fotos...', '#ffc107');
    // emit with session
    socket.emit('photos_from_cell', { session, photos });
    // Wait for photos_ready event or timeout
    const confirmed = await waitForServerConfirmation(12000);
    if (confirmed) {
      setStatus('Enviado e confirmado', '#28a745');
      sendStatus.textContent = '(enviado)';
    } else {
      setStatus('Sem confirmaÃ§Ã£o do servidor', '#b22222');
      sendStatus.textContent = '(erro no envio)';
    }
    sending = false;
    return confirmed;
  }

  function waitForServerConfirmation(timeout = 10000) {
    return new Promise((resolve) => {
      let done = false;
      const onPhotosReady = (payload) => {
        if (payload && payload.session && payload.session !== session) return;
        if (!done) { done = true; cleanup(); resolve(true); }
      };
      const onVisualizer = (payload) => {
        if (payload && payload.session && payload.session !== session) return;
        if (!done) { done = true; cleanup(); resolve(true); }
      };
      function cleanup() {
        socket.off('photos_ready', onPhotosReady);
        socket.off('visualizer_ready', onVisualizer);
        clearTimeout(timer);
      }
      socket.on('photos_ready', onPhotosReady);
      socket.on('visualizer_ready', onVisualizer);
      const timer = setTimeout(() => {
        if (!done) { done = true; cleanup(); resolve(false); }
      }, timeout);
    });
  }

  // socket events
  socket.on('connect', () => {
    setStatus('Socket: conectado', '#28a745');
    // join our session room
    socket.emit('join_session', { session, role: 'viewer' });
  });
  socket.on('disconnect', (reason) => {
    setStatus('Socket: desconectado', '#b22222');
  });
  socket.on('photos_ready', (payload) => {
    // server confirms photos: if this client is in thankScreen, show confirmed
    if (payload && payload.session === session) {
      setStatus('Servidor: fotos prontas', '#28a745');
    }
  });
  socket.on('visualizer_ready', (payload) => {
    if (payload && payload.session === session) {
      setStatus('Visualizador pronto', '#28a745');
    }
  });
  socket.on('finalize_session', (payload) => {
    if (payload && payload.session === session) {
      // operator finalizou sessÃ£o: volta ao inÃ­cio
      photos = [];
      currentIndex = 0;
      currentPhotoData = null;
      sendStatus.textContent = '(pronto)';
      showScreen(enterFs);
      setStatus('Pronto', '#28a745');
    }
  });
  socket.on('reset_session', (payload) => {
    if (payload && payload.session === session) {
      photos = [];
      currentIndex = 0;
      currentPhotoData = null;
      sendStatus.textContent = '(resetado)';
      showScreen(enterFs);
      setStatus('Pronto', '#b22222');
    }
  });

  /* ---------------------- UI binding ---------------------- */
  enterFsBtn.addEventListener('click', async () => {
    try { await document.documentElement.requestFullscreen(); } catch(e){ /* ignore */ }
    // connect socket and show welcome screen
    showScreen(welcomeScreen);
    // start socket connection (safe to call multiple times)
    if (!socket.connected) socket.connect();
  });

  startBtn.addEventListener('click', async () => {
    // start flow: camera -> 3 photos -> send
    showScreen(cameraScreen);
    await run3PhotosFlow();
  });

  // ensure preview buttons have focusable behavior (handlers already used in capture flow)
  refazerBtn.addEventListener('click', ()=>{ /* handled inside run3PhotosFlow */ });
  continuarBtn.addEventListener('click', ()=>{ /* handled inside run3PhotosFlow */ });

  // initial UI
  showScreen(enterFs);
  setStatus('Pronto', '#b22222');

  // expose for debug
  window._celular = {
    showScreen, startCamera, stopCamera, photos, sendPhotosToServer, socket
  };

})();
</script>
</body>
</html>
